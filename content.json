{"meta":{"title":"RON BLOG","subtitle":"Ron, open the door.","description":"Cumulate","author":"Ron","url":"https://gitflhub.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-12T01:12:21.732Z","updated":"2021-05-25T14:17:28.640Z","comments":false,"path":"/404.html","permalink":"https://gitflhub.github.io/404.html","excerpt":"","text":""},{"title":"关于我","date":"2021-10-20T11:09:59.211Z","updated":"2021-10-20T11:09:59.211Z","comments":false,"path":"about/index.html","permalink":"https://gitflhub.github.io/about/index.html","excerpt":"","text":"个人简介1234CUMT 地理信息科学 本科生UESTC 计算机技术 研究生Java 开发工程师NLP,深度学习 本心初衷123有大厂梦也常有听闻中年危机规划走算法职业路线。 个人履历12345678910111213142019-07 月 本科毕业2019-07 至 2020-07 在南京担任Java开发工程师2020-07 至 2020-12 考研初试准备2021-03 至 2021-03 考研复试准备2021-04 至 2021-06入学前就职2021-07 至 2021-08 入学前学习2021-09 至 2022-08学习NLP等 个人规划1234567891011122019-07 月 拿到开发工程师OFFER(已完成)2020-07 至 2021-04 获取研究生入学资格(已完成)2021-05 至 2021-08 入学前自主学习算法(已完成)2021-09 至 2023-08 入学后系统学习(进行中)2023 拿到大厂实习OFFER(未开始)/计划可能调整为发Paper,导师不放实习2024 拿到大厂OFFER(未开始) 博客：www.ron.zone Github: github.com/GitFLHub"},{"title":"友情链接","date":"2021-07-12T01:12:21.762Z","updated":"2021-05-25T14:17:28.643Z","comments":true,"path":"links/index.html","permalink":"https://gitflhub.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-15T03:54:36.826Z","updated":"2021-05-25T14:17:28.643Z","comments":false,"path":"repository/index.html","permalink":"https://gitflhub.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-12T01:12:22.020Z","updated":"2021-05-25T14:17:28.644Z","comments":false,"path":"tags/index.html","permalink":"https://gitflhub.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-15T03:54:55.446Z","updated":"2021-05-25T14:17:28.642Z","comments":false,"path":"books/index.html","permalink":"https://gitflhub.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-12T01:12:21.759Z","updated":"2021-05-25T14:17:28.642Z","comments":false,"path":"categories/index.html","permalink":"https://gitflhub.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"SACN","slug":"End-to-End Structure-Aware Convolutional Networks for Knowledge Base Completion","date":"2022-03-03T05:01:42.000Z","updated":"2022-03-03T05:54:04.659Z","comments":true,"path":"2022/03/03/End-to-End Structure-Aware Convolutional Networks for Knowledge Base Completion/","link":"","permalink":"https://gitflhub.github.io/2022/03/03/End-to-End%20Structure-Aware%20Convolutional%20Networks%20for%20Knowledge%20Base%20Completion/","excerpt":"","text":"SACNEnd-to-End Structure-Aware Convolutional Networks for Knowledge Base Completion基于端到端结构感知卷积神经网络的知识构建创新点Structure-Aware Convolutional Network (SACN) 将GCN和ConvE结合 Encoder加权图卷积网络 Weighted graph convolutional network (WGCN) WGCN 利用了图结构的节点信息和关系信息。图节点的权重可调（节点值？边值？），可以适应本地聚合中使用的来自邻居的信息量。 通过聚合的实体来表示实体（？） DecoderConv-TransE (在之前的论文里，提到) 通过恢复原始的三元组来表示关系（？） Encoder 和 Decoder编码器和解码器都通过 减小交叉熵误差 进行联合训练 WGCNGCN的扩展，在聚合时，对不同类型的关系进行不同的加权。 WGCN将多关系KB图视为多个单关系子图，其中每个子图都包含特定类型的关系。WGCN确定在组合节点的GCN嵌入时给每个子图赋予不同的权重。 WGCNWGCN: Graph Convolutional Networks with Weighted Structural Features具有加权结构特征的图卷积网络通过图的连通性和拓扑性的信息,可以调整学习节点的表示. 针对已有的模型来考虑解决问题 采用平均权重的方式 采用局部区分内外邻居的方式 没有考虑到局部拓扑的因素 提出了一种 加权结构特征的图卷积网络 思路： WGCN 首先收集结构信息（有向边的方向和度数（出入度）感知的随机游走算法？重启算法？） 前置过程的交互信息被作为节点的结构特征，进一步获取节点间的依赖和拓扑信息。 其他模型： 聚合节点的图内容和结构 GAT 采用注意力机制只考虑内容的相似性，没有考虑到拓扑结构的相似性 将边视为双向边，在获取节点的结构信息的时候，节点的权值与方向无关（会忽略不可逆转的信息，如时间序列想）。 区分方向结构使用单挑赋权参数的方式。（不能获取节点的密度，或者区分节点的几何重构关系） GCN 不能获取到长依赖，GCN不能区分非同构图？","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://gitflhub.github.io/tags/Machine-Learning/"}]},{"title":"SMO 的计算过程","slug":"SMO 的计算过程","date":"2021-11-04T08:49:50.000Z","updated":"2021-11-04T09:01:04.689Z","comments":true,"path":"2021/11/04/SMO 的计算过程/","link":"","permalink":"https://gitflhub.github.io/2021/11/04/SMO%20%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/","excerpt":"","text":"SMO 的定义SMO的思想类似坐标上升算法，我们需要优化一系列的αα的值，我们每次选择尽量少的$\\alpha$ 来优化，不断迭代直到函数收敛到最优值。 来到SVM的对偶问题上，对偶形式: arg \\max \\limits_{\\alpha} \\sum_{i=1}^{N} \\alpha_{i} - \\frac{1}{2}\\sum_{i=1}^{N}\\sum_{j=1}^{N}y_{i}y_{j}\\alpha_{i}\\alpha_{j}\\langle x_{i}, x_{j} \\ranglesubject to $\\alpha{i} \\ge 0$ , $\\sum{i=1}^{N}\\alpha{i}y{i}=0$ 其中我们需要对$(\\alpha{1}, \\alpha{2}, …, \\alpha_{N})$ 进行优化，但是这个凸二次优化问题的其他求解算法的复杂度很高，但是Platt提出的SMO算法可以高效的求解上述对偶问题，他把原始问题的求解$N$ 个参数二次规划问题分解成多个二次规划问题求解，每个字问题只需要求解2各参数，节省了时间成本和内存需求。 与坐标上升算法不同的是，我们在SMO算法中我们每次需要选择一对变量 $(\\alpha_i, \\alpha_j)$ , 因为在SVM中，我们的 并不是完全独立的，而是具有约束的: \\sum_{i=1}^{N}\\alpha_{i}y_{i} = 0因此一个 $\\alpha$ 改变，另一个也要随之变化以满足条件。 SMO 的计算过程题目对以下数据点，求出其最优的超平面 x_1=(1,2,3),y_1=+1\\\\ x_2=(4,1,2),y_1=+1\\\\ x_3=(-1,2,1),y_1=-1解答构建训练集约束最优化问题： \\begin{align} &\\mathop{max}_{\\lambda}(-\\frac{1}{2}\\sum_{i=0}^{n}\\sum_{j=0}^{n}\\lambda_{i}\\lambda_{j}y_{i}y_{j}(x_{i},x_{j}) + \\sum_{i=0}^{n}\\lambda_{i})\\\\ =&\\mathop{min}_{\\lambda}(\\frac{1}{2}\\sum_{i=0}^{n}\\sum_{j=0}^{n}\\lambda_{i}\\lambda_{j}y_{i}y_{j}(x_{i},x_{j}) - \\sum_{i=0}^{n}\\lambda_{i})\\\\ \\end{align}令 \\begin{align} &L(\\lambda_1,\\lambda_2,\\lambda_3)\\\\ =&\\frac{1}{2}(\\lambda_{1}\\lambda_{1}(1*1)(x_{11}^{2}+x_{12}^{2}+x_{13}^{2})+\\lambda_{1}\\lambda_{2}(1*1)(x_{11}*x_{21}+x_{12}*x_{22}+x_{13}*x_{23})\\\\ &+\\lambda_{1}\\lambda_{3}(1*-1)(x_{11}*x_{31}+x_{12}*x_{32}+x_{13}*x_{33})+\\lambda_{2}\\lambda_{1}(1*1)(x_{21}*x_{11}+x_{22}*x_{12}+x_{23}*x_{13})\\\\ &+\\lambda_{2}\\lambda_{2}(1*1)(x_{21}^{2}+x_{22}^{2}+x_{23}^{2})+\\lambda_{2}\\lambda_{3}(1*-1)(x_{21}*x_{31}+x_{22}*x_{32}+x_{23}*x_{33})\\\\ &+\\lambda_{3}\\lambda_{1}(1*-1)(x_{31}*x_{11}+x_{32}*x_{12}+x_{33}*x_{13})+\\lambda_{3}\\lambda_{2}(1*-1)(x_{31}*x_{21}+x_{32}*x_{22}+x_{33}*x_{23})\\\\ &+\\lambda_{3}\\lambda_{3}(-1*-1)(x_{31}^{2}+x_{32}^{2}+x_{33}^{2})- \\sum_{i=0}^{n}\\lambda_{i}\\\\ =&\\frac{1}{2}(14\\lambda_{1}^2+24\\lambda_{1}\\lambda_{2}+21\\lambda_{2}^2+8\\lambda_{2}\\lambda_{3}+6\\lambda_{3}^2)-\\sum_{i=0}^{n}\\lambda_{i}\\\\ \\end{align}其中 1*\\lambda_1 + 1 * \\lambda_2-1*\\lambda_3=0所以 \\lambda_3=\\lambda_1+\\lambda_2代入上式得 L(\\lambda_1,\\lambda_2)=\\frac{1}{2}(20\\lambda_{1}^2+44\\lambda_{1}\\lambda_{2}+35\\lambda_{2}^2)-2(\\lambda_1+\\lambda_2)为求$L(\\lambda1,\\lambda_2)$的最小值，分别对$\\lambda{1},\\lambda_{2}$求偏导的： \\left \\{ \\begin{array}{c} 20\\lambda_1+22\\lambda_2-2=0\\\\ 22\\lambda_1+35\\lambda_2-2=0 \\end{array} \\right.解得 \\left \\{ \\begin{array}{c} \\lambda_1 = \\frac{49}{270}\\\\ \\lambda_2= -\\frac{2}{27} \\end{array} \\right.不符合$\\lambda_{i}(1\\leqslant i\\leqslant n) &gt; 0$，考虑极值点在边缘 当$\\lambda_{1}=0$时，在点$(0, \\frac{2}{35})$取得极小值$-\\frac{2}{35}$ 当$\\lambda_{2}=0$时，在点$(\\frac{1}{10}, 0)$取得极小值$-\\frac{1}{10}$ 所以在点$(\\frac{1}{10}, 0)$取得最小值$-\\frac{1}{10}$ 所以$\\lambda_1 = \\frac{1}{10}, \\lambda_2=0,\\lambda_2=\\frac{1}{10}$ \\begin{align} W^*&=\\lambda_1 * x_1 + \\lambda_2 * x_2 + \\lambda_3 * x_3\\\\ &=(0, \\frac{2}{5}, \\frac{1}{5})\\\\ b&=1-(0, \\frac{2}{5}, \\frac{1}{5})\\odot(1,2,3)\\\\ &=-\\frac{2}{5} \\end{align}最大间隔超平面的表达式为 \\begin{align} y&=W^*(x_1,x_2,x_3)^T+b\\\\ &=\\frac{2}{5}x_2+\\frac{1}{5}x_3-\\frac{2}{5} \\end{align}","categories":[],"tags":[{"name":"SMO","slug":"SMO","permalink":"https://gitflhub.github.io/tags/SMO/"},{"name":"SVM","slug":"SVM","permalink":"https://gitflhub.github.io/tags/SVM/"}]},{"title":"Transformer 的 Position Embedding 理解","slug":"Transformer 的 Position Embedding 的理解","date":"2021-10-21T00:20:48.000Z","updated":"2021-10-21T04:04:43.726Z","comments":true,"path":"2021/10/21/Transformer 的 Position Embedding 的理解/","link":"","permalink":"https://gitflhub.github.io/2021/10/21/Transformer%20%E7%9A%84%20Position%20Embedding%20%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"参考链接：视频：Bilibili:Transformer的位置编码（Position Encoding）进展梳理_哔哩哔哩_bilibili 笔记：PosEnc 模型示例: 位置编码公式： PE_{(k, 2i)} = \\sin(k/10000^{\\frac{2i}{d_{model}}})\\\\PE_{(k, 2i + 1)} = \\cos(k/10000^{\\frac{2i}{d_{model}}})\\\\k :{元素在序列中位置} \\\\i:{用于表示列数}\\\\d_{model}:模型的维数公式理解:在Transformer中，输入Encoder或者Decoder中的向量为 Embedding Vector + Position Embedding Vector。 将 Embedding Vector 和 Position Embedding Vector 分别表示为$e_i$和$p_i$。 后续的计算过程可以视为 \\begin{equation}\\begin{split} (e_i + p_i)^TW_Q^TW_k(e_j+p_j)&=e_i^TW_Q^TW_ke_j+p_i^TW_Q^TW_ke_j\\\\ &+e_i^TW_Q^TW_kp_j+p_i^TW_Q^TW_kp_j \\end{split}\\end{equation}$e_i^TW_Q^TW_ke_j$ 是表示词向量之间的运算 $p_i^TW_Q^TW_ke_j$ 和$e_i^TW_Q^TW_kp_j$分别包含了两个词向量的绝对位置的信息 $p_i^TW_Q^TW_kp_j$简化看成为$p_i^Tp_j$。现在想要将其转化为和相对位置有关的向量，即$i-j$的形式 又因为 \\begin{equation}\\begin{split} p_i^Tp_j&=(p_{i1},p_{i2},...,p_{id_{model}})^T(p_{j1},p_{j2},...,p_{jd_{model}})\\\\ &=p_{i1}p_{j1}+p_{i2}p_{j2}+...+p_{id_{model}}p_{jd_{model}} \\end{split}\\end{equation}再结合 PE_{(k, 2i)} = \\sin(k/10000^{\\frac{2i}{d_{model}}})\\\\PE_{(k, 2i + 1)} = \\cos(k/10000^{\\frac{2i}{d_{model}}})可以理解为 \\begin{equation}\\begin{split} p_i^Tp_j&=(p_{i1},p_{i2},...,p_{id_{model}})^T(p_{j1},p_{j2},...,p_{jd_{model}})\\\\ &=p_{i1}p_{j1}+p_{i2}p_{j2}+...+p_{id_{model}}p_{jd_{model}}\\\\ &=\\cos(i/10000^{\\frac{2*1}{d_{model}}})\\cos(j/10000^{\\frac{2*1}{d_{model}}}) + \\sin(i/10000^{\\frac{2*1}{d_{model}}})\\sin(j/10000^{\\frac{2*1}{d_{model}}})+...\\\\ &=cos((i-j)/10000^{\\frac{2*1}{d_{model}}}) + cos((i-j)/10000^{\\frac{2*2}{d_{model}}}) + ... + cos((i-j)/10000^{\\frac{2*d_{model}/2}{d_{model}}})\\\\ &=g(i-j) \\end{split}\\end{equation}于是最终被表示成了相对位置的形式。","categories":[],"tags":[{"name":"NLP","slug":"NLP","permalink":"https://gitflhub.github.io/tags/NLP/"}]},{"title":"PCA","slug":"PCA","date":"2021-09-14T12:22:08.000Z","updated":"2021-09-14T12:25:49.264Z","comments":true,"path":"2021/09/14/PCA/","link":"","permalink":"https://gitflhub.github.io/2021/09/14/PCA/","excerpt":"","text":"PCA1234567891011121314151617181920212223242526272829303132333435def compute_pca(X, n_components=2): &quot;&quot;&quot; Input: X: of dimension (m,n) where each row corresponds to a word vector n_components: Number of components you want to keep. Output: X_reduced: data transformed in 2 dims/columns + regenerated original data &quot;&quot;&quot; ### START CODE HERE (REPLACE INSTANCES OF &#x27;None&#x27; with your code) ### # mean center the data X_demeaned = X- np.mean(X, axis=0) # calculate the covariance matrix covariance_matrix = np.cov(X_demeaned, rowvar=False) # 计算协方差采用的是去平均值矩阵，还要添加rowvar参数 # calculate eigenvectors &amp; eigenvalues of the covariance matrix eigen_vals, eigen_vecs = np.linalg.eigh(covariance_matrix) # sort eigenvalue in increasing order (get the indices from the sort) idx_sorted = np.argsort(eigen_vals) # reverse the order so that it&#x27;s from highest to lowest. idx_sorted_decreasing = np.argsort(-eigen_vals) # sort the eigen values by idx_sorted_decreasing eigen_vals_sorted = eigen_vals[idx_sorted_decreasing] # sort eigenvectors using the idx_sorted_decreasing indices eigen_vecs_sorted = eigen_vecs[:,idx_sorted_decreasing] # 选取特征向量的时候注意要采用matrix[:,排序索引] 不可采用 matrix[排序索引] 因为调整的是列向量的顺序 # select the first n eigenvectors (n is desired dimension # of rescaled data array, or dims_rescaled_data) eigen_vecs_subset = eigen_vecs_sorted[:,0:n_components] # transform the data by multiplying the transpose of the eigenvectors # with the transpose of the de-meaned data # Then take the transpose of that product. X_reduced = np.dot(X_demeaned, eigen_vecs_subset) ### END CODE HERE ### return X_reduced","categories":[{"name":"categories","slug":"categories","permalink":"https://gitflhub.github.io/categories/categories/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://gitflhub.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"PCA","slug":"PCA","permalink":"https://gitflhub.github.io/tags/PCA/"}]},{"title":"Anki 常用插件","slug":"Anki 常用插件","date":"2021-07-06T02:44:21.000Z","updated":"2021-07-06T03:06:58.051Z","comments":true,"path":"2021/07/06/Anki 常用插件/","link":"","permalink":"https://gitflhub.github.io/2021/07/06/Anki%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","excerpt":"","text":"Anki 插件推荐 Anki 插件名称 插件介绍 插件ID AnkiConnect 实现 Anki 与外界通信 2055492159 Enhance main window 增强主页 877182321 Review Heatmap 复习热力图，记录学习日历 1771074083 Evernote Importer 支持印象笔记 831016260 Markdown and KaTeX Support 支持 MarkDown 和数学公式 1087328706 Word Query (查询大卡片单词词义音标等) 775418273","categories":[{"name":"资料整理","slug":"资料整理","permalink":"https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Anki","slug":"Anki","permalink":"https://gitflhub.github.io/tags/Anki/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://gitflhub.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]},{"title":"开源数据集","slug":"开源数据集","date":"2021-07-05T13:49:03.000Z","updated":"2021-07-06T00:49:20.481Z","comments":true,"path":"2021/07/05/开源数据集/","link":"","permalink":"https://gitflhub.github.io/2021/07/05/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86/","excerpt":"","text":"开放数据集• DataHub (http://datahub.io/dataset)• World Health Organization (http://www.who.int/research/en/)• Data.gov (http://data.gov)• European Union Open Data Portal (http://open-data.europa.eu/en/data/)• Amazon Web Service public datasets (http://aws.amazon.com/datasets)• Facebook Graph (http://developers.facebook.com/docs/graph-api)• Healthdata.gov (http://www.healthdata.gov)• Google Trends (http://www.google.com/trends/explore)• Google Finance (https://www.google.com/finance)• Google Books Ngrams (http://storage.googleapis.com/books/ngrams/books/datasetsv2.html)• Machine Learning Repository (http://archive.ics.uci.edu/ml/)","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"开放数据集","slug":"开放数据集","permalink":"https://gitflhub.github.io/tags/%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E9%9B%86/"}]},{"title":"Machine Learning","slug":"Machine Learning","date":"2021-07-05T13:01:42.000Z","updated":"2022-03-03T05:48:24.840Z","comments":true,"path":"2021/07/05/Machine Learning/","link":"","permalink":"https://gitflhub.github.io/2021/07/05/Machine%20Learning/","excerpt":"","text":"学习库Numpy 科学计算库 Pandas 数据分析可视化 Matplotlib 数据可视化 Scikit-learn 机器学习库 知识点线性代数矩阵数组 算法监督学习分类：最终属于1还是0 回归：最终一个具体值 例子1：房价预测（回归） 例子2：肿瘤预测（分类）一个属性 两个属性（特征） 无穷多特征：向量机 算法代价函数 一个参数的代价函数可以化为一个一元二次函数 两个参数的代价函数可以化为一个二元二次函数 更多参数可以考虑梯度下降的方式 梯度下降需要考虑步伐大小，大小学习速率过慢，太大会错过最优解，甚至会导致发散 步长α是动态调整的， 梯度下降只适用于求解线性回归。（为弓形图像） 多元梯度下降 特征缩放 也可以采取减去均值再除以范围 特征或多项式回归 正规方程如果X ^ TX是不可逆的，常见的原因可能是: 冗余特征，即两个特征密切相关(即线性相关) 太多的特性(例如m≤n)。在这种情况下，删除一些特性或使用“正则化” 正规方程和梯度下降比较 梯度下降 正规方程需要 需要选择确定学习速率α 不需要选择确定学习速率α 需要多次迭代 不需要迭代 O (kn^2) O (n^3), 需要计算 X^TX的逆矩阵 n 非常大时任然适用 n太大计算缓慢 聚类算法","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://gitflhub.github.io/tags/Machine-Learning/"}]},{"title":"Vocabulary","slug":"Vocabulary","date":"2021-06-03T09:17:43.000Z","updated":"2021-07-05T14:06:57.273Z","comments":true,"path":"2021/06/03/Vocabulary/","link":"","permalink":"https://gitflhub.github.io/2021/06/03/Vocabulary/","excerpt":"","text":"threshold","categories":[{"name":"English","slug":"English","permalink":"https://gitflhub.github.io/categories/English/"}],"tags":[{"name":"生词","slug":"生词","permalink":"https://gitflhub.github.io/tags/%E7%94%9F%E8%AF%8D/"}]},{"title":"Octave 基础","slug":"Octave-基础","date":"2021-05-31T13:01:42.000Z","updated":"2021-05-31T13:03:42.979Z","comments":true,"path":"2021/05/31/Octave-基础/","link":"","permalink":"https://gitflhub.github.io/2021/05/31/Octave-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"工具1. Octave函数常用操作 函数名称 描述 svd (singular value decomposition) 奇异值分解 pinv 求逆矩阵 inv 伪逆矩阵 ‘ 转置 ^ 指数运算 == bool判断 ~= 不等于判断 &amp;&amp; 逻辑与 “双竖杠” 或 xor 逻辑或 PS1(“&gt;&gt; “) 定义默认的提示符 = 赋值 pi 圆周率 disp 打印字符串 sprintf 拼接字符串 format long 默认long型字符串 format short 默认short型字符串 A = [1 2; 3 4; 5 6] 定义矩阵 v = 1:0.1:2 从1到2，生成步长为0.1的数组 ones(2,3) 生成两行三列的1矩阵 zeros(1, 3) 生成一行三列的零矩阵 rand(1,3) 随机生成一行三列的行矩阵 randn(1,3) 生成三个符合方差，标准差为1的正态分布的随机数 hist(数组，默认5柱) 生成样本直方图 hist(数组, 50) 生成50柱直方图 eye(4) 四阶单位矩阵 help eye 查看eye指令的用法 q 退出 size(A) 查看矩阵的大小，1x2的矩阵 size(A，n) 返回矩阵的第n个纬度大小 length(v) 最大维度的大小 文件操作 函数名称 描述 pwd Octave当前路径 cd 改变路径 ls 列出当前路径文件 load feature.dat 或 load（‘feature.dat’） 加载文件 who 查看当前变量 whos 查看当前变量详情，大小，类别 clear featurex 删除 featurex save hello.mat v; 将v写入hello.mat文件中","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Octave","slug":"Octave","permalink":"https://gitflhub.github.io/tags/Octave/"},{"name":"工具","slug":"工具","permalink":"https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Octave 绘制图像","slug":"Octave 绘制图像","date":"2021-05-28T13:01:42.000Z","updated":"2021-07-15T03:55:58.622Z","comments":true,"path":"2021/05/28/Octave 绘制图像/","link":"","permalink":"https://gitflhub.github.io/2021/05/28/Octave%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","excerpt":"","text":"Octace 绘制图像二维图像三角函数123456# 生成从0 到 0.98 的数组，步长为0.01t = [0:0.01:0.98]; # 构造y1 和 t的关系式y1 = sin(2*pi*4*t); # 生成二维图像plot(t,y1); 1234# 构造y21 和 t的关系式y2 = cos(2*pi*4*t); # 生成二维图像plot(t,y2); 在原有基础上添加第一个图像 1234# 保留绘制的第一个图hold on# 继续绘制第二个图plot(t,y1,&#x27;r&#x27;) 12345678910# x轴标签xlabel(&#x27;time&#x27;) # y轴标签ylabel(&#x27;value&#x27;) # 线型标注legend(&#x27;sin&#x27;,&#x27;cos&#x27;) # 图表名称title(&#x27;my plot&#x27;) # 输出图片print -dpng &#x27;myplot.png&#x27; 显示多个图像12345678910# 分割出第一个子图 1 * 2 两个子图subplot(1,2,1); # 填充第一个子图plot(t,y1); # 分割出第二个子图subplot(1,2,2);# 填充第二个子图plot(t,y2);# 设置第二个子图的坐标轴范围axis([0.5 1 -1 1]) 矩阵图示12345678910# 随机生成5*5矩阵A = magic(5)# 图示矩阵imagesc(A)A = 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9 12345678A = 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9# 组合命令 colorbar 生成条状尺度图 gray 灰度图imagesc(A), colorbar, colormap gray; 12# 更大的尺度图imagesc(magic(25)), colorbar, colormap gray;","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Octave","slug":"Octave","permalink":"https://gitflhub.github.io/tags/Octave/"},{"name":"工具","slug":"工具","permalink":"https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Markdown 公式编辑","slug":"Markdown-公式编辑","date":"2021-05-27T13:01:42.000Z","updated":"2021-11-10T12:27:53.023Z","comments":true,"path":"2021/05/27/Markdown-公式编辑/","link":"","permalink":"https://gitflhub.github.io/2021/05/27/Markdown-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/","excerpt":"","text":"行内公式是在公式代码块的基础上前面加上$ ，后面加上$ 组成的，而行间公式则是在公式代码块前后使用$$ 和$$ 。 1.1 行内公式行内公式：$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $ 效果： $\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $ 1.2 行间公式行间公式：$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 效果： \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.2. 希腊字母 名称 大写 code 小写 code alpha A A α \\alpha beta B B β \\beta gamma Γ \\Gamma γ \\gamma delta Δ \\Delta δ \\delta epsilon E E ϵ \\epsilon zeta Z Z ζ \\zeta eta H H η \\eta theta Θ \\Theta θ \\theta iota I I ι \\iota kappa K K κ \\kappa lambda Λ \\Lambda λ \\lambda mu M M μ \\mu nu N N ν \\nu xi Ξ \\Xi ξ \\xi omicron O O ο \\omicron pi Π \\Pi π \\pi rho P P ρ \\rho sigma Σ \\Sigma σ \\sigma tau T T τ \\tau upsilon Υ υ υ \\upsilon phi Φ \\Phi ϕ \\phi chi X X χ \\chi psi Ψ \\Psi ψ \\psi omega Ω \\Omega ω \\omega 3. 上下标上标 $x^2$ : $x^2$ 下标$x_1$ : $x_1$ 组合$x^2_1$ : $x^2_1$ 注意：例如$x{12}$源码为： $x{12}$。注意其中的中括号{} 多级上标${x^5}^6$：需要用中括号{}划分界限${x\\^5}\\^6$, $x\\^{5\\^6}$ 两种方式均可以 4. 括号4.1 小括号与方括号使用原始的( ) ，[ ] 即可 如(2+3)[4+4]：$(2+3)[4+3]$ 复杂例子： $(\\frac{x}{y})$： 可表示为\\left(\\frac{x}{y}\\right) 或(\\frac{x}{y}) 4.2 大括号由于大括号&#123;&#125; 被用于分组，因此需要使用\\&#123;和\\&#125;表示大括号，也可以使用\\lbrace 和\\rbrace来表示。 如\\{a*b\\}:a∗b 或\\lbrace a*b\\rbrace :a*b表示：${a*b}:a∗b$ 4.3 尖括号 区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如\\langle x \\rangle 表示：$\\langle x \\rangle$。 5. 求和与积分5.1 求和\\sum 用来表示求和符号，其下标表示求和下限，上标表示上限。 如:\\sum_{r=1}^n表示：$\\sum_{r=1}^n$ 5.2 积分\\int 用来表示积分符号，同样地，其上下标表示积分的上下限。如，\\int_{r=1}^\\infty表示：$\\int_{r=1}^\\infty$ 多重积分同样使用 int ，通过 i 的数量表示积分导数： \\iint表示： $\\iint$， \\iint\\表示： $\\iiint$， \\iiiint表示： $\\iiiint$， 5.3 连乘\\prod &#123;a+b&#125;，输出：$\\prod {a+b}$ \\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)，输出：$\\prod_{i=1}^{k}({a+b})$ \\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)，输出$\\prod_{i=1}^{k}({a+b})$ a \\times b 输出$a \\times b$ 5.4 其他类似\\prod : $\\prod$ \\bigcup : $\\bigcup$ \\bigcap : $\\bigcap$ \\arg\\,\\\\max_&#123;c_k&#125; : $arg\\, \\max{c_k}$ 6. 分式与根式6.1 分式第一种，使用\\frac ab，\\frac作用于其后的两个组a ，b ，结果为 $\\frac ab$ 如果你的分子或分母不是单个字符，请使用&#123;..&#125;来分组，比如\\frac &#123;a+c+1&#125;&#123;b+c+2&#125;表示：$\\frac {a+c+1}{b+c+2}$ 第二种，使用\\over来分隔一个组的前后两部分，如&#123;a+1\\over b+1&#125;：${a+1\\over b+1}$ 6.2 连分式书写连分数表达式时，请使用\\cfrac代替\\frac或者\\over两者效果对比如下：\\frac 表示如下： x=a_0 + \\frac &#123;1^2&#125;&#123;a_1 + \\frac &#123;2^2&#125;&#123;a_2 + \\frac &#123;3^2&#125;&#123;a_3 + \\frac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125; x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}\\cfrac 表示如下：x=a_0 + \\cfrac &#123;1^2&#125;&#123;a_1 + \\cfrac &#123;2^2&#125;&#123;a_2 + \\cfrac &#123;3^2&#125;&#123;a_3 + \\cfrac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125; x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}6.3 根式根式使用\\sqrt 来表示：$\\sqrt{\\pi}$ 如开4次方：\\sqrt[4]&#123;\\frac xy&#125;:$\\sqrt[4]{\\frac xy}$ 开平方：\\sqrt &#123;a+b&#125;：$\\sqrt {a+b}$ 7. 多行表达式7.1 分类表达式定义函数的时候经常需要分情况给出表达式，使用\\begin&#123;cases&#125;…\\end&#123;cases&#125; 。其中： 使用\\\\ 来分类 使用&amp; 指示需要对齐的位置， 使用\\ +空格表示空格。 例子 1： 1234567$$f(n)\\begin&#123;cases&#125;\\cfrac n2, &amp;if\\ n\\ is\\ even\\\\3n + 1, &amp;if\\ n\\ is\\ odd\\end&#123;cases&#125;$$ f(n) \\begin{cases} \\cfrac n2, &if\\ n\\ is\\ even\\\\ 3n + 1, &if\\ n\\ is\\ odd \\end{cases}例子 2： 1234567$$L(Y,f(X)) =\\begin&#123;cases&#125;0, &amp; \\text&#123;Y = f(X)&#125; \\\\1, &amp; \\text&#123;Y $\\neq$ f(X)&#125;\\end&#123;cases&#125;$$ L(Y, f(X)) = \\begin{cases} 0, & \\text{Y = f(X)}\\\\ 1, & \\text{Y $\\neq$ f(X)} \\end{cases}7.2 多行表达式有时候需要将一行公式分多行进行显示。 12345678$$\\begin&#123;equation&#125;\\begin&#123;split&#125; a&amp;=b+c-d \\\\ &amp;\\quad +e-f\\\\ &amp;=g+h\\\\ &amp; =i \\end&#123;split&#125;\\end&#123;equation&#125;$$ \\begin{equation} \\begin{split} a&=b+c -d\\\\ &\\quad +e-f\\\\ &=g+h\\\\ &=i \\end{split} \\end{equation} 其中begin{equation} 表示开始方程，end{equation} 表示方程结束；begin{split} 表示开始多行公式，end{split} 表示结束；公式中用\\ 表示回车到下一行，&amp; 表示对齐的位置。 7.3 方程组使用\\begin&#123;array&#125;...\\end&#123;array&#125; 与\\left \\&#123; 与\\right. 配合表示方程组: 123456789$$\\left \\&#123; \\begin&#123;array&#125;&#123;c&#125;a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end&#123;array&#125;\\right.$$ \\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1\\\\ a_2x+b_2y+c_2z=d_2\\\\ a_3x+b_3y+c_3z=d_3\\\\ \\end{array} \\right.8. 特殊函数与符号8.1 三角函数\\sin(x): $\\sin(x)$ \\arctan(x): $arctan(x)$ 8.2 比较运算符小于(\\lt )：$\\lt$ 大于(\\gt )：$\\gt$ 小于等于(\\le )：$\\le$ 大于等于(\\ge )：$\\ge$ 不等于(\\ne ) :$\\ne$ 可以在这些运算符前面加上\\not ，如\\not\\lt :$\\not \\lt$ 8.3 集合运算符并集(\\cup ): $\\cup$交集(\\cap ): $\\cap$差集(\\setminus ): $\\setminus$子集(\\subset ): $\\subset$真子集(\\subseteq ): $\\subseteq$非子集(\\subsetneq ): $\\subsetneq$父集(\\supset ): $\\supset$属于(\\in ): $\\in$不属于(\\notin ): $\\notin$空集(\\emptyset ): $\\emptyset$空(\\varnothing): $\\varnothing$ 8.4 排列\\binom&#123;n+1&#125;&#123;2k&#125;:$\\binom{n+1}{2k}$ &#123;n+1 \\choose 2k&#125;: ${n+1 \\choose 2k}$ 8.5 箭头\\to: $\\to$\\rightarrow: $\\rightarrow$\\leftarrow: $\\leftarrow$\\Rightarrow: $\\Rightarrow$\\Leftarrow: $\\Leftarrow$\\mapsto: $\\mapsto$ 8.6 逻辑运算符\\land:$\\land$\\lor: $\\lor$\\lnot: $\\lnot$\\forall: $\\forall$\\exists: $\\exists$\\top: $\\top$\\bot: $\\bot$\\vdash: $\\vdash$\\vDash: $\\vDash$ 8.7 模运算 \\mod 6: $\\mod 6$ 如a \\equiv b \\mod n : $a \\equiv b \\mod n$ 8.8 点\\ldots: $\\ldots$\\cdots: $\\cdots$\\cdot: $\\cdot$ 其区别是点的位置不同，\\ldots 位置稍低，\\cdots 位置居中。 123456$$\\begin&#123;equation&#125;a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n\\end&#123;equation&#125;$$ 表示： \\begin{equation} a_1+a_2+\\ldots+a_n\\\\ a_1+a_2+\\cdots+a_n\\\\ \\end{equation}9. 顶部符号对于单字符，\\hat x ：$\\hat x$多字符可以使用\\widehat &#123;xy&#125; ：$\\widehat {xy}$类似的还有:\\overline x : $\\overline x$矢量(\\vec x ): $\\vec x$向量(\\overrightarrow &#123;xy&#125; ): $\\overrightarrow {xy}$(\\dot x ): $\\dot x$(\\ddot x ): $\\ddot x$(\\dot &#123;\\dot x&#125; ): $\\dot {\\dot x}$ 10. 表格使用\\begin&#123;array&#125;&#123;列样式&#125;…\\end&#123;array&#125; 这样的形式来创建表格，列样式可以是clr 表示居中，左，右对齐，还可以使用| 表示一条竖线。表格中各行使用\\\\ 分隔，各列使用&amp; 分隔。使用\\hline 在本行前加入一条直线。 例如: 123456789$$\\begin&#123;array&#125;&#123;c|lcr&#125;n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\\\end&#123;array&#125;$$ \\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}11. 矩阵11.1 基本内容使用\\begin&#123;matrix&#125;…\\end&#123;matrix&#125; 这样的形式来表示矩阵，在\\begin 与\\end 之间加入矩阵中的元素即可。矩阵的行之间使用\\\\ 分隔，列之间使用&amp; 分隔，例如: 1234567$$\\begin&#123;matrix&#125;1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end&#123;matrix&#125;$$ \\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}11.2 括号如果要对矩阵加括号，可以像上文中提到的一样，使用\\left 与\\right 配合表示括号符号。也可以使用特殊的matrix 。即替换\\begin&#123;matrix&#125;…\\end&#123;matrix&#125; 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix 。 pmatrix\\begin&#123;pmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;pmatrix&#125; : \\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix} bmatrix\\begin&#123;bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;bmatrix&#125; : \\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix} Bmatrix\\begin&#123;Bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Bmatrix&#125; : \\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix} vmatrix\\begin&#123;vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;vmatrix&#125; : \\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix} Vmatrix\\begin&#123;Vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Vmatrix&#125; : \\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix} 元素省略 可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如： 12345678$$\\begin&#123;pmatrix&#125;1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\\\end&#123;pmatrix&#125;$$ 表示： \\begin{pmatrix} 1&a_1&a_1^2&\\cdots&a_1^n\\\\ 1&a_2&a_2^2&\\cdots&a_2^n\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&a_m&a_m^2&\\cdots&a_m^n\\\\ \\end{pmatrix}增广矩阵 增广矩阵需要使用前面的表格中使用到的\\begin&#123;array&#125; ... \\end&#123;array&#125; 来实现。 1234567$$\\left[ \\begin&#123;array&#125; &#123;c c | c&#125; %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6\\end&#123;array&#125; \\right]$$ 显示为： \\left[ \\begin{array} {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线 1 & 2 & 3 \\\\ 4 & 5 & 6 \\end{array} \\right]12. 公式标记与引用 使用\\tag&#123;yourtag&#125; 来标记公式，如果想在之后引用该公式，则还需要加上\\label&#123;yourlabel&#125; 在\\tag 之后，如a = x^2 - y^3 \\tag&#123;1&#125;\\label&#123;1&#125; 显示为： a = x^2 - y^3 \\tag{12.1} 如果不需要被引用，只使用\\tag&#123;yourtag&#125; ，x+y=z\\tag&#123;1.1&#125;显示为： x+y=z\\tag{12.2} \\tab&#123;yourtab&#125; 中的内容用于显示公式后面的标记。公式之间通过\\label&#123;&#125; 设置的内容来引用。为了引用公式，可以使用\\eqref&#123;yourlabel&#125; ，如a + y^3 \\stackrel&#123;\\eqref&#123;1&#125;&#125;= x^2 显示为： a + y^3 \\stackrel{\\eqref{1}}= x^2或者使用\\ref&#123;yourlabel&#125; 不带括号引用，如a + y^3 \\stackrel&#123;\\ref&#123;111&#125;&#125;= x^2 显示为： a + y^3 \\stackrel{\\ref{111}}= x^213. 字体黑板粗体字此字体经常用来表示代表实数、整数、有理数、复数的大写字母。 \\mathbb ABCDEF： \\Bbb ABCDEF： 黑体字\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ : $\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$\\mathbf abcdefghijklmnopqrstuvwxyz :$\\mathbf abcdefghijklmnopqrstuvwxyz$ 打印机字体\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ : $\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$","categories":[{"name":"语言","slug":"语言","permalink":"https://gitflhub.github.io/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"https://gitflhub.github.io/tags/LaTex/"},{"name":"数学公式","slug":"数学公式","permalink":"https://gitflhub.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"}]},{"title":"Java实现堆排序，快速排序，归并排序","slug":"Java实现堆排序，快速排序，归并排序","date":"2021-05-26T13:01:42.000Z","updated":"2021-07-15T03:58:33.938Z","comments":true,"path":"2021/05/26/Java实现堆排序，快速排序，归并排序/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Java%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"堆排序算法思想堆排序(大根堆，降序排序为例)的算法思想 ①将输入元素构造成堆 ②构造完成后找到最右下元素的父节点开始进行局部调整 ③依次往前，重复②的操作，直到调整到堆的根节点。 ④输出堆顶元素 ⑤重复②③④步骤，直到堆被清空。 代码如下主函数入口1234567891011121314151617package solution;import struct.Heap;public class Method3 &#123; public static void main(String[] args) &#123; // 初始化堆 Heap heap = new Heap(new Integer[]&#123;4,1,2,5,3,8,11,23,15,16,18&#125;); // 调整为大根堆 heap.turnMaxHeap(); // 输出堆顶元素 while (heap.size &gt; 0) &#123; // 循环输出堆顶元素 System.out.println(heap.peakHeapTop()); &#125; return; &#125;&#125;Heap类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package struct;public class Heap &#123; // 假设堆的最大大小为100 public final static int MAX_SIZE = 100; // 存放数据的元素 public Integer[] elems = new Integer[MAX_SIZE]; // 堆的大小 public int size = 0; // 构造堆的函数 public Heap(Integer[] arr) &#123; for (Integer i = 0; i &lt; arr.length; i++) &#123; elems[i] = arr[i]; size++; &#125; &#125; /** * 构造大根堆 */ public void turnMaxHeap() &#123; // 从最右下节点的父节点开始遍历 int index = size / 2 - 1; for (int i = index; i &gt;= 0; i--) &#123; // 局部调整 turnPartialMaxHeap(i); &#125; &#125; /** * 堆进行局部调整 * * @param currentIndex 子树的根节点 */ public void turnPartialMaxHeap(int currentIndex) &#123; // 左孩子索引 Integer leftChildIndex = getLeftChildIndex(currentIndex); // 右孩子索引 Integer rightChildIndex = getRightChildIndex(currentIndex); // 判断 if (leftChildIndex == null &amp;&amp; rightChildIndex == null) &#123; // 说明当前已经找到了叶结点 return; &#125; else if (leftChildIndex != null &amp;&amp; rightChildIndex == null) &#123; // 只有左孩子 if (elems[currentIndex] &lt; elems[leftChildIndex]) &#123; Integer temp = elems[currentIndex]; elems[currentIndex] = elems[leftChildIndex]; elems[leftChildIndex] = temp; &#125; &#125; else if (leftChildIndex != null &amp;&amp; rightChildIndex != null) &#123; // 左孩子右孩子同时存在,取左右节点的最大值与父节点进行比较 if (elems[leftChildIndex] &gt; elems[rightChildIndex]) &#123; // 左孩子为孩子王 if (elems[currentIndex] &lt; elems[leftChildIndex]) &#123; Integer temp = elems[currentIndex]; elems[currentIndex] = elems[leftChildIndex]; elems[leftChildIndex] = temp; &#125; &#125; else &#123; // 有孩子为孩子王或者左右孩子相等 if (elems[currentIndex] &lt; elems[rightChildIndex]) &#123; Integer temp = elems[currentIndex]; elems[currentIndex] = elems[rightChildIndex]; elems[rightChildIndex] = temp; &#125; &#125; // 继续调整左右子树 turnPartialMaxHeap(2 * (currentIndex + 1) - 1); turnPartialMaxHeap(2 * (currentIndex + 1)); &#125; &#125; /** * 摘取堆顶元素 * * @return */ public Integer peakHeapTop() &#123; Integer res = null; // 如果堆为空，则返回null if (size != 0) &#123; // 取出堆顶元素 res = elems[0]; // 补上堆顶元素 elems[0] = elems[size - 1]; // size 自减 size--; // 重新建立大根堆 turnMaxHeap(); &#125; return res; &#125; /** * 获取节点的左孩子 * * @param index * @return */ public Integer getLeftChild(Integer index) &#123; if (getLeftChildIndex(index) != null) &#123; return elems[getLeftChildIndex(index)]; &#125; else &#123; return null; &#125; &#125; /** * 获取左孩子索引 * * @param index * @return */ public Integer getLeftChildIndex(Integer index) &#123; if (index &gt;= 0 &amp;&amp; (index + 1) * 2 &lt;= size) &#123; return (index + 1) * 2 - 1; &#125; else &#123; return null; &#125; &#125; /** * 获取节点的右孩子 * * @param index * @return */ public Integer getRightChild(Integer index) &#123; if (getRightChildIndex(index) != null) &#123; return elems[getRightChildIndex(index)]; &#125; else &#123; return null; &#125; &#125; /** * 获取右孩子索引 * * @param index * @return */ public Integer getRightChildIndex(Integer index) &#123; if (index &gt;= 0 &amp;&amp; (index + 1) * 2 + 1 &lt;= size) &#123; return (index + 1) * 2; &#125; else &#123; return null; &#125; &#125;&#125; 快速排序算法思想①将待排序数组的第一个元素作为标准，将比第一个元素小的放到参照元素的左边，将比第一个元素大的放到参照元素的右边。②放置完成后，把原数组划分为参照元素前后两个子数组③重复①②过程，直到子数组中只有一个元素时停止排序 实现代码主函数123public static void main(String[] args) &#123; int[] res = quickSort(new int[]&#123;6, 9, 7, 2, 0, 9, 6, 5, 3, 1&#125;, 0, 9);&#125;排序函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * 快速排序 * * @param arr 待排序数组 * @param startIndex 起始下标 * @param endIndex 结束下标 * @return 返回开始结束下标之间的一次快排操作结果 */public static int[] quickSort(int[] arr, int startIndex, int endIndex) &#123; // 下标异常返回arr,跳出递归过程 if (startIndex &gt;= endIndex || startIndex &lt; 0 || endIndex &lt; 0) &#123; return arr; &#125; // 参考值 int splitNum = arr[startIndex]; int frontIndex = startIndex; int rearIndex = endIndex; // 起始下标小于结束下标时进行循环 boolean lastMoveIsFront = true; while (rearIndex &gt; frontIndex) &#123; // 从数组尾巴上找到第一个比参考值小的元素 while (rearIndex &gt; frontIndex &amp;&amp; arr[rearIndex] &gt;= splitNum) &#123; rearIndex--; &#125; // 判断循环跳出原因 if (arr[rearIndex] &lt; splitNum) &#123; // 将小数左移 arr[frontIndex++] = arr[rearIndex]; // 标记最后一次移动是头指针 lastMoveIsFront = true; &#125; // 从数组头部找到一个比参考值大的元素 while (rearIndex &gt; frontIndex &amp;&amp; arr[frontIndex] &lt;= splitNum) &#123; frontIndex++; &#125; &#125; // 判断循环跳出原因 if (arr[frontIndex] &gt; splitNum) &#123; // 将大数后移 arr[rearIndex--] = arr[frontIndex]; // 标记最后一次移动是尾指针 lastMoveIsFront = true; &#125; // 将参考值放入合适的位置 此处犯过错误 if (lastMoveIsFront) &#123; arr[frontIndex--] = splitNum; &#125; else &#123; arr[frontIndex++] = splitNum; &#125; // 分治处理当前参考值左右边子数组 quickSort(arr, startIndex, rearIndex - 1); quickSort(arr, rearIndex + 1, endIndex); return arr;&#125; 归并排序算法思想①将待排序数组的以2,4,8,,,2^n的步长划分为若干个子数组②对这些子数组进行排序，这里选择的是快速排序 实现代码1234567891011121314151617181920/** * 归并排序 * * @param arr 输入数组 * @return */ public static int[] mergeSort(int[] arr) &#123; // 起始步长为1 int spet = 1; while (spet &lt; arr.length) &#123; spet *= 2; for (int i = 0; i &lt; arr.length; i += spet) &#123; int start = i; int end = i + spet - 1 &lt; arr.length - 1 ? i + spet - 1 : arr.length - 1; quickSort(arr, start, end); &#125; &#125; return arr; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gitflhub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://gitflhub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"Markdown 制作 Anki 卡片","slug":"Markdown-制作-Anki-卡片","date":"2021-05-15T13:01:42.000Z","updated":"2021-07-15T04:02:49.863Z","comments":true,"path":"2021/05/15/Markdown-制作-Anki-卡片/","link":"","permalink":"https://gitflhub.github.io/2021/05/15/Markdown-%E5%88%B6%E4%BD%9C-Anki-%E5%8D%A1%E7%89%87/","excerpt":"","text":"MarkDown 编辑器 方式一：MarkDown 编辑器资料准备这里以Typora为例：1.打开MarkDown 编辑器2.设置标题层级3.四级标题#### 这层标题为面试的具体问题，如“JRE和JDK的区别？”4.五级标题##### 这层标题为面试问题的具体答案,示例如下：123456789101112131415# JAVA工程师面试## 1.JAVA ### (1)Java基础#### JRE和JDK的区别##### JDK Java Development Kit,Java 开发工具包，提供了开发环境和运行环境##### JRE Java Runtime Environment Java 运行环境，为Java提供了所需的环境##### 运行Java程序，JRE即可##### 编写Java程序，需要安装JDK 格式转换1.转为Anki批量格式CSV网上有一个大佬做了Markdown转Anki卡片的功能，链接如下https://hintsnet.com/tools/md2anki/index.html 2.格式调整由于下载来的文件里面默认HTML标签是&lt; ol &gt;,在文本编辑器中批量替换为&lt; ul &gt; 3.导入Anki方式二：网页数据爬取网页爬取数据爬取工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;/** * 网页抓取工具类 */public class Test1 &#123; /** * 方法入口 * * @param htmltest 要获取的资源URL * @param laber anki标签 */ public static void demo1(String htmltest, String laber) &#123; String html = htmltest; // HTML文档对象 Document doc = Jsoup.parse(html); Elements rows = doc.select(&quot;div[class=interview_detail]&quot;).get(0).select(&quot;ul&quot;).select(&quot;li&quot;); Elements rowTitle = doc.select(&quot;div[class=interview_detail]&quot;); // 生成Anki题目 Element pFirst = rowTitle.select(&quot;p&quot;).first(); // rowTitle.remove(pFirst); StringBuffer stringBuffer = new StringBuffer(); String res = rowTitle.html(); if (rows.size() == 0) &#123; &#125; else &#123; // 获取网页结构指定的div[class=interview_wrap] 的代码信息 String title = doc.select(&quot;div[class=interview_wrap]&quot;).select(&quot;h2&quot;).get(0).text(); // 替换回车 res = res.replaceAll(&quot;(\\\\r\\\\n|\\\\n|\\\\n\\\\r)&quot;, &quot; &quot;) .replaceAll(&quot;\\t&quot;, &quot;&quot;) .replaceAll(&quot;class=\\&quot;language-java\\&quot;&quot;, &quot;&quot;); if (pFirst != null) &#123; // 删除空行 res = res.replaceAll(pFirst.html(), &quot;&quot;).replaceAll(&quot;&lt;p&gt;&lt;/p&gt;&quot;, &quot;&quot;); &#125; // title 是anki卡片正面 stringBuffer.append(title).append(&quot;\\t &quot;); // 标签分类 stringBuffer.append(laber).append(&quot;\\t &quot;); // res 是anki卡片反面 stringBuffer.append(res); System.out.println(stringBuffer.toString()); &#125; &#125;&#125; maven 依赖12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 主方法123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.net.URL;import java.util.stream.Collectors;public class Script &#123; public static void main(String[] args) &#123; // 这个文件里面存放了链接信息 File file = new File(&quot;src/main/resources/url.txt&quot;); try &#123; // 读取配置信息 BufferedReader in = new BufferedReader(new FileReader(file)); String str; String label = &quot;&quot;; while ((str = in.readLine()) != null) &#123; // 获取Anki标签 if (str.contains(&quot;@&quot;)) &#123; label = str.substring(1); &#125; else &#123; // 链接拼接 String urlStr = &quot;https://www.javanav.com/interview/&quot; + str + &quot;.html&quot;; // 网址 URL url = new URL(urlStr); String result = new BufferedReader(new InputStreamReader(url.openStream())) .lines().parallel().collect(Collectors.joining(System.lineSeparator())); // 调用爬取入口 Test1.demo1(result, label); // 读取太快会被反爬虫 Thread.sleep(10 * 3); &#125; &#125; &#125; catch (IOException | InterruptedException e) &#123; &#125; &#125;&#125; 控制台打印结果（部分）12345678==和equals的区别是什么? Java基础 &lt;ul&gt; &lt;li&gt;== 是关系运算符，equals() 是方法，结果都返回布尔值&lt;/li&gt; &lt;li&gt;Object 的 == 和 equals() 比较的都是地址，作用相同&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;== 作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;基本类型，比较值是否相等&lt;/li&gt; &lt;li&gt;引用类型，比较内存地址值是否相等&lt;/li&gt; &lt;li&gt;不能比较没有父子关系的两个对象&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;equals()方法的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JDK 中的类一般已经重写了 equals()，比较的是内容&lt;/li&gt; &lt;li&gt;自定义类如果没有重写 equals()，将调用父类（默认 Object 类）的 equals() 方法，Object 的 equals() 比较使用了 this == obj&lt;/li&gt; &lt;li&gt;可以按照需求逻辑，重写对象的 equals() 方法（重写 equals方法，一般须重写 hashCode方法）&lt;/li&gt; &lt;/ul&gt; 基本类型和包装类对象使用 == 和 equals进行比较的结果？ Java基础 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;1、值不同，使用 ＝＝ 和 equals() 比较都返回 false&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、值相同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;使用 ＝＝ 比较：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;基本类型 － 基本类型、基本类型 － 包装对象返回 true&lt;/li&gt; &lt;li&gt;包装对象 － 包装对象，非同一个对象（对象的内存地址不同）返回 false；对象的内存地址相同返回 true，如下值等于 100 的两个 Integer 对象（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）&lt;/li&gt; &lt;/ul&gt; &lt;pre&gt; &lt;code&gt; Integer i1 = 100; &amp;nbsp;Integer i2 = 100; &amp;nbsp;Integer i3 = 200; &amp;nbsp;Integer i4 = 200; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(i1==i2); //打印true &amp;nbsp;System.out.println(i3==i4); //打印false&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;使用 equals() 比较&lt;/p&gt; &lt;ul&gt; &lt;li&gt;包装对象－基本类型返回 true&lt;/li&gt; &lt;li&gt;包装对象－包装对象返回 true&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;3、不同类型的对象对比，返回 false&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;JDK1.8，实验代码&lt;/p&gt; &lt;pre&gt; &lt;code &gt;byte b1 = 127; Byte b2 = new Byte(&quot;127&quot;); Byte b3 = new Byte(&quot;127&quot;); System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2)); System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1)); System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3)); System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3)); System.out.println(); short s1 = 12; Short s2 = new Short(&quot;12&quot;); Short s3 = new Short(&quot;12&quot;); System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2)); System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1)); System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3)); System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3)); System.out.println(); char c1 = &#x27;A&#x27;; Character c2 = new Character(&#x27;A&#x27;); Character c3 = new Character(&#x27;A&#x27;); System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2)); System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1)); System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3)); System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3)); System.out.println(); int i1 = 10000; Integer i2 = new Integer(10000); Integer i3 = new Integer(10000); System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2)); System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1)); System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3)); System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3)); System.out.println(); long l1 = 1000000000000000L; Long l2 = new Long(&quot;1000000000000000&quot;); Long l3 = new Long(&quot;1000000000000000&quot;); System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2)); System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1)); System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3)); System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3)); System.out.println(); float f1 = 10000.111F; Float f2 = new Float(&quot;10000.111&quot;); Float f3 = new Float(&quot;10000.111&quot;); System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2)); System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1)); System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3)); System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3)); System.out.println(); double d1 = 10000.111; Double d2 = new Double(&quot;10000.111&quot;); Double d3 = new Double(&quot;10000.111&quot;); System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2)); System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1)); System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3)); System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3)); System.out.println(); boolean bl1 = true; Boolean bl2 = new Boolean(&quot;true&quot;); Boolean bl3 = new Boolean(&quot;true&quot;); System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2)); System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1)); System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3)); System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;br&gt; 运行结果&lt;/p&gt; &lt;pre&gt; &lt;code&gt;Byte 基本类型和包装对象使用 == 比较 : true Byte 基本类型和包装对象使用 equals 比较 : true Byte 包装对象和包装对象使用 == 比较 : false Byte 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Short 基本类型和包装对象使用 == 比较 : true Short 基本类型和包装对象使用 equals 比较 : true Short 包装对象和包装对象使用 == 比较 : false Short 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Character 基本类型和包装对象使用 == 比较 : true Character 基本类型和包装对象使用 equals 比较 : true Character 包装对象和包装对象使用 == 比较 : false Character 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Integer 基本类型和包装对象使用 == 比较 : true Integer 基本类型和包装对象使用 equals 比较 : true Integer 包装对象和包装对象使用 == 比较 : false Integer 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Long 基本类型和包装对象使用 == 比较 : true Long 基本类型和包装对象使用 equals 比较 : true Long 包装对象和包装对象使用 == 比较 : false Long 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Float 基本类型和包装对象使用 == 比较 : true Float 基本类型和包装对象使用 equals 比较 : true Float 包装对象和包装对象使用 == 比较 : false Float 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Double 基本类型和包装对象使用 == 比较 : true Double 基本类型和包装对象使用 equals 比较 : true Double 包装对象和包装对象使用 == 比较 : false Double 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Boolean 基本类型和包装对象使用 == 比较 : true Boolean 基本类型和包装对象使用 equals 比较 : true Boolean 包装对象和包装对象使用 == 比较 : false Boolean 包装对象和包装对象使用 equals 比较 : true&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt; &lt;p&gt;ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程&lt;/p&gt;什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？ Java基础 &lt;p&gt;装箱：基本类型转变为包装器类型的过程。&lt;br&gt; 拆箱：包装器类型转变为基本类型的过程。&lt;/p&gt; &lt;pre&gt; &lt;code &gt;//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须 Integer i = new Integer(8); &amp;nbsp; //JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样 Integer i = 8; &amp;nbsp; int n = i;//自动拆箱&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、装箱和拆箱的执行过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;装箱是通过调用包装器类的 valueOf 方法实现的&lt;/li&gt; &lt;li&gt;拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。&lt;/li&gt; &lt;li&gt;如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;3、常见问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。&lt;/li&gt; &lt;li&gt;浮点型的包装类 valueOf 方法返回新的对象。&lt;/li&gt; &lt;li&gt;布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;实验代码&lt;/p&gt; &lt;pre&gt; &lt;code&gt;Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1 == i2);//true System.out.println(i3 == i4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Double d1 = 100.0; Double d2 = 100.0; Double d3 = 200.0; Double d4 = 200.0; System.out.println(d1 == d2);//false System.out.println(d3 == d4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Boolean b1 = false; Boolean b2 = false; Boolean b3 = true; Boolean b4 = true; System.out.println(b1 == b2);//true System.out.println(b3 == b4);//true&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;包含算术运算会触发自动拆箱。&lt;/li&gt; &lt;li&gt;存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &lt;pre&gt; &lt;code &gt;Integer s1 = 0; long t1 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s1 += i; &#125; long t2 = System.currentTimeMillis(); System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; int s2 = 0; long t3 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s2 += i; &#125; long t4 = System.currentTimeMillis(); System.out.println(&quot;使用int，递增相加耗时：&quot; + (t4 - t3));//使用int，递增相加耗时：6&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;hashCode()相同，equals()也一定为true吗？ Java基础 &lt;p&gt;首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。&lt;/li&gt; &lt;li&gt;hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;关于 hashCode() 和 equals() 是方法是有一些 常规协定：&lt;/p&gt; &lt;p&gt;1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。&lt;/p&gt; &lt;p&gt;2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。&lt;/p&gt; &lt;p&gt;3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;就像打人是你的能力，但打伤了就违法了。重写 equals 和 hashCode 方法返回是否为 true 是你的能力，但你不按照上述协议进行控制，在用到对象 hash 和 equals 逻辑判断相等时会出现意外情况，如 HashMap 的 key 是否相等。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;final在java中的作用 Java基础 &lt;ul&gt; &lt;li&gt;被 final 修饰的类，不能够被继承&lt;/li&gt; &lt;li&gt;被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象&lt;/li&gt; &lt;li&gt;被 final 修饰的方法不能重写&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;final finally finalize()区别 Java基础 &lt;ul&gt; &lt;li&gt;final 表示最终的、不可改变的。用于修饰类、方法和变量。final 修饰的类不能被继承；final 方法也同样只能使用，不能重写，但能够重载；final 修饰的成员变量必须在声明时给定初值或者在构造方法内设置初始值，只能读取，不可修改；final 修饰的局部变量必须在声明时给定初值；final 修饰的变量是非基本类型，对象的引用地址不能变，但对象的属性值可以改变&lt;/li&gt; &lt;li&gt;finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）&lt;/li&gt; &lt;li&gt;finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。&lt;/li&gt; &lt;/ul&gt; finally语句块一定执行吗？ Java基础 &lt;ul&gt; &lt;li&gt;直接返回未执行到 try-finally 语句块&lt;/li&gt; &lt;li&gt;抛出异常未执行到 try-finally 语句块&lt;/li&gt; &lt;li&gt;系统退出未执行到 finally 语句块&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;等...&lt;/p&gt; &lt;p&gt;代码如下&lt;/p&gt; &lt;pre&gt; &lt;code &gt;public static String test() &#123; String str = null; int i = 0; if (i == 0) &#123; return str;//直接返回未执行到finally语句块 &#125; try &#123; System.out.println(&quot;try...&quot;); return str; &#125; finally &#123; System.out.println(&quot;finally...&quot;); &#125; &#125; public static String test2() &#123; String str = null; int i = 0; i = i / 0;//抛出异常未执行到finally语句块 try &#123; System.out.println(&quot;try...&quot;); return str; &#125; finally &#123; System.out.println(&quot;finally...&quot;); &#125; &#125; public static String test3() &#123; String str = null; try &#123; System.out.println(&quot;try...&quot;); System.exit(0);//系统退出未执行到finally语句块 return str; &#125; finally &#123; System.out.println(&quot;finally...&quot;); &#125; &#125;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;final与static的区别 Java基础 &lt;ul&gt; &lt;li&gt;都可以修饰类、方法、成员变量。&lt;/li&gt; &lt;li&gt;都不能用于修饰构造方法。&lt;/li&gt; &lt;li&gt;static 可以修饰类的代码块，final 不可以。&lt;/li&gt; &lt;li&gt;static 不可以修饰方法内的局部变量，final 可以。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;static：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;static 修饰表示静态或全局，被修饰的属性和方法属于类，可以用类名.静态属性 / 方法名 访问&lt;/li&gt; &lt;li&gt;static 修饰的代码块表示静态代码块，当 Java 虚拟机（JVM）加载类时，就会执行该代码块,只会被执行一次&lt;/li&gt; &lt;li&gt;static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，只会被创建一次&lt;/li&gt; &lt;li&gt;static 修饰的变量可以重新赋值&lt;/li&gt; &lt;li&gt;static 方法中不能用 this 和 super 关键字&lt;/li&gt; &lt;li&gt;static 方法必须被实现，而不能是抽象的abstract&lt;/li&gt; &lt;li&gt;static 方法不能被重写&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;final：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;final 修饰表示常量、一旦创建不可改变&lt;/li&gt; &lt;li&gt;final 标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可以重新赋值&lt;/li&gt; &lt;li&gt;final 方法不能被子类重写&lt;/li&gt; &lt;li&gt;final 类不能被继承，没有子类，final 类中的方法默认是 final 的&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;final 和 static 修饰成员变量加载过程例子&lt;/p&gt; &lt;pre&gt; &lt;code &gt;import java.util.Random; public class TestStaticFinal &#123; public static void main(String[] args) &#123; StaticFinal sf1 = new StaticFinal(); StaticFinal sf2 = new StaticFinal(); System.out.println(sf1.fValue == sf2.fValue);//打印false System.out.println(sf1.sValue == sf2.sValue);//打印true &#125; &#125; class StaticFinal &#123; final int fValue = new Random().nextInt(); static int sValue = new Random().nextInt(); &#125;&lt;/code&gt;&lt;/pre&gt;","categories":[{"name":"资料整理","slug":"资料整理","permalink":"https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Anki","slug":"Anki","permalink":"https://gitflhub.github.io/tags/Anki/"}]}],"categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"},{"name":"categories","slug":"categories","permalink":"https://gitflhub.github.io/categories/categories/"},{"name":"资料整理","slug":"资料整理","permalink":"https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"name":"English","slug":"English","permalink":"https://gitflhub.github.io/categories/English/"},{"name":"语言","slug":"语言","permalink":"https://gitflhub.github.io/categories/%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"https://gitflhub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://gitflhub.github.io/tags/Machine-Learning/"},{"name":"SMO","slug":"SMO","permalink":"https://gitflhub.github.io/tags/SMO/"},{"name":"SVM","slug":"SVM","permalink":"https://gitflhub.github.io/tags/SVM/"},{"name":"NLP","slug":"NLP","permalink":"https://gitflhub.github.io/tags/NLP/"},{"name":"机器学习","slug":"机器学习","permalink":"https://gitflhub.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"PCA","slug":"PCA","permalink":"https://gitflhub.github.io/tags/PCA/"},{"name":"Anki","slug":"Anki","permalink":"https://gitflhub.github.io/tags/Anki/"},{"name":"浏览器插件","slug":"浏览器插件","permalink":"https://gitflhub.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"},{"name":"开放数据集","slug":"开放数据集","permalink":"https://gitflhub.github.io/tags/%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E9%9B%86/"},{"name":"生词","slug":"生词","permalink":"https://gitflhub.github.io/tags/%E7%94%9F%E8%AF%8D/"},{"name":"Octave","slug":"Octave","permalink":"https://gitflhub.github.io/tags/Octave/"},{"name":"工具","slug":"工具","permalink":"https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"LaTex","slug":"LaTex","permalink":"https://gitflhub.github.io/tags/LaTex/"},{"name":"数学公式","slug":"数学公式","permalink":"https://gitflhub.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"name":"排序","slug":"排序","permalink":"https://gitflhub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]}