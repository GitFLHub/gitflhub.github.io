{"meta":{"title":"RON BLOG","subtitle":"Ron, open the door.","description":"Cumulate","author":"Ron","url":"https://gitflhub.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-05-25T14:17:28.640Z","updated":"2021-05-25T14:17:28.640Z","comments":false,"path":"/404.html","permalink":"https://gitflhub.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2021-05-25T16:57:28.993Z","updated":"2021-05-25T14:17:28.642Z","comments":false,"path":"books/index.html","permalink":"https://gitflhub.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-06-01T17:14:12.415Z","updated":"2021-06-01T17:11:58.206Z","comments":false,"path":"about/index.html","permalink":"https://gitflhub.github.io/about/index.html","excerpt":"","text":"个人简介123一年工作经验喜欢钻研技术不善交际 本心初衷123有一个大厂梦（BAT）也常有听闻中年危机计划走算法职业路线。 个人履历123456789102019-07 月 本科毕业2019-07 至 2020-07 在南京担任Java开发工程师2020-07 至 2020-12 考研初试准备2021-03 至 2021-03 考研复试准备2021-04 至 2021-04 入学前暂时找了份工作 个人规划1234567891011122019-07 月 拿到开发工程师OFFER(已完成)2020-07 至 2021-04 获取研究生入学资格(已完成)2021-05 至 2021-08 入学前自主学习算法(进行中)2021-09 至 2023-08 入学后系统学习(未开始)2023 拿到大厂实习OFFER(未开始)2024 拿到大厂OFFER(未开始) 博客：www.ron.zone Github: github.com/GitFLHub"},{"title":"分类","date":"2021-05-25T16:57:50.708Z","updated":"2021-05-25T14:17:28.642Z","comments":false,"path":"categories/index.html","permalink":"https://gitflhub.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-05-26T16:21:11.315Z","updated":"2021-05-25T14:17:28.643Z","comments":true,"path":"links/index.html","permalink":"https://gitflhub.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-05-26T12:48:24.812Z","updated":"2021-05-25T14:17:28.644Z","comments":false,"path":"tags/index.html","permalink":"https://gitflhub.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-05-25T14:17:28.643Z","updated":"2021-05-25T14:17:28.643Z","comments":false,"path":"repository/index.html","permalink":"https://gitflhub.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Octave 基础","slug":"Octave-基础","date":"2021-05-31T13:01:42.000Z","updated":"2021-05-31T13:03:42.979Z","comments":true,"path":"2021/05/31/Octave-基础/","link":"","permalink":"https://gitflhub.github.io/2021/05/31/Octave-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"工具1. Octave函数常用操作 函数名称 描述 svd (singular value decomposition) 奇异值分解 pinv 求逆矩阵 inv 伪逆矩阵 ‘ 转置 ^ 指数运算 == bool判断 ~= 不等于判断 &amp;&amp; 逻辑与 “双竖杠” 或 xor 逻辑或 PS1(“&gt;&gt; “) 定义默认的提示符 = 赋值 pi 圆周率 disp 打印字符串 sprintf 拼接字符串 format long 默认long型字符串 format short 默认short型字符串 A = [1 2; 3 4; 5 6] 定义矩阵 v = 1:0.1:2 从1到2，生成步长为0.1的数组 ones(2,3) 生成两行三列的1矩阵 zeros(1, 3) 生成一行三列的零矩阵 rand(1,3) 随机生成一行三列的行矩阵 randn(1,3) 生成三个符合方差，标准差为1的正态分布的随机数 hist(数组，默认5柱) 生成样本直方图 hist(数组, 50) 生成50柱直方图 eye(4) 四阶单位矩阵 help eye 查看eye指令的用法 q 退出 size(A) 查看矩阵的大小，1x2的矩阵 size(A，n) 返回矩阵的第n个纬度大小 length(v) 最大维度的大小 文件操作 函数名称 描述 pwd Octave当前路径 cd 改变路径 ls 列出当前路径文件 load feature.dat 或 load（‘feature.dat’） 加载文件 who 查看当前变量 whos 查看当前变量详情，大小，类别 clear featurex 删除 featurex save hello.mat v; 将v写入hello.mat文件中","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Octave","slug":"Octave","permalink":"https://gitflhub.github.io/tags/Octave/"},{"name":"工具","slug":"工具","permalink":"https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Machine Learning","slug":"Machine Learning","date":"2021-05-27T13:56:43.055Z","updated":"2021-06-02T15:36:32.401Z","comments":true,"path":"2021/05/27/Machine Learning/","link":"","permalink":"https://gitflhub.github.io/2021/05/27/Machine%20Learning/","excerpt":"","text":"学习库Numpy 科学计算库 Pandas 数据分析可视化 Matplotlib 数据可视化 Scikit-learn 机器学习库 知识点线性代数矩阵数组 算法监督学习分类：最终属于1还是0 回归：最终一个具体值 例子1：房价预测（回归） 例子2：肿瘤预测（分类）一个属性 两个属性（特征） 无穷多特征：向量机 算法代价函数 一个参数的代价函数可以化为一个一元二次函数 两个参数的代价函数可以化为一个二元二次函数 更多参数可以考虑梯度下降的方式 梯度下降需要考虑步伐大小，大小学习速率过慢，太大会错过最优解，甚至会导致发散 步长α是动态调整的， 梯度下降只适用于求解线性回归。（为弓形图像） 多元梯度下降 特征缩放 也可以采取减去均值再除以范围 特征或多项式回归 正规方程如果X ^ TX是不可逆的，常见的原因可能是: 冗余特征，即两个特征密切相关(即线性相关) 太多的特性(例如m≤n)。在这种情况下，删除一些特性或使用“正则化” 正规方程和梯度下降比较 梯度下降 正规方程需要 需要选择确定学习速率α 不需要选择确定学习速率α 需要多次迭代 不需要迭代 O (kn^2) O (n^3), 需要计算 X^TX的逆矩阵 n 非常大时任然适用 n太大计算缓慢 聚类算法","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://gitflhub.github.io/tags/Machine-Learning/"}]},{"title":"Octave 绘制图像","slug":"Octave 绘制图像","date":"2021-05-27T12:51:01.668Z","updated":"2021-05-27T16:25:04.649Z","comments":true,"path":"2021/05/27/Octave 绘制图像/","link":"","permalink":"https://gitflhub.github.io/2021/05/27/Octave%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/","excerpt":"","text":"Octace 绘制图像二维图像三角函数123456# 生成从0 到 0.98 的数组，步长为0.01t = [0:0.01:0.98]; # 构造y1 和 t的关系式y1 = sin(2*pi*4*t); # 生成二维图像plot(t,y1); 1234# 构造y21 和 t的关系式y2 = cos(2*pi*4*t); # 生成二维图像plot(t,y2); 在原有基础上添加第一个图像 1234# 保留绘制的第一个图hold on# 继续绘制第二个图plot(t,y1,&#x27;r&#x27;) 12345678910# x轴标签xlabel(&#x27;time&#x27;) # y轴标签ylabel(&#x27;value&#x27;) # 线型标注legend(&#x27;sin&#x27;,&#x27;cos&#x27;) # 图表名称title(&#x27;my plot&#x27;) # 输出图片print -dpng &#x27;myplot.png&#x27; 显示多个图像12345678910# 分割出第一个子图 1 * 2 两个子图subplot(1,2,1); # 填充第一个子图plot(t,y1); # 分割出第二个子图subplot(1,2,2);# 填充第二个子图plot(t,y2);# 设置第二个子图的坐标轴范围axis([0.5 1 -1 1]) 矩阵图示12345678910# 随机生成5*5矩阵A = magic(5)# 图示矩阵imagesc(A)A = 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9 12345678A = 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9# 组合命令 colorbar 生成条状尺度图 gray 灰度图imagesc(A), colorbar, colormap gray; 12# 更大的尺度图imagesc(magic(25)), colorbar, colormap gray;","categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"}],"tags":[{"name":"Octave","slug":"Octave","permalink":"https://gitflhub.github.io/tags/Octave/"},{"name":"工具","slug":"工具","permalink":"https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Java实现堆排序，快速排序，归并排序","slug":"Java实现堆排序，快速排序，归并排序","date":"2021-05-26T15:59:14.075Z","updated":"2021-05-26T15:59:48.421Z","comments":true,"path":"2021/05/26/Java实现堆排序，快速排序，归并排序/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Java%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","excerpt":"","text":"堆排序算法思想堆排序(大根堆，降序排序为例)的算法思想 ①将输入元素构造成堆 ②构造完成后找到最右下元素的父节点开始进行局部调整 ③依次往前，重复②的操作，直到调整到堆的根节点。 ④输出堆顶元素 ⑤重复②③④步骤，直到堆被清空。 代码如下主函数入口1234567891011121314151617package solution;import struct.Heap;public class Method3 &#123; public static void main(String[] args) &#123; // 初始化堆 Heap heap = new Heap(new Integer[]&#123;4,1,2,5,3,8,11,23,15,16,18&#125;); // 调整为大根堆 heap.turnMaxHeap(); // 输出堆顶元素 while (heap.size &gt; 0) &#123; // 循环输出堆顶元素 System.out.println(heap.peakHeapTop()); &#125; return; &#125;&#125;Heap类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152package struct;public class Heap &#123; // 假设堆的最大大小为100 public final static int MAX_SIZE = 100; // 存放数据的元素 public Integer[] elems = new Integer[MAX_SIZE]; // 堆的大小 public int size = 0; // 构造堆的函数 public Heap(Integer[] arr) &#123; for (Integer i = 0; i &lt; arr.length; i++) &#123; elems[i] = arr[i]; size++; &#125; &#125; /** * 构造大根堆 */ public void turnMaxHeap() &#123; // 从最右下节点的父节点开始遍历 int index = size / 2 - 1; for (int i = index; i &gt;= 0; i--) &#123; // 局部调整 turnPartialMaxHeap(i); &#125; &#125; /** * 堆进行局部调整 * * @param currentIndex 子树的根节点 */ public void turnPartialMaxHeap(int currentIndex) &#123; // 左孩子索引 Integer leftChildIndex = getLeftChildIndex(currentIndex); // 右孩子索引 Integer rightChildIndex = getRightChildIndex(currentIndex); // 判断 if (leftChildIndex == null &amp;&amp; rightChildIndex == null) &#123; // 说明当前已经找到了叶结点 return; &#125; else if (leftChildIndex != null &amp;&amp; rightChildIndex == null) &#123; // 只有左孩子 if (elems[currentIndex] &lt; elems[leftChildIndex]) &#123; Integer temp = elems[currentIndex]; elems[currentIndex] = elems[leftChildIndex]; elems[leftChildIndex] = temp; &#125; &#125; else if (leftChildIndex != null &amp;&amp; rightChildIndex != null) &#123; // 左孩子右孩子同时存在,取左右节点的最大值与父节点进行比较 if (elems[leftChildIndex] &gt; elems[rightChildIndex]) &#123; // 左孩子为孩子王 if (elems[currentIndex] &lt; elems[leftChildIndex]) &#123; Integer temp = elems[currentIndex]; elems[currentIndex] = elems[leftChildIndex]; elems[leftChildIndex] = temp; &#125; &#125; else &#123; // 有孩子为孩子王或者左右孩子相等 if (elems[currentIndex] &lt; elems[rightChildIndex]) &#123; Integer temp = elems[currentIndex]; elems[currentIndex] = elems[rightChildIndex]; elems[rightChildIndex] = temp; &#125; &#125; // 继续调整左右子树 turnPartialMaxHeap(2 * (currentIndex + 1) - 1); turnPartialMaxHeap(2 * (currentIndex + 1)); &#125; &#125; /** * 摘取堆顶元素 * * @return */ public Integer peakHeapTop() &#123; Integer res = null; // 如果堆为空，则返回null if (size != 0) &#123; // 取出堆顶元素 res = elems[0]; // 补上堆顶元素 elems[0] = elems[size - 1]; // size 自减 size--; // 重新建立大根堆 turnMaxHeap(); &#125; return res; &#125; /** * 获取节点的左孩子 * * @param index * @return */ public Integer getLeftChild(Integer index) &#123; if (getLeftChildIndex(index) != null) &#123; return elems[getLeftChildIndex(index)]; &#125; else &#123; return null; &#125; &#125; /** * 获取左孩子索引 * * @param index * @return */ public Integer getLeftChildIndex(Integer index) &#123; if (index &gt;= 0 &amp;&amp; (index + 1) * 2 &lt;= size) &#123; return (index + 1) * 2 - 1; &#125; else &#123; return null; &#125; &#125; /** * 获取节点的右孩子 * * @param index * @return */ public Integer getRightChild(Integer index) &#123; if (getRightChildIndex(index) != null) &#123; return elems[getRightChildIndex(index)]; &#125; else &#123; return null; &#125; &#125; /** * 获取右孩子索引 * * @param index * @return */ public Integer getRightChildIndex(Integer index) &#123; if (index &gt;= 0 &amp;&amp; (index + 1) * 2 + 1 &lt;= size) &#123; return (index + 1) * 2; &#125; else &#123; return null; &#125; &#125;&#125; 快速排序算法思想①将待排序数组的第一个元素作为标准，将比第一个元素小的放到参照元素的左边，将比第一个元素大的放到参照元素的右边。②放置完成后，把原数组划分为参照元素前后两个子数组③重复①②过程，直到子数组中只有一个元素时停止排序 实现代码主函数123public static void main(String[] args) &#123; int[] res = quickSort(new int[]&#123;6, 9, 7, 2, 0, 9, 6, 5, 3, 1&#125;, 0, 9);&#125;排序函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * 快速排序 * * @param arr 待排序数组 * @param startIndex 起始下标 * @param endIndex 结束下标 * @return 返回开始结束下标之间的一次快排操作结果 */public static int[] quickSort(int[] arr, int startIndex, int endIndex) &#123; // 下标异常返回arr,跳出递归过程 if (startIndex &gt;= endIndex || startIndex &lt; 0 || endIndex &lt; 0) &#123; return arr; &#125; // 参考值 int splitNum = arr[startIndex]; int frontIndex = startIndex; int rearIndex = endIndex; // 起始下标小于结束下标时进行循环 boolean lastMoveIsFront = true; while (rearIndex &gt; frontIndex) &#123; // 从数组尾巴上找到第一个比参考值小的元素 while (rearIndex &gt; frontIndex &amp;&amp; arr[rearIndex] &gt;= splitNum) &#123; rearIndex--; &#125; // 判断循环跳出原因 if (arr[rearIndex] &lt; splitNum) &#123; // 将小数左移 arr[frontIndex++] = arr[rearIndex]; // 标记最后一次移动是头指针 lastMoveIsFront = true; &#125; // 从数组头部找到一个比参考值大的元素 while (rearIndex &gt; frontIndex &amp;&amp; arr[frontIndex] &lt;= splitNum) &#123; frontIndex++; &#125; &#125; // 判断循环跳出原因 if (arr[frontIndex] &gt; splitNum) &#123; // 将大数后移 arr[rearIndex--] = arr[frontIndex]; // 标记最后一次移动是尾指针 lastMoveIsFront = true; &#125; // 将参考值放入合适的位置 此处犯过错误 if (lastMoveIsFront) &#123; arr[frontIndex--] = splitNum; &#125; else &#123; arr[frontIndex++] = splitNum; &#125; // 分治处理当前参考值左右边子数组 quickSort(arr, startIndex, rearIndex - 1); quickSort(arr, rearIndex + 1, endIndex); return arr;&#125; 归并排序算法思想①将待排序数组的以2,4,8,,,2^n的步长划分为若干个子数组②对这些子数组进行排序，这里选择的是快速排序 实现代码1234567891011121314151617181920/** * 归并排序 * * @param arr 输入数组 * @return */ public static int[] mergeSort(int[] arr) &#123; // 起始步长为1 int spet = 1; while (spet &lt; arr.length) &#123; spet *= 2; for (int i = 0; i &lt; arr.length; i += spet) &#123; int start = i; int end = i + spet - 1 &lt; arr.length - 1 ? i + spet - 1 : arr.length - 1; quickSort(arr, start, end); &#125; &#125; return arr; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gitflhub.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://gitflhub.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"JVM 虚拟机基础","slug":"JVM-虚拟机基础","date":"2021-05-26T15:58:38.699Z","updated":"2021-05-26T16:00:50.771Z","comments":true,"path":"2021/05/26/JVM-虚拟机基础/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"JVM中的堆一般分为三部分，新生代、老年代和永久代。 新生代主要是用来存放新生的对象。一般占据堆空间的1/3，由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代分为Eden区、ServivorFrom、ServivorTo三个区。 Eden区：Java新对象的出生地(如果新创建的对象占用内存很大则直接分配给老年代)。当Eden区内存不够的时候就会触发一次MinorGc，对新生代区进行一次垃圾回收。 ServivorTo：保留了一次MinorGc过程中的幸存者。 ServivorFrom:上一次GC的幸存者，作为这一次GC的被扫描者。当JVM无法为新建对象分配内存空间的时候(Eden区满的时候)，JVM触发MinorGc。因此新生代空间占用越低，MinorGc越频繁。MinorGC采用复制算法。 老年代老年代的对象比较稳定，所以MajorGC不会频繁执行。 触发MinorGC的条件：1 在进行MajorGC之前，一般都先进行了一次MinorGC，使得有新生代的对象进入老年代，当老年代空间不足时就会触发MajorGC。2 当无法找到足够大的连续空间分配给新创建的较大对象时，也会触发MajorGC进行垃圾回收腾出空间。 MajorGC采用标记—清除算法(或者标记—整理算法)MajorGC的耗时比较长，因为要先整体扫描再回收，MajorGC会产生内存碎片。为了减少内存损耗，一般需要合并或者标记出来方便下次直接分配。 当老年代也满了装不下的时候，就会抛出OOM。 永久代(元数据区)指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。Class在被加载的时候元数据信息会放入永久区域，但是GC不会在主程序运行的时候清除永久代的信息。所以这也导致永久代的信息会随着类加载的增多而膨胀，最终导致OOM。注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：1.元空间并不在虚拟机中，而是使用本地内存。因此默认情况下元空间的大小仅仅受本地内存的大小限制。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中。 这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。 MajorGC和FullGC的区别(这里参考1建议不要纠结这两个概念的区别，而是应该专注于解决问题) Full GC是清理整个堆空间—包括年轻代和老年代。 Major GC是清理老年代。 MinorGC 触发机制1 Eden区满的时候，JVM会触发MinorGC。 MajorGC 触发机制1 在进行MajorGC之前，一般都先进行了一次MinorGC，使得有新生代的对象进入老年代，当老年代空间不足时就会触发MajorGC。2 当无法找到足够大的连续空间分配给新创建的较大对象时(如大数组)，也会触发MajorGC进行垃圾回收腾出空间。 Full GC触发机制：1 调用System.gc时，系统建议执行Full GC，但是不必然执行2 老年代空间不足3 方法区空间不足4 通过Minor GC后进入老年代的平均大小大于老年代的可用内存5 由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时，4 当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载。 虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁， 当它的年龄增加到一定程度（默认为 15 岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold (阈值)来设置。 参考：1 原文: Minor GC vs Major GC vs Full GC2 Java中的新生代、老年代、永久代和各种GC 作者：Aaron_Swartz链接：https://www.jianshu.com/p/d3a0b4e36c28来源：简书","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://gitflhub.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"Java注解","slug":"Java注解","date":"2021-05-26T15:57:55.196Z","updated":"2021-05-26T16:00:38.320Z","comments":true,"path":"2021/05/26/Java注解/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Java%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"之前一直以为注释=注解，em…..Java5之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解。例如在方法覆盖中使用@Override，注解，注解都是用@符号开头的。有的注解可以在运行时读写字节码文件信息 1.基本注解无论哪一种注解，本质上都是一种数据类型，是一种接口类型。到Java8为止，Java提供了11种内置注解。其中有5种是基本注解，他们来自于java.lang包；有六种是元注解（meta annotation），他们来自于java.lang.annotation包，自定义注解会用到元注解。基本注解类型包括@Override,@Deprecated,@SuppressWarnings,@SafeVarargs,@FunctionalInterface。下面逐一介绍 1.1 @Override:@Override只能用于方法，子类覆盖父类方法（或者实现接口方法）时可以@Override注解。编译器会检查被@Override的方法，确保该父类中存在的方法，否则会有编译错误。 1.2 @Deprecated@Deprecated用来指示API已经过时了。@Deprecated可以用来注释类，接口，成员方法和变量。调用@Deprecated方法的代码会出现删除线 1.3@SuppressWarnnings@SuppressWarnnings注释用来抑制编译器警告，如果确认程序中的警告没有问题，可以不用理会。若是不想看到相关警告，可以使用@SuppressWarnning方法来消除警告。 1.4@SafeVarargs@SafeVarargs可以抑制将非范型变量值赋值给范型变量值 1.5@FunctionalInterface@FunctionalInterface用于接口注释 2.元注解元注解包括@Documented，@Tagget，@Retention，@Inherited，@Repeatable，@Native。元注解是为其他注解进行说明的注释。当自定义一个新的注解类型时，其中可以使用元注解。 1.@Documented如果在一个自定义注解中引用@Documented注解，那么该注解可以修饰代码元素(类、接口、成员变量和成员方法)，javadoc等工具可以提取这些元素 2.@Target@Target注解用来指定一个新注解的适用目标。@Target注解中有一个成员（value）用来设置目标，value是java.lang.annotation.ElementType枚举类型的数组，ElementType描述Java程序元素类型，他有10个枚举常量。枚举常量 说明ANNOTATION_TYPE 其他注释类型声明CONSTRUCTOR 构造方法声明FIELD 成员变量或常量声明LOCAL_VARIABLE 局部变量声明METHOD 方法声明PACKAGE 包声明PARAMETER 参数声明TYPE 类、接口声明TYPE_PARAMETER 用于泛型中类型参数的声明TYPE_USE 用于任何类型的声明，Java8推出 3,@Retention@Rentention注释用来指定一个新注解的有效范围，@Retention注解一个成员（value）用来设置保留策略，value是java.lang.annotation.RetentionPolicy枚举类型，RetentionPolicy描述注释保留类型策略，他有三个枚举常量枚举常量 说明SOURCE 只适用于Java源代码文件中，此范围最小CLASS 编译器把注释信息记录在字节码文件中，此范围居中RUNTIME 编译器把注释信息记录在字节码文件中，并在运行时可以读取这些信息，此范围最大 4.@Inherited@Inherited注释用来指定一个新注解可以被继承。假定一个类A被该注释修饰，那么这个A类的子类会继承该新注解 5.@Repeatable@Repeatable注解允许在相同的程序元素中重复注解。可重复的注解必须使用@Repeatable进行注解。 6.@Native@Native 注释一个成员变量，指示这个变量可以被本地代码引用。常常被代码生成工具使用 3.自定义注解1.声明注解声明自定义注解可以使用@Interface关键字实现，最简单的形式的注释实例代码如下：//Marker.java文件package.com.a51work6;public @Interface Marker{}一个源文件中可以声明多个注解，但是只有一个是公有访问权限的，源文件命名与公有访问权限的注解名一致。Marker注解中不包含任何成员，这种注解称为标记注解，基本注解中的@Override就属于标记注解。根据需要，注解中可以包含一些成员，实例代码//Marker.java文件package.com.a51work6; //单值注解@Interface MyAnnotation{ String value();}代码中声明MyAnnotation注解，他有一个成员value，注意value后面有对小括号。value前面的是数据类型。成员也可以有访问权限修饰符，但是只能是公有权限和默认权限。注释中的成员也可以有默认值，示例代码如下：//Marker.java文件package.com.a51work6;//单值注解@Interface MyAnnotation1{ String value() default “注解信息”; int count() default 0;} 2.案例：使用元注解前面啰嗦了一大堆，直接写个例子吧，不然要睡着了。例子：import javax.xml.bind.Element;import java.lang.annotation.*;//指定MyAnnotation注解信息可以被javadoc工具读取@Documented//指定注解用于修饰类和接口等类型@Target({ ElementType.TYPE })//指定注释信息可以在运行时被读取@Retention( RetentionPolicy.RUNTIME )public @interface MyAnnotation { //注解的成员 String description();}还是不知道这个用来干嘛。再来一个例子试试//MemberAnnotation.javaimport java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; @Documented@Retention(RetentionPolicy.RUNTIME)//指定MemberAnnotation注解用于修饰类中的成员@Target({ ElementType.FIELD, ElementType.METHOD })public @interface MemberAnnotation { //type类型是Class，默认值是void.class //&lt;?&gt;表示不限定类型，用？作为占位符 Class&lt;?&gt; type() default void.class; //description类型是String，没有默认值 String description();}import javax.xml.bind.Element;import java.lang.annotation.*;//指定MyAnnotation注解信息可以被javadoc工具读取@Documented//指定注解用于修饰类和接口等类型@Target({ ElementType.TYPE})//指定注释信息可以在运行时被读取@Retention( RetentionPolicy.RUNTIME )public @interface MyAnnotation { //注解的成员 String description();}@MyAnnotation(description = “这是一个测试类”)public class Person { //修饰成员变量 @MemberAnnotation(type = String.class, description = “名字”) private String name; @MemberAnnotation(type = int.class, description = &quot;年龄&quot;) private int age; @MemberAnnotation(type = String.class, description = &quot;获得名字&quot;) public String getName() &#123; return name; &#125; //修饰成员方法 @MemberAnnotation(type = int.class, description = &quot;获得年龄&quot;) public int getAge() &#123; return age; &#125; @MemberAnnotation(description = &quot;设置姓名和年龄&quot;) public void setNameAndAge(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; }还是不知道要干嘛。。。。 3.案例读取运行时注解信息注解是为工具读取信息而准备的。有些工具可以读取源代码文件中的注解信息；有的可以读取字节码文件中的注解信息；有的可以在运行时读取注解信息。但是读取这些注解信息都是一样的，区别只在于自定义注解中@Retention的保留策略不同。读取注解信息要反射相关API，Class类有如下方法。 A getAnnotation(Class annotation Class):如果此元素存在annotationClass类型的注解，则返回注解，否则返回null。Annotation[] getAnnotations():返回此元素上存在的所有注解。Annotation[] getDeclaredAnnotations():返回直接存在于此元素上的所有注解。与getAnnotations()区别在于，该方法将不返回继承的注释。boolbean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass):如果此元素存在annotationClass的注解，则返回true，否则返回false。boolbean isAnnotation():如果此Class对象表示一个注解类型，则返回true。运行时Person类中注解信息代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.lang.reflect.Field;import java.lang.reflect.Method;public class mainFun &#123; public static void main(String[] args) &#123; try &#123; //创建Person类对应的对象 Class&lt;?&gt; clz = Class.forName(&quot;Person&quot;); //读取类注解 //判断Person类是否存在MyAnnotation注解 if (clz.isAnnotationPresent(MyAnnotation.class)) &#123; //返回注解实例 MyAnnotation myAnnotation = (MyAnnotation) clz.getAnnotation(MyAnnotation.class); //读取注解中的表达式 System.out.printf(&quot;类%s,读取注释描述：%s\\n&quot;, clz.getName(), myAnnotation.description()); &#125; //读取成员方法的注解详情 Method[] methods = clz.getDeclaredMethods(); for (Method method : methods) &#123; //判断方法是否存在MemberAnnotation注解 if (method.isAnnotationPresent(MemberAnnotation.class)) &#123; //返回MemberAnnotation注解实例 MemberAnnotation memberAnnotation = method.getAnnotation(MemberAnnotation.class); //读取MemberAnnotation实例的注解表达式 System.out.printf(&quot;方法%s，读取注解描述： %s\\n&quot;, method.getName(), memberAnnotation.description()); &#125; &#125; //读取成员变量的注解信息 Field[] fields = clz.getDeclaredFields(); for (Field field : fields) &#123; //判断变量是否存在MemberAnnotation注解 if (field.isAnnotationPresent(MemberAnnotation.class)) &#123; //返回MemberAnnotation注解实例 MemberAnnotation memberAnnotation = field.getAnnotation(MemberAnnotation.class); //读取MemberAnnotation实例的注解表达式 System.out.printf(&quot;成员变量%s,读取注解描述:%s\\n&quot;, field.getName(), memberAnnotation.description()); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行结果： 123456789&quot;C:\\Program Files\\Java\\jdk1.8.0_181\\bin\\java.exe&quot; &quot;-javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.1.3\\lib\\idea_rt.jar=55483:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.1.3\\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\deploy.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\access-bridge-64.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\cldrdata.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\dnsns.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\jaccess.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\jfxrt.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\localedata.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\nashorn.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\sunec.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\sunjce_provider.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\sunmscapi.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\sunpkcs11.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\ext\\zipfs.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\javaws.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\jfr.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\jfxswt.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\management-agent.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\plugin.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.8.0_181\\jre\\lib\\rt.jar;E:\\编程\\eclipseJavaCode\\IXml\\out\\production\\IXml;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jaxws-api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jaxws-rt.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jaxws-tools.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\activation.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\FastInfoset.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\gmbal-api-only.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\http.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jaxb-api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jaxb-impl.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jsr173_api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jsr181-api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jsr250-api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\management-api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\mimepull.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\policy.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\resolver.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\saaj-api.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\saaj-impl.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\stax-ex.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\streambuffer.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\woodstox.jar;E:\\编程\\eclipseJavaCode\\IXml\\lib\\jaxb-xjc.jar&quot; mainFun类Person,读取注释描述：这是一个测试类方法getName，读取注解描述： 获得名字方法getAge，读取注解描述： 获得年龄方法setNameAndAge，读取注解描述： 设置姓名和年龄成员变量name,读取注解描述:名字成员变量age,读取注解描述:年龄Process finished with exit code 0 终于知道要干嘛了。。。","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"Java 注解","slug":"Java-注解","permalink":"https://gitflhub.github.io/tags/Java-%E6%B3%A8%E8%A7%A3/"}]},{"title":"Bean的操作","slug":"Bean的操作","date":"2021-05-26T15:56:49.952Z","updated":"2021-05-26T15:59:34.765Z","comments":true,"path":"2021/05/26/Bean的操作/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Bean%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"2.1 声明Bean2.1.1创建Spring配置Spring提供两种装配Bean的方式。传统上Spring使用多个XML文件作为配置文件。也可以采用基于Java注解的配置方式。在XML文件中声明Bean时，Spring配置文件的根元素是来源于Spring beans命名空间所定义的元素。Spring XML配置文件例子如下： 1234&lt;? xml version=&quot; 1. 0&quot; encoding=&quot; UTF- 8&quot;?&gt; &lt; beans xmlns=&quot; http:// www. springframework. org/ schema/ beans&quot; xmlns: xsi=&quot; http:// www. w3. org/ 2001/ XMLSchema- instance&quot; xsi: schemaLocation=&quot; http:// www. springframework. org/ schema/ beans http:// www. springframework. org/ schema/ beans/ spring- beans- 3. 0. xsd&quot;&gt; &lt;!-- Bean declarations go here --&gt; &lt;/ beans&gt; 在beans元素内，可以放置所有的Spring配置信息。Spring的核心框架自带了10个命名空间。 2.1.2声明一个简单的Bean1234567package com. springinaction. springidol;public class Juggler implements Performer &#123; private int beanBags = 3; public Juggler() &#123; &#125; public Juggler( int beanBags) &#123; this. beanBags = beanBags; &#125;public void perform() throws PerformanceException &#123; System. out. println(&quot; JUGGLING &quot; + beanBags + &quot; BEANBAGS&quot;); &#125; &#125; 1&lt;bean id=”duke” class=”com.springinaction.springidol.Juggler”&gt;&lt;/bean&gt; 通过的配置方式。创建了一个由Spring容器管理的名字为duke的Juggler的Bean，其中id属性定义了Bean的名字，也作为该Bean在Spring容器中的引用。在Spring容器加载Bean时，Spring将使用默认的构造器来实例化duke 1234new com.springinacation.springidol.Juggler();ApplicationContext ctx = new ClassPathXmlApplicationContext( &quot;com/ springinaction/ springidol/ spring- idol. xml&quot;); Performer performer = (Performer) ctx. getBean(&quot; duke&quot;); performer. perform(); 2.1.3通过构造器注入1，Juggler类能够以两种不同的方式构造：■使用默认的构造器；■使用带有一个int参数的构造方法，该参数设置了Juggler可以同时抛在空中的豆袋子的个数。带参数的配置方法 123&lt;bean id=”duke” class=”com.springinaction.springidol.Juggler”&gt; &lt;constructor-arg value=”15” /&gt;&lt;/bean&gt; 的value属性设置为15通过构造器注入对象 123456789101112131415161718package com. springinaction. springidol;public class PoeticJuggler extends Juggler &#123; private Poem poem; public PoeticJuggler(Poem poem) &#123; super(); this.poem = poem; &#125; public PoeticJuggler(int beanBags, Poem poem) &#123; super(beanBags); this.poem = poem; &#125; public void perform() throws PerformanceException &#123; super.perform(); System. out. println(&quot; JUGGLING &quot; + beanBags + &quot; BEANBAGS&quot;); poem.recite(); &#125; &#125; poem接口： 123456789101112131415161718192021222324252627282930package com. springinaction. springidol;public interface Poem &#123; void recite(); &#125;package com. springinaction. springidol; public class Sonnet29 implements Poem &#123; private static String[] LINES = &#123; &quot;When, in disgrace with fortune and men&#x27; s eyes,&quot;, &quot;I all alone beweep my outcast state&quot;, &quot;And trouble deaf heaven with my bootless cries&quot;, &quot;And look upon myself and curse my fate,&quot;, &quot;Wishing me like to one more rich in hope,&quot;, &quot;Featured like him, like him with friends possess&#x27; d,&quot;, &quot;Desiring this man&#x27; s art and that man&#x27; s scope,&quot;, &quot;With what I most enjoy contented least;&quot;, &quot;Yet in these thoughts myself almost despising,&quot;, &quot;Haply I think on thee, and then my state,&quot;, &quot;Like to the lark at break of day arising&quot;, &quot;From sullen earth, sings hymns at heaven&#x27; s gate;&quot;, &quot;For thy sweet love remember&#x27; d such wealth brings&quot;, &quot;That then I scorn to change my state with kings.&quot; &#125;; public Sonnet29() &#123; &#125; public void recite() &#123; for (int i = 0; i &lt; LINES. length; i++) &#123; System. out. println(LINES[i]); &#125; &#125;&#125; 可以XML将Sonn t29声明为一个Spring: 1&lt;bean id=”sonnett29” class=”com.springinaction.springidol.Sonnect29” /&gt; 有了poem，现将poem赋于Duke。声明如下： 1234&lt;bean id=&quot;poeticDuke&quot; class=&quot;com.springinaction.springidol.PoeticJuggler&quot;&gt; &lt;constructor-arg value=&quot;15&quot;/&gt; &lt;constructor-arg ref=&quot;sonnet29&quot;/&gt;&lt;/bean&gt; 通过工厂方法创建Bean有时候静态工厂方法是实例化对象的唯一方法。Spring支持通过元素的factory-method属性来装配工厂创建的Bean。为单例类配置Bean 1&lt;bean id=”theStage” class=” com.springinaction.springidol.PoeticJuggler” factory-method=”getInstance” /&gt; 这种配置方式可以用来创建静态方法 2.1.4 Bean的作用域当在Spring中配置元素时，我们可以为Bean声明一个作用域。为了让Spring在每次请求时都为Bean产生一个新的实例，则需要配置scope属性为prototype即可。例如，把演出门票声明为Spring Bean: 1&lt;bean id=”ticket” class=” com.springinaction.springidol.PoeticJuggler” scope=”prototype” /&gt; 除了prototype，Spring还提供了其他几个作用域的选项。 2.1.5初始化和销毁BeanSpring提供了Bean生命周期的钩子方法。为了Bean定义初始化和销毁操作，只需要使用init-method和destroy-method参数来配置元素。为bean定义初始化和销毁操作，只需要使用init-method和destory-method参数来配置元素。如舞台类活动Auditorium 12345678public class Auditorium &#123; public void turnOnLights() &#123; . &#125; public void turnOffLights() &#123; . &#125;&#125; 为了实例化对象的初始化和注销需求，我们可以使用initmethod和destorymethod属性来声明auditoriumBean： 1&lt;bean id=&quot;auditorium&quot; class=&quot;com.springinaction.springidol.Auditorium&quot; init-method=&quot;turnOnLights&quot; destroy-method=&quot;turnOffLights&quot;/&gt; 这样的配置方式会让auditoriumBean实例化后会立即调用turnOn-Lights()方法。在该Bean从容器移除和销毁前，会调用turnOffLights()InitializingBean和DisposableBean为Bean定义初始化和销毁方法的另一种可选方式是，让Bean实现Spring的InitializingBean和DisposableBean接口。Spring容器以特殊的方式对待实现这两个接口的Bean，允许它们进入Bean的生命周期。InitializingBean声明了一个afterPropertiesSet()方法作为初始化方法。而DisposableBean声明了一个destroy()方法，该方法在Bean从应用上下文移除时会被调用。使用这些生命周期接口的最大好处就是Spring能够自动检测实现了这些接口的Bean，而无需额外的配置。实现这些接口的缺点是Bean与Spring的API产生了耦合。就因为这条理由，所以我还是推荐使用init-method和destory-method属性来初始化和销毁Bean。唯一可能使用Spring的生命周期接口的场景是，开发一个明确在Spring容器内使用的框架Bean。可以使用元素的default-init-method和default-destory-method属性： 123456&lt;? xml version=&quot; 1. 0&quot; encoding=&quot; UTF- 8&quot;?&gt; &lt; beans xmlns=&quot; http:// www. springframework. org/ schema/ beans&quot; xmlns: xsi=&quot; http:// www. w3. org/ 2001/ XMLSchema- instance&quot; xsi: schemaLocation=&quot; http:// www. springframework. org/ schema/ beans http:// www. springframework. org/ schema/ beans/ spring- beans- 3. 0. xsd&quot; default- init- method=&quot; turnOnLights&quot; default- destroy- method=&quot; turnOffLights&quot;&gt; ... &lt;/ beans&gt; default-init-method属性为应用上下文中所有的Bean设置了共同的初始化方法。类似的是，default-destory-method为应用上下文中所有的Bean设置了一个共同的销毁方法。 2.2注入Bean属性2.2.1注入Bean属性使用元素配置Bean的属性。在许多方面与类似。 通过构造参数来注入值 通过setter方式来注入值例子： 123&lt;beanid=&quot;kenny&quot;class=&quot;com.springinaction.springidol.Instrumentalist&quot;&gt;&lt;propertyname=&quot;song&quot;value=&quot;JingleBells&quot;/&gt;&lt;/bean&gt; 一旦Instrumentalist被实例化，Spring就会调用元素所指定属性的setter方法为该属性注入值。在这段XML代码中，元素会指示Spring调用setSong()方法将song属性的值设置为“JingleBells”。但是元素并没有限制只能注入String类型的值，value属性同样可以指定数值型（int、float、java.lang.Double等）以及boolen型的值。例子： 1234&lt;bean id=&quot; kenny&quot; class=&quot; com. springinaction. springidol. Instrumentalist&quot;&gt;&lt;property name=&quot; song&quot; value=&quot; Jingle Bells&quot; /&gt; &lt;property name=&quot; age&quot; value=&quot; 37&quot; /&gt; &lt;/bean&gt; 2.2.2引用其他Bean程序清单2.6 saxophone实现了Instrument接口： 1234567package com.springinaction.springidol;public class Saxophone implements Instrument &#123; public Saxophone() &#123;&#125; public void play() &#123; System.out.println(&quot;TOOT TOOT TOOT&quot;); &#125;&#125; 配置文件 12345&lt;bean id=&quot; saxophone&quot; class=&quot; com. springinaction. springidol. Saxophone&quot; /&gt;&lt;bean id=&quot; kenny2&quot; class=&quot; com. springinaction. springidol. Instrumentalist&quot;&gt;&lt;property name=&quot; song&quot; value=&quot; Jingle Bells&quot; /&gt; &lt;property name=&quot; instrument&quot; ref=&quot; saxophone&quot; /&gt; &lt;/bean&gt; 调用方法: 123ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;com/springinaction/ springidol/spring- idol. xml&quot;); Performer performer = (Performer) ctx. getBean(&quot; kenny&quot;);performer. perform(); 注入内部 Bean重新配置了kenny Bean 123456&lt;bean id=&quot; kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot;&gt;&lt;property name=&quot; song&quot; value=&quot; Jingle Bells&quot; /&gt; &lt;property name=&quot; instrument&quot;&gt; &lt;bean class=&quot; org. springinaction. springidol. Saxophone&quot; /&gt; &lt;/property&gt; &lt;/bean&gt; 内部Bean是通过直接声明一个元素作为元素的子节点而定义的。内部Bean并不限于setter注入，还可以把内部Bean装配到构造方法的入参中例子： 123456&lt;bean id=&quot; duke&quot; class=&quot; com. springinaction. springidol. PoeticJuggler&quot;&gt; &lt;constructor- arg value=&quot; 15&quot; /&gt; &lt;constructor- arg&gt; &lt;bean class=&quot; com. springinaction. springidol. Sonnet29&quot; /&gt; &lt;/constructor- arg&gt; &lt;/bean&gt; 注意内部Bean没有ID属性，说明内部Bean不能被复用。内部Bean仅仅适用于一次注入。而且也不能被其他Bean所引用。 2.2.3使用Spring的命名空间p装配属性1&lt;bean id=&quot; kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot; p: song = &quot;Jingle Bells&quot; p: instrument-ref = &quot;saxophone&quot; /&gt; p:song属性的值被设置为“JingleBells”，将使用该值装配song属性。同样，p:instrument-ref属性的值被设置为“saxophone”，将使用一个ID为saxophone的Bean引用来装配instrument属性。-ref后缀作为一个标识来告知Spring应该装配一个引用而不是字面值。 2.2.4装配集合当配置集合类型的Bean属性时，Spring提供了4种类型的集合配置元素。 当装配类型为数组或者java.util.Collection任意实现的属性时，和元素非常有用。我们很快就会看到，其实属性实际定义的集合类型与选择或者元素没有任何关系。如果属性为任意的java.util.Collec-tion类型时，这两个配置元素在使用时几乎可以完全互换。 和这两个元素分别对应java.util.Map和java.util.Properties。当我们需要由键-值对组成的集合时，这两种配置元素非常有用。这两种配置元素的关键区别在于，要求键和值都必须为String类型，而允许键和值可以是任意类型。1234567891011121314151617public class OneManBand implements PerformanceException &#123; public OneManBand() &#123;```javapublic void perform() &#123; for(Instrument instrument : implements) &#123; instrument.play(); &#125;&#125;private Collection&lt;Instrument&gt; implements;private void setInstruments(Collection&lt;Instrument&gt; implements) &#123; this.implements = implement;&#125;&#125; 装配List、Set和Array让我们使用配置元素，为Hank赋予表演时所用到的乐器集合： 123456789&lt;bean id=&quot; hank&quot; class=&quot; com. springinaction. springidol. OneManBand&quot;&gt; &lt;property name=&quot; instruments&quot;&gt; &lt;list&gt; &lt;ref bean=&quot; guitar&quot; /&gt; &lt;ref bean=&quot; cymbal&quot; /&gt; &lt;ref bean=&quot; harmonica&quot; /&gt;&lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; .元素包含一个或多个值。这里的元素用来定义Spring上下文中的其他Bean引用，当然还可以使用其他的Spring设值元素作为的成员，包括、和。实际上，可以包含另外一个作为其成员，形成多维列表。中，OneManBand的instruments属性为java.util.Collection类型，使用了Java5范型来限制集合中的元素必须为Instrument类型。如果Bean的属性类型为数组类型或java.util.Collection接口的任意实现，都可以使用元素。换句话说，即使像下面那样配置instruments属性，元素也一样有效：使用Set装配 12345678910&lt;bean id=&quot; hank&quot; class=&quot; com. springinaction. springidol. OneManBand&quot;&gt; &lt;property name=&quot; instruments&quot;&gt; &lt;set&gt; &lt;ref bean=&quot; guitar&quot; /&gt; &lt;ref bean=&quot; cymbal&quot; /&gt; &lt;ref bean=&quot; harmonica&quot; /&gt; &lt;ref bean=&quot; harmonica&quot; /&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 无论还是都可以用来装配类型为java.util.Collection的任意实现或者数组的属性。不能因为属性为java.util.Set类型，就表示用户必须使用元素来完成装配。 装配Map集合 1234567891011121314151617181920public class OneManBand implements PerformanceException &#123; public Map&lt;String, Instrument&gt; instruments; public OneManBand() &#123; &#125; @Override public void perform() throws PerformanceException &#123; for (String key : instruments.keySet()) &#123; System.out.println(key + &quot;:&quot;); Instrument instrument = instruments.get(key); instrument.play(); &#125; &#125; public void setInstruments(Map&lt;String, Instrument&gt; instruments) &#123; this.instruments = instruments;&#125;&#125; 配置文件 12345678&lt;bean id=&quot;hank&quot; class=&quot;com.springidol.OneManBand&quot;&gt;&lt;property name=&quot;instruments&quot;&gt; &lt;map&gt; &lt;entry key=&quot;saxophone&quot; value-ref=&quot;saxophone&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;piano&quot; value-ref=&quot;piano&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 装配Properties集合当将OneManBand的instrument属性声明为Map类型时，需要使用value-ref指定每一个entry的值。这是因为每一个entry最终都会成为Spring上下文中的一个Bean。但是如果所配置Map的每一个entry的键和值都为String类型时，我们可以考虑使用java.util.Properties代替Map。Properties类提供了和Map大致相同的功能，但是它限定键和值必须为String类型。为了演示，OneManBand使用String-to-String的java.util.Propeties集合来装配，代替之前键为String类型而值为Bean引用的Map。修改后的instruments属性如下所示： 123456789101112@Override public void perform() throws PerformanceException &#123; Collection&lt;String&gt; instrumentsObject = instruments.stringPropertyNames(); for(String key : instrumentsObject) &#123; String instrumentValue = instruments.getProperty(key); System.out.println(key + &quot;:&quot; + instrumentValue); &#125; &#125; public void setInstruments(Properties instruments) &#123; this.instruments = instruments;&#125; 配置如下： 123456&lt;property name=&quot;instruments&quot;&gt; &lt;props&gt; &lt;prop key=&quot;saxophone&quot;&gt;saxophonesaxophonesaxophone&lt;/prop&gt; &lt;prop key=&quot;piano&quot;&gt;pianopianopiano&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; 元素构建了一个java.util.Properties值，这个Properties的每一个成员都由元素定义。每一个元素都有一个key属性，其定义了Properties每个成员的键，而每一个成员的值由元素的内容所定义。在我们的示例中，键为“GUITAR”的元素，它的值为“STRUMSTRUMSTRUM”。这可能是我们所讨论的最复杂的Spring配置元素了。这是因为术语属性（property）包含了太多的含义。请牢记下面的配置要点：■元素用于把值或Bean引用注入到Bean的属性中；■元素用于定义一个java.util.Properties类型的集合值；■元素用于定义集合的一个成员。 2.2.5装配空值除了为Bean的属性或构造器参数装配其他任意类型的值外，Spring还可以装配一个空值。或者更准确地讲，Spring可以装配null值。为属性设置null值，只需使用元素。例如： 1&lt;property name=&quot;someNonNullProperty&quot;&gt;&lt;null/&gt;&lt;/property&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"Bean","slug":"Bean","permalink":"https://gitflhub.github.io/tags/Bean/"}]},{"title":"Java Bean","slug":"Java-Bean","date":"2021-05-26T15:52:32.924Z","updated":"2021-05-26T15:59:40.210Z","comments":true,"path":"2021/05/26/Java-Bean/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Java-Bean/","excerpt":"","text":"3.1自动装配Bean属性当Spring装配Bean属性时，有时候非常明确，就是需要将某个Bean的引用装配给指定属性。如果我们的应用上下文中只有一个javax.sql.DataSource类型的Bean，那么任意一个依赖DataSource的其他Bean就是需要这个DataSourceBean。毕竟这里只有一个DataSourceBean。为了应对这种明确的装配场景，Spring提供了自动装配（autowiring）。与其显式地装配Bean的属性，为何不让Spring识别出可以自动装配的场景——不需要不需要考虑究竟要装配哪一个Bean引用。 3.1.1 4种类型的自动装配■ byName——把与Bean的属性具有相同名字（或者ID）的其他Bean自动装配到Bean的对应属性中。如果没有跟属性的名字相匹配的Bean，则该属性不进行装配。■ byType——把与Bean的属性具有相同类型的其他Bean自动装配到Bean的对应属性中。如果没有跟属性的类型相匹配的Bean，则该属性不被装配。■ constructor——把与Bean的构造器入参具有相同类型的其他Bean自动装配到Bean构造器的对应入参中。■ autodetect——首先尝试使用constructor进行自动装配。如果失败，再尝试使用byType进行自动装配。byName自动装配如将以下配置信息： 1234&lt;bean id=&quot;kenny2&quot; class=&quot;com.springidol.Instrumentalist&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot;&gt;&lt;/property&gt; &lt;property name=&quot;instrument&quot; ref=&quot;piano&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 替换成 12345&lt;bean id=&quot;kenny2&quot; class=&quot;com.springidol.Instrumentalist&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;instrument&quot; class=&quot;com.springidol.Saxophone&quot;&gt;&lt;/bean&gt; byName自动装配遵循一项约定：为属性自动装配ID与该属性的名字相同的Bean。byType自动装配byType自动装配的工作方式类似于byName自动装配，只不过不再是匹配属性的名字而是检查属性的类型。当我们尝试使用byType自动装配时，Spring会寻找哪一个Bean的类型与属性的类型相匹配。了避免因为使用byType自动装配而带来的歧义，Spring为我们提供了另外两种选择：可以为自动装配标识一个首选Bean，或者可以取消某个Bean自动装配的候选资格。为自动装配标识一个首选Bean，可以使用元素的primary属性。如果只有一个自动装配的候选Bean的primary属性设置为true，那么该Bean将比其他候选Bean优先被选择。但是primary属性有个很怪异的一点：它默认设置为true。这意味着所有的候选Bean都将变成首选Bean（因此，其实就不存在首选Bean了）。所以，为了使用primary属性，我们不得不将所有非首选Bean的primary属性设置为false。我们希望排除某些Bean，那可以设置这些Bean的autowire-candidate属性为false，如下所示： 1&lt;beanid=&quot;saxophone&quot;class=&quot;com.springinaction.pringidol.Saxophone&quot;autowire-candidate=&quot;false&quot;/&gt; constructor自动装配如果要通过构造器注入来配置Bean，那我们可以移除元素，由Spring在应用上下文中自动选择Bean注入到构造器入参中。 123&lt;bean id=&quot;duke&quot; class=&quot;com.springidol.PoeticJuggler&quot; autowire=&quot;constructor&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;Sonnect29&quot; class=&quot;com.springidol.Sonnet29&quot;&gt; 最佳自动装配设置autowire属性为autodetect，由Spring来决定。自动装配顺序constructor-&gt;byType-&gt;byname 3.1.2 默认自动装配如果需要为Spring应用上下文中的每一个Bean（或者其中的大多数）配置相同相同的autowire属性，那么就可以要求Spring为它所创建的所有Bean应用相同的自动装配策略来简化配置。我们所需要做的仅仅是在根元素上增加一个default-autowire属性： 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=http://www.springframework.org/schema/beans xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation=http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd default-autowire=&quot;byType&quot;&gt;&lt;/beans&gt; 默认情况下，default-autowire属性被设置为none，标示所有Bean都不使用自动装配，除非Bean自己配置了autowire属性。在这里，我们将default-autowire属性设置为byType，希望每一个Bean的所有属性都使用byType自动装配策略进行自动装配。当然了，我们可以将default-autowire属性设置为任意一种有效的自动装配策略，并将其应用于Spring配置文件中的所有Bean。注意，我只是说default-autowire应用于指定Spring配置文件中的所有Bean；我可没说它应用于Spring应用上下文中的所有Bean。你可以在一个Spring应用上下文中定义多个配置文件，每一个配置文件都可以有自己的默认自动装配策略。同样，不能因为我们配置了一个默认的自动装配策略，就意味着所有的Bean都只能使用这个默认的自动装配策略。我们还可以使用元素的autowire属性来覆盖元素所配置的默认自动装配策略。 3.1.3 混合使用默认装配和显示装配举个例子，即使kennyBean已经配置为byType自动装配策略，但它仍然可以显式装配kenny的instrument属性，如下所示： 1234&lt;bean id=&quot;kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot; autowire=&quot;byType&quot;&gt;&lt;property name=&quot;song&quot; value=&quot;JingleBells&quot;/&gt;&lt;property name=&quot;instrument&quot; ref=&quot;saxophone&quot;/&gt;&lt;/bean&gt; 例如，如果我们想为kennyBean的instrument属性装配null值，可以使用如下的配置： 1234&lt;bean id=&quot;kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot; autowire=&quot;byType&quot;&gt;&lt;property name=&quot;song&quot; value=&quot;JingleBells&quot;/&gt;&lt;property name=&quot;instrument&quot;&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt; 3.2 使用注解装配从Spring2.5开始，最有趣的一种装配SpringBean的方式是使用注解自动装配Bean的属性。使用注解自动装配与在XML中使用autowire属性自动装配并没有太大差别。但是使用注解方式允许更细粒度的自动装配，我们可以选择性地标注某一个属性来对其应用自动装配。Spring容器默认禁用注解装配。所以，在使用基于注解的自动装配前，我们需要在Spring配置中启用它。最简单的启用方式是使用Spring的context命名空间配置中的元素，如下所示： 元素告诉Spring我们打算使用基于注解的自动装配。一旦配置完成，我们就可以对代码添加注解，标识Spring应该为属性、方法和构造器进行自动装配。Spring 3支持几种不同的用于自动装配的注解：■Spring自带的@Atutowired注解；■JSR-330的@Inject注解；■JSR-250的@Resource注解。我们首先介绍如何使用Spring自带的@Autowired注解，然后再介绍如何使用Java依赖注入标准（JSR-330）的@Inject和JSR-250的@Resource。 3.2.1 使用@Autowired@Autowired示例： 1234&lt;!--使用@Autowired注解需要的声明--&gt;&lt;bean class=&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &quot;/&gt;&lt;bean id=&quot;duke&quot; class=&quot;com.springidol.PoeticJuggler&quot; autowire=&quot;constructor&quot;&gt;&lt;/bean&gt; 标注@Autowired 1234@Autowiredpublic void setInstrument(Instrument instrument) &#123; this.instrument = instrument;&#125; 另外，我们还可以使用@Autowired注解直接标注属性，并删除setter方法： 12@Autowired private Instrument instrument; @Autowired甚至不会受限于private关键字。即使in-strument属性是私有的实例变量，它仍然可以被自动装配。如果没有匹配的Bean，如何让@Autowired注解远离失败。可选的自动装配默认情况下，@Autowired具有强契约特征，其所标注的属性或参数必须是可装配的。如果没有Bean可以装配到@Autowired所标注的属性或参数中，自动装配就会失败（抛出令人讨厌的NoSuchBeanDefinitionException）。这可能是我们所期望的处理方式——当自动装配无法完成时，让Spring尽早失败，远胜于以后抛出NullPointerExcepiton异常。属性不一定非要装配，null值也是可以接受的。在这种场景下，可以通过设置@Autowired的required属性为false来配置自动装配是可选的。例如： 12@Autowired(required = false)private Instrument instrument; 在这里，Spring将尝试装配instrument属性，但是如果没有查找到与之匹配的类型为Instrument的Bean，应用就不会发生任何问题，而instrument属性的值会设置为null。注意required属性可以用于@Autowired注解所使用的任意地方。但是当使用构造器装配时，只有一个构造器可以将@Autowired的requeired属性设置为true。其他使用@Autowired注解所标注的构造器只能将required属性设置为false。此外，当使用@Autowired标注多个构造器时，Spring就会从所有满足装配条件的构造器中选择入参最多的那个构造器。限定歧义性的依赖另一方面，问题或许在于Spring并不缺少适合自动装配的Bean。可能会有足够多的Bean（或者至少2个）都完全满足装配条件，并且都可以被装配到属性或参数中。、@Autowired注解没有办法选择哪一个Bean才是它真正需要的。所以抛出NoSuchBeanDefinitionException异常，明确表明装配失败了。我们可以配合使用Spring的@Qualifier注解。例如： 123@Autowired @Qualifier(&quot; guitar&quot;) private Instrument instrument; 所示，@Qualifier注解将尝试注入ID为guitar的Bean。除了通过Bean的ID来缩小选择范围，我们还可以通过在Bean上直接使用qualifier来缩小范围。例如： 123&lt;bean id=&quot;saxophone1&quot; class=&quot;com.springidol.Piano&quot;&gt; &lt;qualifier value=&quot;ppp&quot;&gt;&lt;/qualifier&gt;&lt;/bean&gt; 123@Autowired@Qualifier(&quot;ppp&quot;)private Instrument instrument; 创建自定义的限定器（Qualifier）为了创建一个自定义的限定器注解，我们所需要做的仅仅是定义一个注解，并使用@Qualifier注解作为它的元注解。 3.2.2 借助@Inject实现基于标准的自动装配为了统一各种依赖注入框架的编程模型，JCP（JavaCommunityProcess）最近发布了Java依赖注入规范，JCP将其称为JSR-330，更常见的叫法是atinject。该规范为Java带来了通用依赖注入模型。该注解几乎可以完全替换Spring的@Au-towired注解。所以，除了使用Spring特定的@Autowired注解，我们还可以选择使用@Inject注解来标注instrument属性：限定@Inject所标注的属性一样，@Inject注解易导致歧义性的Bean定义。相对于@Autowired所对应的@Qualifier，@Inject所对应的是@Named注解。 3.2.3 在注解注入中使用表达式可以通过@Value直接标注某个属性、方法或者方法参数，并传入一个String类型的表达式来装配属性。例如： 12@Value(&quot; Eruption&quot;) private String song; 使用SpEL从系统属性中获取一个值： 12@Value(&quot;#&#123;systemProperties.myFavoriteSong&#125;&quot;)private String song; 3.3 自动检测Bean有助于完全消除Spring配置中的和元素，我们仍需要使用元素显式定义Bean。为了配置Spring自动检测，需要使用元素来代替元素： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; default-autowire=&quot;constructor&quot;&gt; &lt;context:component-scan base-package=&quot;com.springidol&quot;&gt;&lt;/context:component-scan&gt;&lt;/ beans &gt; base-package属性标识了元素所扫描的包。 3.3.1 为自动检测标注Bean默认情况下，查找使用构造型（stereotype）注解所标注的类，这些特殊的注解如下。■@Component——通用的构造型注解，标识该类为Spring组件。■@Controller——标识将该类定义为SpringMVCcontroller。■@Repository——标识将该类定义为数据仓库。■@Service——标识将该类定义为服务。■使用@Component标注的任意自定义注解。示例： 12345678@Component(&quot;guiterID&quot;)public class Guiter implements Instrument &#123; public Guiter() &#123;&#125; @Override public void play() &#123; System.out.println(&quot;guiterguiterguiterguiter&quot;); &#125;&#125; 3.3.2 过滤组件扫描事实上，在如何扫描来获得候选Bean方面，非常灵活。通过为配置和/或者子元素，我们可以随意调整扫描行为。增加一个包含过滤器来要求自动注册所有的Instrument实现类， 的type和expression属性一起协作来定义组件扫描策略。 1234&lt;context:component-scan base-package=&quot;com.springidol&quot;&gt; &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.springidol.Instrument&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;com.springidol.Piano&quot;/&gt;&lt;/context:component-scan&gt; 3.4 基于Java的Spring配置3.4.1 创建基于Java的配置需要极少量的XML来启用Java配置： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;&lt;/beans&gt; 3.4.2 定义一个配置类在 基于 Java 的 配置 里 使用@ Configuration 注解 的 Java 类， 就 等价 于 XML 配置 中的&lt; beans&gt; 元素。 123@Configurationpublic class SpringIdolConfig &#123;&#125; @Configuration注解会作为一个标识告知Spring：这个类将包含一个或多个SpringBean的定义。这些Bean的定义是使用@Bean注解所标注的方法。 3.4.3 声明一个简单的Bean示例： 1234567@Configurationpublic class SpringIdolConfig &#123; @Bean public Performer duke() &#123; return new Juggler(); &#125;&#125; 在Spring的基于Java的配置中，并没有String属性。Bean的ID和类型都被视为方法签名的一部分。Bean的实际创建是在方法体中定义的。因为它们全部是Java代码，所以我们可以进行编译期检查来确保Bean的类型是合法类型，并且Bean的ID是唯一的。 3.4.4 使用Spring的基于Java的配置进行注入1234567891011121314151617181920212223242526272829@Configurationpublic class SpringIdolConfig &#123; @Bean public Performer duke() &#123; return new Juggler(); &#125; @Bean public Performer duke15() &#123; return new Juggler(15); &#125; @Bean public Performer kenny() &#123; Instrumentalist kenny = new Instrumentalist(); kenny.setSong(&quot;aaaaaaannnnnnnnnn&quot;); return kenny; &#125; @Bean public Poem sonnet29() &#123; return new Sonnet29(); &#125; @Bean public Performer poeticDuke() &#123; return new PoeticJuggler(sonnet29()); &#125;&#125; 在Spring的Java配置中，通过声明方法引用一个Bean并不等同于调用该方法。如果真的这样，每次调用sonnet29()，都将得到该Bean的一个新的实例。Spring要比这聪明多了。","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"Bean","slug":"Bean","permalink":"https://gitflhub.github.io/tags/Bean/"},{"name":"Spring","slug":"Spring","permalink":"https://gitflhub.github.io/tags/Spring/"}]},{"title":"AOP 面向切面编程","slug":"AOP-面向切面编程","date":"2021-05-26T15:37:34.116Z","updated":"2021-05-26T15:59:26.062Z","comments":true,"path":"2021/05/26/AOP-面向切面编程/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/","excerpt":"","text":"4.1 面向切面编程的介绍横切关注点可以被描述为影响应用多处的功能。例如，安全就是一个横切关注点，应用中的许多方法都会涉及安全规则。图4.1直观呈现了横切关注点的概念。 切面提供了取代继承和委托的另一种选择，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，可以通过声明的方式定义这个功能以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面。好处：每个关注点现在都只集中于一处，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。 4.1.1 定义AOP术语AOP的术语：通知（advice）、切点（pointcut）和连接点（joinpoint）。他们之间的联系 通知（advice）：切面的工作内容被称为通知。通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用于某个方法被调用之前？之后？之前和之后？还是只在方法抛出异常时？Spring切面可以应用5种类型的通知。■Before——在方法被调用之前调用通知。■After——在方法完成之后调用通知，无论方法执行是否成功。■After-returning——在方法成功执行之后调用通知。■After-throwing——在方法抛出异常后调用通知。■Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。连接点（Joinpoint）连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。切点（Poincut）切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称模式来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。切面（Aspect）切面是通知和切点的结合。通知和切点共同定义了关于切面的全部内容——它是什么，在何时和何处完成其功能。引入（Introduction）引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一种方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中。从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。织入（Weaving）织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入。■编译期——切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。■类加载期——切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的LTW（load-timeweaving）就支持以这种方式织入切面。■运行期——切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面的。 4.1.2 Spring对AOP的支持Spring 提供 了 4 种 各具特色 的 AOP 支持：■ 基于 代理 的 经典 AOP；■@ AspectJ 注解 驱动 的 切面；■ 纯 POJO 切面；■ 注入 式 AspectJ 切面（ 适合 Spring 各 版本）。Spring通知是Java编写的Spring所创建的通知都是用标准的Java类编写的。这样的话，我们就可以使用与普通Java开发一样的集成开发环境（IDE）来开发切面。而且，定义通知所应用的切点通常在Spring配置文件里采用XML来编写的。这意味着切面的代码和配置语法对于Java开发人员来说是相当熟悉的。AspectJ与之相反。虽然AspectJ现在支持基于注解的切面，但是AspectJ最初是以Java语言扩展的方式实现的。这种方式既有优点也有缺点。通过特有的AOP语言，我们可以获得更强大和细粒度的控制，以及更丰富的AOP工具集，但是我们需要额外学习新的工具和语法。Spring在运行期通知对象通过在代理类中包裹切面，Spring在运行期将切面织入到Spring管理的Bean中。代理类封装了目标类，并拦截被通知的方法的调用，再将调用转发给真正的目标Bean。当拦截到方法调用时，在调用目标Bean方法之前，代理会执行切面逻辑。直到应用需要被代理的Bean时，Spring才创建代理对象。如果使用的是ApplicationContext，在ApplicationContext从BeanFactory中加载所有Bean时，Spring创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。Spring只支持方法连接点正如前面所探讨过的，通过各种AOP实现可以支持多种连接点模型。因为Spring基于动态代理，所以Spring只支持方法连接点。这与其他一些AOP框架是不同的，例如AspectJ和Jboss，除了方法切点，它们还提供了字段和构造器接入点。Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且Spring也不支持构造器连接点，我们也无法在Bean创建时应用通知。但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截，我们可以利用Aspect来协助SpringAOP。 4.2 使用切点选择连接点在SpringAOP中，需要使用AspectJ的切点表达式语言来定义切点。Spring仅支持AspectJ切点指示器（pointcutdesignator）的一个子集。Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。 在Spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。 4.2.1 编写切点例如，如图4.4所示的切点表达式表示当Instrument的play()方法执行时会触发通知。我们使用execution()指示器选择Instrument的play()方法。方法表达式以*号开始，标识了我们不关心方法返回值的类型。然后，我们指定了全限定类名和方法名。对于方法参数列表，我们使用（..）标识切点选择任意的play()方法，无论该方法的入参是什么。 现在 假设 我们 需要 配置 切点 仅 匹配 com. springinaction. springidol 包。 在此 场景 下， 可以 使用 within() 指示器 来 限制 匹配， 如图 4. 5 所示。 &amp;&amp;操作符把execution()和within()指示器连接在一起形成and关系（切点必须匹配所有的指示器）。因为&amp;在XML中有特殊含义，所以在使用Spring的基于XML配置来描述切点时，我们可以使用and来代替&amp;&amp;。同样，or和not可以使用||和!来分别代替。 4.2.2 使用Spring的bean()指示器Spring2.5还引入了一个新的bean()指示器，该指示器允许我们在切点表达式中使用Bean的ID来标识Bean。bean()使用BeanID或Bean名称作为参数来限制切点只匹配特定的Bean。例如： 1execution(* com. springinaction. springidol. Instrument. play()) and bean(eddie)。 希望在执行Instrument的play()方法时应用通知，但限定Bean的ID为eddie。 1execution(* com. springinaction. springidol. Instrument. play()) and !bean(eddie) 在此场景下，切面的通知会被编织到所有的ID不为eddie的Bean中。 4.3在XML中声明切面Spring的AOP配置元素简化了基于POJO切面的声明 定义一个类，然后再XML中进行配置 123456789101112131415161718192021222324252627package com.springidol;/** * @author : FL * @Classname : com.springidol.Audience * @Version : * @date : 2019-08-21 21:30 * @describe : */public class Audience &#123; public void takeSeats() &#123; System.out.println(&quot;taking seats&quot;); &#125; public void turnOffCellPhones() &#123; System.out.println(&quot;turnOffCellPhones&quot;); &#125; public void applaud() &#123; System.out.println(&quot;applaud&quot;); &#125; public void demandrefund() &#123; System.out.println(&quot;Boo!We what our money back&quot;); &#125;&#125; 配置文件中声明： 123&lt;bean id=&quot;audience&quot; class=&quot;com.springidol.Audience&quot;&gt;&lt;/bean&gt; 4.3.1 声明前置后后置通知把audienceBean变成一个切面配置文件修改如下 12345678&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:aspect ref=&quot;audience&quot;&gt; &lt;aop:before method=&quot;takeSeats&quot; pointcut=&quot;execution(* com.springidol.Performer.perform(..))&quot; /&gt; &lt;aop:before method=&quot;turnOffCellPhones&quot; pointcut=&quot;execution(* com.springidol.Performer.perform(..))&quot; /&gt; &lt;aop:after-returning method=&quot;applaud&quot; pointcut=&quot;execution(* com.springidol.Performer.perform())&quot; /&gt; &lt;aop:after-throwing method=&quot;demandrefund&quot; pointcut=&quot;execution(* com.springidol.Performer.perform())&quot; /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 元素内，可以声明多个通知器、切面或者切点两个元素定义了匹配切点的方法执行之前调用前置通知方法——audienceBean的takeSeats()和turnOffCellPhones()方法（由method属性所声明）。元素定义了一个返回后（after-returning）通知，在切点所匹配的方法调用之后再执行applaud()方法。同样，元素定义了抛出后通知，如果所匹配的方式执行时抛出任何异常，都将调用demandRefund()方法。图4.6展示了通知逻辑如何编织到业务逻辑中。 在所有的通知元素中，pointcut属性定义了通知所应用的切点。pointcut属性的值是使用AspectJ切点表达式语法所定义的切点。使用元素来定义一个可以在所有的通知元素中使用的命名切点。 123456789101112&lt;bean id=&quot;audience&quot; class=&quot;com.springidol.Audience&quot;&gt;&lt;/bean&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:aspect ref=&quot;audience&quot;&gt; &lt;aop:pointcut id=&quot;performance&quot; expression=&quot;execution(* com.springidol.Performer.perform())&quot;/&gt; &lt;aop:before method=&quot;takeSeats&quot; pointcut-ref=&quot;performance&quot; /&gt; &lt;aop:before method=&quot;turnOffCellPhones&quot; pointcut-ref=&quot;performance&quot; /&gt; &lt;aop:after-returning method=&quot;applaud&quot; pointcut-ref=&quot;performance&quot; /&gt; &lt;aop:after-throwing method=&quot;demandrefund&quot; pointcut-ref=&quot;performance&quot; /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 4.3.2 声明环绕通知123456789101112131415public void watchPerformance(ProceedingJoinPoint joinPoint) &#123; try &#123; System.out.println(&quot;takingSeats&quot;); System.out.println(&quot;turningoffphone&quot;); long start = System.currentTimeMillis(); joinPoint.proceed(); long end = System.currentTimeMillis(); System.out.println(&quot;clap&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); System.out.println(&quot;time:&quot; + (end - start) + &quot;ms&quot;); &#125; catch (Throwable t) &#123; System.out.println(&quot;money back&quot;); &#125;&#125; 对于新的通知方法，我们首先会注意到它使用了ProceedingJoinPoint作为方法的入参。这个对象非常重要，因为它能让我们在通知里调用被通知方法。通知方法可以完成任何它所需要做的事情，而且如果希望把控制转给被通知的方法时，我们可以调用ProceedingJoinPoint的proceed()方法。谨记我们必须调用proceed()方法。如果忘记这样做，通知将会阻止被通知的方法的调用。或许这正是我们所需要的，但是更好的方式是在某一点执行被通知的方法。更有意思的是，正如我们可以忽略调用proceed()方法来阻止执行被通知的方法，我们还可以在通知里多次调用被通知的方法。这样做的一个原因是实现重试逻辑，在被通知的方法执行失败时反复重试。在此示例中的audience切面，watchPerformance()方法包含之前4个通知方法的所有逻辑，但所有的逻辑都放在一个单独的方法中了，而且该方法还会负责自身的异常处理。同时我们也注意到在连接点的proceed()方法被调用之前，当前时间被记录在一个局部变量中；当方法返回后，系统会打印执行时间。声明环绕通知与声明其他类型的通知并没有太大区别。我们所需要做的仅仅是使用 元素。 123456&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:aspect ref=&quot;audience&quot;&gt; &lt;aop:pointcut id=&quot;performance2&quot; expression=&quot;execution(* com.springidol.Performer.perform())&quot;/&gt; &lt;aop:around method=&quot;watchPerformance&quot; pointcut-ref=&quot;performance2&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 4.3.3 为通知传递参数切面和实例化对象进行传参：配置文件： 12345678&lt;bean id=&quot;volunteer&quot; class=&quot;com.springidol.Volunteer&quot; /&gt;&lt;bean id=&quot;magician&quot; class=&quot;com.springidol.Magician&quot;/&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:aspect ref=&quot;magician&quot;&gt; &lt;aop:pointcut id=&quot;thinking1&quot; expression=&quot;execution(* com.springidol.Volunteer.setVolunteerThoughts(String)) and args(thoughts)&quot;/&gt; &lt;aop:before pointcut-ref=&quot;thinking1&quot; method=&quot;interceptThoughts&quot; arg-names=&quot;thoughts&quot;&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 其中Volunteer和Magician的定义如下 1234567891011121314151617181920212223public class Volunteer implements Thinker &#123; private String volunteerThoughts; public void thinkOfSomething(String volunteerThoughts) &#123; this.volunteerThoughts = volunteerThoughts; &#125; public String getThoughts() &#123; return volunteerThoughts; &#125;&#125;public class Magician implements MindReader &#123; private String thoughts; public void interceptThoughts(String thoughts) &#123; System.out.println(&quot;Intercepting...............&quot;); this.thoughts = thoughts; &#125; public String getThoughts() &#123; return thoughts; &#125;&#125; 4.3.4 通过切面引入新功能 当引入接口的方法被调用时，代理将此调用委托给实现了新接口的某个其他对象。实际上，Bean的实现被拆分到了多个类。 12345&lt;aop:config&gt; &lt;aop:aspect&gt; &lt;aop:declare-parents types-matching=&quot;com.springidol.Performer+&quot; implement-interface=&quot;com.springidol.Contestant&quot; default-impl=&quot;com.springidol.GraciousContestant&quot; /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 暂时不懂要干嘛 4.4注解切面使用注解来创建切面是AspectJ5所引入的关键特性。AspectJ5之前，编写As-pectJ切面需要学习一种Java语言的扩展，但是AspectJ面向注解的模型可以非常简便地通过少量注解把任意类转变为切面。这种新特性通常称为@AspectJ。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Aspectpublic class Audience &#123; @Pointcut(&quot;execution(* com.springidol.Performer.perform())&quot;) public void performance() &#123; &#125; @Before(&quot;performance()&quot;) public void takeSeats() &#123; System.out.println(&quot;taking seats&quot;); &#125; @Before(&quot;performance()&quot;) public void turnOffCellPhones() &#123; System.out.println(&quot;turnOffCellPhones&quot;); &#125; @AfterReturning(&quot;performance()&quot;) public void applaud() &#123; System.out.println(&quot;applaud&quot;); &#125; @AfterThrowing public void demandFraud() &#123; System.out.println(&quot;Boo!We what our money back&quot;); &#125; public void watchPerformance(ProceedingJoinPoint joinPoint) &#123; try &#123;// System.out.println(&quot;takingSeats&quot;);// System.out.println(&quot;turningoffphone&quot;); long start = System.currentTimeMillis(); joinPoint.proceed(); long end = System.currentTimeMillis();// System.out.println(&quot;clap&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); System.out.println(&quot;time:&quot; + (end - start) + &quot;ms&quot;); &#125; catch (Throwable t) &#123; System.out.println(&quot;money back&quot;); &#125; &#125;&#125; 新的Audience类现在已经使用@AspectJ注解进行了标注。该注解标识了Audience不仅仅是一个POJO，还是一个切面。@Pointcut注解用于定义一个可以在@AspectJ切面内可重用的切点。@Pointcut注解的值是一个AspectJ切点表达式——这里标识该切点必须匹配Performer的perform()方法。切点的名称来源于注解所应用的方法名称。因此，该切点的名称为performance()。performance()方法的实际内容并不重要，在这里它事实上是空的。其实该方法本身只是一个标识，供@Pointcut注解依附。Audience的每一个方法都使用了通知注解来标注。takeSeats()和turnOffCellPhones()方法使用@Before注解来标识它们是前置通知方法。applaud()方法使用@AfterReturning注解来标识它是后置通知方法，而demandRefund()方法使用了@AfterThrowing注解，所以如果在表演时抛出任何异常，该方法都会被调用。performance()切点的名称作为参数的值赋给了所有的通知注解。以这种方式来标识每一个通知方法应该应用在哪里。注意，除了那些注解和无操作的performance()方法，Audience类在实现上并没有任何改变。这意味着Audience仍然是一个简单的Java对象，能够像以前一样使用。该类仍然可以像下面一样在Spring中进行装配： 因为Audience类本身包含了所有它所需要定义的切点和通知，所以我们不再需要在XML配置中声明切点和通知。最后一件需要做的事是让Spring将Audience应用为一个切面。我们需要在Spring上下文中声明一个自动代理Bean，该Bean知道如何把@AspectJ注解所标注的Bean转变为代理通知。为此，Spring自带了名为AnnotationAwareAspectJAutoProxyCreator的自动代理创建类。我们可以在Spring上下文中把AnnotationAwareAspectJAutoProxyCreator注册为一个Bean，但是我们需要需要 敲一大段的文字（相信我……我之前敲过几次了）。因此，为了简化如此长的名字，Spring在aop命名空间中提供了一个自定义的配置元素，该元素很容易被记住： 将在Spring上下文中创建一个AnnotationAwareAspectJAutoProxyCreator类，它会自动代理一些Bean，这些Bean的方法需要与使用@Aspect注解的Bean中所定义的切点相匹配，而这些切点又是使用@Pointcut注解定义出来的。为了使用配置元素，我们需要在Spring的配置文件中包含aop命名空间： 1&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xmlns:aop=”http://www.springframework.org/schema/aop” xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt; 我们需要记住仅仅使用@AspectJ注解作为指引来创建基于代理的切面，但本质上它仍然是一个Spring风格的切面。这非常有意义，因为这意味着虽然我们使用@AspectJ的注解，但是我们仍然限于代理方法的调用。如果想利用AspectJ的所有能力，我们必须在运行时使用AspectJ并不依赖Spring来创建基于代理的切面。同样值得一提的是，元素和@AspectJ注解都是把一个POJO转变为一个切面的有效方式。但是相对于@AspectJ的一个明显优势是我们不需要实现切面功能的源码。通过@AspectJ，我们必须标注类和方法，它需要有源码。而可以引用任意一个Bean。 4.4.1 注解环绕通知12345678910111213141516@Around(&quot; performance()&quot;)public void watchPerformance(ProceedingJoinPoint joinPoint) &#123; try &#123; System.out.println(&quot;takingSeats&quot;); System.out.println(&quot;turningoffphone&quot;); long start = System.currentTimeMillis(); joinPoint.proceed(); long end = System.currentTimeMillis(); System.out.println(&quot;clap&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;); System.out.println(&quot;time:&quot; + (end - start) + &quot;ms&quot;); &#125; catch (Throwable t) &#123; System.out.println(&quot;money back&quot;); &#125;&#125; 但是简单地使用@Around注解来标注方法并不足以调用proceed()方法，因此，被环绕通知的方法必须接受一个ProceedingJoinPoint对象作为方法入参，并在对象上调用proceed()方法。 4.4.2 传递参数给所标注的通知12345678910111213141516171819@Aspectpublic class Magician implements MindReader &#123; private String thoughts; @Pointcut(&quot;execution(* com.springidol.&quot; + &quot;Thinker.thinkOfSomething(String)) &amp;&amp; args(thoughts)&quot;) public void thinking(String thoughts) &#123; &#125; @Before(&quot;thinking(thoughts)&quot;) public void interceptThoughts(String thoughts) &#123; System.out.println(&quot;Intercepting...............&quot;); this.thoughts = thoughts; &#125; public String getThoughts() &#123; return thoughts; &#125;&#125; 元素变为@Pointcut注解，而元素变为@Before注解。在这里，唯一发生显著变化的是@AspectJ能够依靠Java语法来判断为通知所传递参数的细节。因此，这里并不需要与元素的argnames属性所对应的注解。 Spring提供了几种技巧，可以帮助我们减少XML的配置数量。自动装配（autowiring）有助于减少甚至消除配置元素和元素，让Spring自动识别如何装配Bean的依赖关系。自动检测（autodiscovery）比自动装配更进了一步，让Spring能够自动识别哪些类需要被配置成SpringBean，从而减少对元素的使用。当自动装配和自动检测一起使用时，它们可以显著减少Spring的XML配置数量。通常只需要配置少量的几行XML代码，而无需知道在Spring的应用上下文中究竟有多少Bean。","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://gitflhub.github.io/tags/AOP/"}]},{"title":"Java 中的锁","slug":"Java-中的锁","date":"2021-05-26T15:31:11.111Z","updated":"2021-05-26T16:00:07.676Z","comments":true,"path":"2021/05/26/Java-中的锁/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Java-%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"","text":"序号 锁名称 应用 1 乐观锁 CAS 2 悲观锁 synchronized、vector、hashtable 3 自旋锁 CAS 4 可重入锁 synchronized、Reentrantlock、Lock 5 读写锁 ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet 6 公平锁 Reentrantlock(true) 7 非公平锁 synchronized、reentrantlock(false) 8 共享锁 ReentrantReadWriteLock中读锁 9 独占锁 synchronized、vector、hashtable、ReentrantReadWriteLock中写锁 10 重量级锁 synchronized 11 轻量级锁 锁优化技术 12 偏向锁 锁优化技术 13 分段锁 concurrentHashMap 14 互斥锁 synchronized 15 同步锁 synchronized 16 死锁 相互请求对方的资源 17 锁粗化 锁优化技术 18 锁消除 锁优化技术 1、乐观锁 乐观锁是一种乐观思想，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）。Java中的乐观锁：CAS，比较并替换，比较当前值（主内存中的值），与预期值（当前 线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。**可以同时进行读操作，读的时候其他线程不能进行写操作。 2、悲观锁悲观锁是一种悲观思想，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。Java中的悲观锁：synchronized修饰的方法和方法块、ReentrantLock。只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行。 3、自旋锁自旋锁是一种技术： 为了让线程等待，我们只须让线程执行一个忙循环（自旋）。现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面 请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是 否很快就会释放锁。自旋锁的优点：避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。自旋锁的缺点： 占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源， 而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限 度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起 线程。自旋次数默认值：10次，可以使用参数-XX:PreBlockSpin来自行更改。 自适应自旋： 自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长 及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。Java中的自旋锁： CAS操作中的比较操作失败后的自旋等待。 4、可重入锁（递归锁）可重入锁是一种技术： 任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。可重入锁的原理： 通过组合自定义同步器来实现锁的获取与释放。再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再 次成功获取。获取锁后，进行计数自增，释放锁：释放锁时，进行计数自减。Java中的可重入锁： ReentrantLock、synchronized修饰的方法或代码段。可重入锁的作用： 避免死锁。面试题1： 可重入锁如果加了两把，但是只释放了一把会出现什么问题？答：程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。 面试题2： 如果只加了一把锁，释放两次会出现什么问题？ 答：会报错，java.lang.IllegalMonitorStateException。 5、读写锁读写锁是一种技术： 通过ReentrantReadWriteLock类来实现。为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。读锁： 允许多个线程获取读锁，同时访问同一个资源。 写锁： 只允许一个线程获取写锁，不允许同时访问同一个资源。 如何使用：/** 创建一个读写锁 它是一个读写融为一体的锁，在使用的时候，需要转换*/private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();复制代码获取读锁和释放读锁// 获取读锁rwLock.readLock().lock();// 释放读锁rwLock.readLock().unlock();复制代码获取写锁和释放写锁// 创建一个写锁rwLock.writeLock().lock();// 写锁 释放rwLock.writeLock().unlock();复制代码Java中的读写锁：ReentrantReadWriteLock 6、公平锁公平锁是一种思想： 多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不 为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。 7、非公平锁非公平锁是一种思想： 线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的 线程优先获取锁。优点： 非公平锁的性能高于公平锁。缺点： 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）Java中的非公平锁：synchronized是非公平锁，ReentrantLock通过构造函数指定 该锁是公平的还是非公平的，默认是非公平的。 8、共享锁共享锁共享锁是一种思想： 可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义。Java中用到的共享锁：ReentrantReadWriteLock。 9、独占锁独占锁是一种思想： 只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。Java中用到的独占锁： synchronized，ReentrantLock 10、重量级锁重量级锁是一种称谓：synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本身依赖底层的操作系统的 Mutex Lock来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系 统 Mutex Lock来实现的锁称为重量级锁。为了优化synchonized，引入了轻量级锁， 偏向锁。Java中的重量级锁： synchronized 11、轻量级锁轻量级锁是JDK6时加入的一种锁优化机制： 轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。优点： 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。缺点： 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。 12、偏向锁偏向锁是JDK6时加入的一种锁优化机制： 在无竞争的情况下把整个同步都消除掉， 连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线 程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的 线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块 时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。优点： 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。缺点： 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。 13、分段锁分段锁是一种机制： 最好的例子来说明分段锁是ConcurrentHashMap。ConcurrentHashMap原理：它内部细分了若干个小的 HashMap，称之为段(Segment)。 默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap 添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行 put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并 行。线程安全：ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全 14、互斥锁互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访 问。读-读互斥读-写互斥写-读互斥 写-写互斥Java中的同步锁： synchronized 15、同步锁同步锁与互斥锁同义，表示并发执行的多个线程，在同一时间内只允许一个线程访问 共享数据。Java中的同步锁： synchronized 16、死锁死锁是一种现象：如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获 取不到对方的资源，就会造成死锁。Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意 程序的并发场景，避免造成死锁。 17、锁粗化锁粗化是一种优化技术： 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步 操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损 耗。 18、锁消除锁消除是一种优化技术： 就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。那如何判断共享数据不会被线程竞争？利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待， 认为它是线程私有的，同步加锁就不需要了。 19、synchronizedsynchronized是Java中的关键字：用来修饰方法、对象实例。属于独占锁、悲观锁、可重入锁、非公平锁。 作用于实例方法时，锁住的是对象的实例(this)；2.当作用于静态方法时，锁住的是 Class类，相当于类的一个全局锁，会锁所有调用该方法的线程；3.synchronized 作用于一个非 NULL的对象实例时，锁住的是所有以该对象为锁的代码块。 它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在代码块前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。20、Lock和synchronized的区别Lock： 是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别2.Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。3.synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 4.Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断。5.通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。6.Lock 可以通过实现读写锁提高多个线程进行读操作的效率。synchronized的优势：足够清晰简单，只需要基础的同步功能时，用synchronized。Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即 使出现异常，锁也能被自动释放。使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。21、ReentrantLock 和synchronized的区别 ReentrantLock是Java中的类 ： 继承了Lock类，可重入锁、悲观锁、独占锁、互斥锁、同步锁。划重点相同点： 不同点： 主要解决共享变量如何安全访问的问题2.都是可重入锁，也叫做递归锁，同一线程可以多次获得同一个锁，3.保证了线程安全的两大特性：可见性、原子性。 1.ReentrantLock 就像手动汽车，需要显示的调用lock和unlock方法， synchronized 隐式获得释放锁。2.ReentrantLock 可响应中断， synchronized 是不可以响应中断的， ReentrantLock 为处理锁的不可用性提供了更高的灵活性3.ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的4.ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁，synchronized 是非公平锁，且不可更改。5.ReentrantLock 通过 Condition 可以绑定多个条件","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"锁","slug":"锁","permalink":"https://gitflhub.github.io/tags/%E9%94%81/"}]},{"title":"JAVA虚拟机基础概念","slug":"JAVA虚拟机基础概念","date":"2021-05-26T15:06:57.320Z","updated":"2021-05-26T16:00:00.124Z","comments":true,"path":"2021/05/26/JAVA虚拟机基础概念/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","excerpt":"","text":"类装载子系统将编译好的.class文件装载到运行时数据区 运行时数据区堆new 出来的对象放在内存堆首先是新生代的伊甸园区，然后minor gc 定期检查该（伊甸园区和survivor区）对象，检查后将有用对象将对象放入另一个 survivor 区域伊甸园：Survivor ：Survivor = 8 : 1: 1当Survivor 区中的年代数达到15， 则会被移入老年代，新生代放中Survivor 对象大小超过Survivor大小的50%，也会直接被放入老年代 栈栈帧：调用一个方法，生成自己专属的内存空间（栈帧），符合FILO，存放局部变量、操作数、动态链接、方法出口 例如java源代码：123456789101112131415161718package com.tuling.redission;public class Math &#123; public static final int intData = 666; public static User user = new User(); public int compute() &#123; int a = 1; int b = 2; int c =(a + b) * 10; return c; &#125; public static void main(String[] args) &#123; Math math = new Math(); System.out.println(math.compute()); &#125;&#125;可使用cmd命令来反汇编class文件1javap -c xxx.class &gt; xxx.txt得到该目录下的反汇编指令文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Compiled from &quot;Math.java&quot;public class com.tuling.redission.Math &#123; public static final int intData; public static com.tuling.redission.HelloWorld helloWorld; public com.tuling.redission.Math(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public int compute(); Code: 0: iconst_1 1: istore_1 2: iconst_2 3: istore_2 4: iload_1 5: iload_2 6: iadd 7: bipush 10 9: imul 10: istore_3 11: iload_3 12: ireturn public static void main(java.lang.String[]); Code: 0: new #2 // class com/tuling/redission/Math 3: dup 4: invokespecial #3 // Method &quot;&lt;init&gt;&quot;:()V 7: astore_1 8: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 11: aload_1 12: invokevirtual #5 // Method compute:()I 15: invokevirtual #6 // Method java/io/PrintStream.println:(I)V 18: return static &#123;&#125;; Code: 0: new #7 // class com/tuling/redission/HelloWorld 3: dup 4: invokespecial #8 // Method com/tuling/redission/HelloWorld.&quot;&lt;init&gt;&quot;:()V 7: putstatic #9 // Field helloWorld:Lcom/tuling/redission/HelloWorld; 10: return&#125;指令解释链接：http://www.ronblog.cn//article/6 局部变量 和 操作数如对指令进行分析 1int a = 1; 就是给变量a 分配 局部变量栈空间，再将1复制到操作数栈。然后操作数1出栈，写入a的局部变量空间。局部变量 0 调用当前方法的this指针局部变量math栈和堆的关系也可以理解为：栈 中有很多指向 堆的指针 动态链接：把符号引用换成直接引用。实现函数的调用，找到函数名称对应的方法内存入口 程序计数器存放下一条指令的行号（其实是方法区的指令内存空间地址）。目的是为了进行线程切换。其值由字节码执行引擎进行修改。 方法出口指向调用函数 如main（）方法 方法区又叫元空间，存放常量、静态变量、类信息、函数方法例如静态变量user1public static User user = new User();静态变量user存放在方法区中，但还是一个指针，指向了堆 本地方法栈一些JAVA的底层C++ 的具体实现：例如：1new Thread().start();查看源码能看见底层1private native void start(); 字节码执行引擎1.执行内存里的代码2.开启垃圾收集线程，收集的垃圾对象 垃圾回收算法：可达性分析（类比数据结构）将GC root 对象作为起点，线程的本地变量、静态变量、本地方法栈等等从这些起点开始向下搜索文件。从直接引用找到间接引用，这些对象都是非垃圾对象 minor gc 会回收整个年轻代的内存空间","categories":[{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://gitflhub.github.io/tags/JVM/"}]},{"title":"Markdown 制作 Anki 卡片","slug":"Markdown-制作-Anki-卡片","date":"2021-05-26T14:44:46.268Z","updated":"2021-05-26T16:01:04.531Z","comments":true,"path":"2021/05/26/Markdown-制作-Anki-卡片/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Markdown-%E5%88%B6%E4%BD%9C-Anki-%E5%8D%A1%E7%89%87/","excerpt":"","text":"同好会arkDown 编辑器 方式一：MarkDown 编辑器资料准备这里以Typora为例：1.打开MarkDown 编辑器2.设置标题层级3.四级标题#### 这层标题为面试的具体问题，如“JRE和JDK的区别？”4.五级标题##### 这层标题为面试问题的具体答案,示例如下：123456789101112131415# JAVA工程师面试## 1.JAVA ### (1)Java基础#### JRE和JDK的区别##### JDK Java Development Kit,Java 开发工具包，提供了开发环境和运行环境##### JRE Java Runtime Environment Java 运行环境，为Java提供了所需的环境##### 运行Java程序，JRE即可##### 编写Java程序，需要安装JDK 格式转换1.转为Anki批量格式CSV网上有一个大佬做了Markdown转Anki卡片的功能，链接如下https://hintsnet.com/tools/md2anki/index.html 2.格式调整由于下载来的文件里面默认HTML标签是&lt; ol &gt;,在文本编辑器中批量替换为&lt; ul &gt; 3.导入Anki方式二：网页数据爬取网页爬取数据爬取工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;/** * 网页抓取工具类 */public class Test1 &#123; /** * 方法入口 * * @param htmltest 要获取的资源URL * @param laber anki标签 */ public static void demo1(String htmltest, String laber) &#123; String html = htmltest; // HTML文档对象 Document doc = Jsoup.parse(html); Elements rows = doc.select(&quot;div[class=interview_detail]&quot;).get(0).select(&quot;ul&quot;).select(&quot;li&quot;); Elements rowTitle = doc.select(&quot;div[class=interview_detail]&quot;); // 生成Anki题目 Element pFirst = rowTitle.select(&quot;p&quot;).first(); // rowTitle.remove(pFirst); StringBuffer stringBuffer = new StringBuffer(); String res = rowTitle.html(); if (rows.size() == 0) &#123; &#125; else &#123; // 获取网页结构指定的div[class=interview_wrap] 的代码信息 String title = doc.select(&quot;div[class=interview_wrap]&quot;).select(&quot;h2&quot;).get(0).text(); // 替换回车 res = res.replaceAll(&quot;(\\\\r\\\\n|\\\\n|\\\\n\\\\r)&quot;, &quot; &quot;) .replaceAll(&quot;\\t&quot;, &quot;&quot;) .replaceAll(&quot;class=\\&quot;language-java\\&quot;&quot;, &quot;&quot;); if (pFirst != null) &#123; // 删除空行 res = res.replaceAll(pFirst.html(), &quot;&quot;).replaceAll(&quot;&lt;p&gt;&lt;/p&gt;&quot;, &quot;&quot;); &#125; // title 是anki卡片正面 stringBuffer.append(title).append(&quot;\\t &quot;); // 标签分类 stringBuffer.append(laber).append(&quot;\\t &quot;); // res 是anki卡片反面 stringBuffer.append(res); System.out.println(stringBuffer.toString()); &#125; &#125;&#125; maven 依赖12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.13.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 主方法123456789101112131415161718192021222324252627282930313233343536import java.io.*;import java.net.URL;import java.util.stream.Collectors;public class Script &#123; public static void main(String[] args) &#123; // 这个文件里面存放了链接信息 File file = new File(&quot;src/main/resources/url.txt&quot;); try &#123; // 读取配置信息 BufferedReader in = new BufferedReader(new FileReader(file)); String str; String label = &quot;&quot;; while ((str = in.readLine()) != null) &#123; // 获取Anki标签 if (str.contains(&quot;@&quot;)) &#123; label = str.substring(1); &#125; else &#123; // 链接拼接 String urlStr = &quot;https://www.javanav.com/interview/&quot; + str + &quot;.html&quot;; // 网址 URL url = new URL(urlStr); String result = new BufferedReader(new InputStreamReader(url.openStream())) .lines().parallel().collect(Collectors.joining(System.lineSeparator())); // 调用爬取入口 Test1.demo1(result, label); // 读取太快会被反爬虫 Thread.sleep(10 * 3); &#125; &#125; &#125; catch (IOException | InterruptedException e) &#123; &#125; &#125;&#125; 控制台打印结果（部分）12345678==和equals的区别是什么? Java基础 &lt;ul&gt; &lt;li&gt;== 是关系运算符，equals() 是方法，结果都返回布尔值&lt;/li&gt; &lt;li&gt;Object 的 == 和 equals() 比较的都是地址，作用相同&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;== 作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;基本类型，比较值是否相等&lt;/li&gt; &lt;li&gt;引用类型，比较内存地址值是否相等&lt;/li&gt; &lt;li&gt;不能比较没有父子关系的两个对象&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;equals()方法的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;JDK 中的类一般已经重写了 equals()，比较的是内容&lt;/li&gt; &lt;li&gt;自定义类如果没有重写 equals()，将调用父类（默认 Object 类）的 equals() 方法，Object 的 equals() 比较使用了 this == obj&lt;/li&gt; &lt;li&gt;可以按照需求逻辑，重写对象的 equals() 方法（重写 equals方法，一般须重写 hashCode方法）&lt;/li&gt; &lt;/ul&gt; 基本类型和包装类对象使用 == 和 equals进行比较的结果？ Java基础 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;1、值不同，使用 ＝＝ 和 equals() 比较都返回 false&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、值相同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;使用 ＝＝ 比较：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;基本类型 － 基本类型、基本类型 － 包装对象返回 true&lt;/li&gt; &lt;li&gt;包装对象 － 包装对象，非同一个对象（对象的内存地址不同）返回 false；对象的内存地址相同返回 true，如下值等于 100 的两个 Integer 对象（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）&lt;/li&gt; &lt;/ul&gt; &lt;pre&gt; &lt;code&gt; Integer i1 = 100; &amp;nbsp;Integer i2 = 100; &amp;nbsp;Integer i3 = 200; &amp;nbsp;Integer i4 = 200; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(i1==i2); //打印true &amp;nbsp;System.out.println(i3==i4); //打印false&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;使用 equals() 比较&lt;/p&gt; &lt;ul&gt; &lt;li&gt;包装对象－基本类型返回 true&lt;/li&gt; &lt;li&gt;包装对象－包装对象返回 true&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;3、不同类型的对象对比，返回 false&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;JDK1.8，实验代码&lt;/p&gt; &lt;pre&gt; &lt;code &gt;byte b1 = 127; Byte b2 = new Byte(&quot;127&quot;); Byte b3 = new Byte(&quot;127&quot;); System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2)); System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1)); System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3)); System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3)); System.out.println(); short s1 = 12; Short s2 = new Short(&quot;12&quot;); Short s3 = new Short(&quot;12&quot;); System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2)); System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1)); System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3)); System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3)); System.out.println(); char c1 = &#x27;A&#x27;; Character c2 = new Character(&#x27;A&#x27;); Character c3 = new Character(&#x27;A&#x27;); System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2)); System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1)); System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3)); System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3)); System.out.println(); int i1 = 10000; Integer i2 = new Integer(10000); Integer i3 = new Integer(10000); System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2)); System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1)); System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3)); System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3)); System.out.println(); long l1 = 1000000000000000L; Long l2 = new Long(&quot;1000000000000000&quot;); Long l3 = new Long(&quot;1000000000000000&quot;); System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2)); System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1)); System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3)); System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3)); System.out.println(); float f1 = 10000.111F; Float f2 = new Float(&quot;10000.111&quot;); Float f3 = new Float(&quot;10000.111&quot;); System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2)); System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1)); System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3)); System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3)); System.out.println(); double d1 = 10000.111; Double d2 = new Double(&quot;10000.111&quot;); Double d3 = new Double(&quot;10000.111&quot;); System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2)); System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1)); System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3)); System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3)); System.out.println(); boolean bl1 = true; Boolean bl2 = new Boolean(&quot;true&quot;); Boolean bl3 = new Boolean(&quot;true&quot;); System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2)); System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1)); System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3)); System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;br&gt; 运行结果&lt;/p&gt; &lt;pre&gt; &lt;code&gt;Byte 基本类型和包装对象使用 == 比较 : true Byte 基本类型和包装对象使用 equals 比较 : true Byte 包装对象和包装对象使用 == 比较 : false Byte 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Short 基本类型和包装对象使用 == 比较 : true Short 基本类型和包装对象使用 equals 比较 : true Short 包装对象和包装对象使用 == 比较 : false Short 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Character 基本类型和包装对象使用 == 比较 : true Character 基本类型和包装对象使用 equals 比较 : true Character 包装对象和包装对象使用 == 比较 : false Character 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Integer 基本类型和包装对象使用 == 比较 : true Integer 基本类型和包装对象使用 equals 比较 : true Integer 包装对象和包装对象使用 == 比较 : false Integer 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Long 基本类型和包装对象使用 == 比较 : true Long 基本类型和包装对象使用 equals 比较 : true Long 包装对象和包装对象使用 == 比较 : false Long 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Float 基本类型和包装对象使用 == 比较 : true Float 基本类型和包装对象使用 equals 比较 : true Float 包装对象和包装对象使用 == 比较 : false Float 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Double 基本类型和包装对象使用 == 比较 : true Double 基本类型和包装对象使用 equals 比较 : true Double 包装对象和包装对象使用 == 比较 : false Double 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Boolean 基本类型和包装对象使用 == 比较 : true Boolean 基本类型和包装对象使用 equals 比较 : true Boolean 包装对象和包装对象使用 == 比较 : false Boolean 包装对象和包装对象使用 equals 比较 : true&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt; &lt;p&gt;ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程&lt;/p&gt;什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？ Java基础 &lt;p&gt;装箱：基本类型转变为包装器类型的过程。&lt;br&gt; 拆箱：包装器类型转变为基本类型的过程。&lt;/p&gt; &lt;pre&gt; &lt;code &gt;//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须 Integer i = new Integer(8); &amp;nbsp; //JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样 Integer i = 8; &amp;nbsp; int n = i;//自动拆箱&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、装箱和拆箱的执行过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;装箱是通过调用包装器类的 valueOf 方法实现的&lt;/li&gt; &lt;li&gt;拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。&lt;/li&gt; &lt;li&gt;如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;3、常见问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。&lt;/li&gt; &lt;li&gt;浮点型的包装类 valueOf 方法返回新的对象。&lt;/li&gt; &lt;li&gt;布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;实验代码&lt;/p&gt; &lt;pre&gt; &lt;code&gt;Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1 == i2);//true System.out.println(i3 == i4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Double d1 = 100.0; Double d2 = 100.0; Double d3 = 200.0; Double d4 = 200.0; System.out.println(d1 == d2);//false System.out.println(d3 == d4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Boolean b1 = false; Boolean b2 = false; Boolean b3 = true; Boolean b4 = true; System.out.println(b1 == b2);//true System.out.println(b3 == b4);//true&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;包含算术运算会触发自动拆箱。&lt;/li&gt; &lt;li&gt;存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt; &lt;pre&gt; &lt;code &gt;Integer s1 = 0; long t1 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s1 += i; &#125; long t2 = System.currentTimeMillis(); System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; int s2 = 0; long t3 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s2 += i; &#125; long t4 = System.currentTimeMillis(); System.out.println(&quot;使用int，递增相加耗时：&quot; + (t4 - t3));//使用int，递增相加耗时：6&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;hashCode()相同，equals()也一定为true吗？ Java基础 &lt;p&gt;首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。&lt;/p&gt; &lt;ul&gt; &lt;li&gt;类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。&lt;/li&gt; &lt;li&gt;hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;关于 hashCode() 和 equals() 是方法是有一些 常规协定：&lt;/p&gt; &lt;p&gt;1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。&lt;/p&gt; &lt;p&gt;2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。&lt;/p&gt; &lt;p&gt;3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p&gt;就像打人是你的能力，但打伤了就违法了。重写 equals 和 hashCode 方法返回是否为 true 是你的能力，但你不按照上述协议进行控制，在用到对象 hash 和 equals 逻辑判断相等时会出现意外情况，如 HashMap 的 key 是否相等。&lt;/p&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;final在java中的作用 Java基础 &lt;ul&gt; &lt;li&gt;被 final 修饰的类，不能够被继承&lt;/li&gt; &lt;li&gt;被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象&lt;/li&gt; &lt;li&gt;被 final 修饰的方法不能重写&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;final finally finalize()区别 Java基础 &lt;ul&gt; &lt;li&gt;final 表示最终的、不可改变的。用于修饰类、方法和变量。final 修饰的类不能被继承；final 方法也同样只能使用，不能重写，但能够重载；final 修饰的成员变量必须在声明时给定初值或者在构造方法内设置初始值，只能读取，不可修改；final 修饰的局部变量必须在声明时给定初值；final 修饰的变量是非基本类型，对象的引用地址不能变，但对象的属性值可以改变&lt;/li&gt; &lt;li&gt;finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）&lt;/li&gt; &lt;li&gt;finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。&lt;/li&gt; &lt;/ul&gt; finally语句块一定执行吗？ Java基础 &lt;ul&gt; &lt;li&gt;直接返回未执行到 try-finally 语句块&lt;/li&gt; &lt;li&gt;抛出异常未执行到 try-finally 语句块&lt;/li&gt; &lt;li&gt;系统退出未执行到 finally 语句块&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;等...&lt;/p&gt; &lt;p&gt;代码如下&lt;/p&gt; &lt;pre&gt; &lt;code &gt;public static String test() &#123; String str = null; int i = 0; if (i == 0) &#123; return str;//直接返回未执行到finally语句块 &#125; try &#123; System.out.println(&quot;try...&quot;); return str; &#125; finally &#123; System.out.println(&quot;finally...&quot;); &#125; &#125; public static String test2() &#123; String str = null; int i = 0; i = i / 0;//抛出异常未执行到finally语句块 try &#123; System.out.println(&quot;try...&quot;); return str; &#125; finally &#123; System.out.println(&quot;finally...&quot;); &#125; &#125; public static String test3() &#123; String str = null; try &#123; System.out.println(&quot;try...&quot;); System.exit(0);//系统退出未执行到finally语句块 return str; &#125; finally &#123; System.out.println(&quot;finally...&quot;); &#125; &#125;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt;final与static的区别 Java基础 &lt;ul&gt; &lt;li&gt;都可以修饰类、方法、成员变量。&lt;/li&gt; &lt;li&gt;都不能用于修饰构造方法。&lt;/li&gt; &lt;li&gt;static 可以修饰类的代码块，final 不可以。&lt;/li&gt; &lt;li&gt;static 不可以修饰方法内的局部变量，final 可以。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;static：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;static 修饰表示静态或全局，被修饰的属性和方法属于类，可以用类名.静态属性 / 方法名 访问&lt;/li&gt; &lt;li&gt;static 修饰的代码块表示静态代码块，当 Java 虚拟机（JVM）加载类时，就会执行该代码块,只会被执行一次&lt;/li&gt; &lt;li&gt;static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，只会被创建一次&lt;/li&gt; &lt;li&gt;static 修饰的变量可以重新赋值&lt;/li&gt; &lt;li&gt;static 方法中不能用 this 和 super 关键字&lt;/li&gt; &lt;li&gt;static 方法必须被实现，而不能是抽象的abstract&lt;/li&gt; &lt;li&gt;static 方法不能被重写&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;final：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt; &lt;ul&gt; &lt;li&gt;final 修饰表示常量、一旦创建不可改变&lt;/li&gt; &lt;li&gt;final 标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可以重新赋值&lt;/li&gt; &lt;li&gt;final 方法不能被子类重写&lt;/li&gt; &lt;li&gt;final 类不能被继承，没有子类，final 类中的方法默认是 final 的&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;final 和 static 修饰成员变量加载过程例子&lt;/p&gt; &lt;pre&gt; &lt;code &gt;import java.util.Random; public class TestStaticFinal &#123; public static void main(String[] args) &#123; StaticFinal sf1 = new StaticFinal(); StaticFinal sf2 = new StaticFinal(); System.out.println(sf1.fValue == sf2.fValue);//打印false System.out.println(sf1.sValue == sf2.sValue);//打印true &#125; &#125; class StaticFinal &#123; final int fValue = new Random().nextInt(); static int sValue = new Random().nextInt(); &#125;&lt;/code&gt;&lt;/pre&gt;","categories":[{"name":"资料整理","slug":"资料整理","permalink":"https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"}],"tags":[{"name":"Anki","slug":"Anki","permalink":"https://gitflhub.github.io/tags/Anki/"}]},{"title":"Markdown 公式编辑","slug":"Markdown-公式编辑","date":"2021-05-26T14:39:50.928Z","updated":"2021-05-26T16:00:57.823Z","comments":true,"path":"2021/05/26/Markdown-公式编辑/","link":"","permalink":"https://gitflhub.github.io/2021/05/26/Markdown-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/","excerpt":"","text":"行内公式是在公式代码块的基础上前面加上$ ，后面加上$ 组成的，而行间公式则是在公式代码块前后使用$$ 和$$ 。 1.1 行内公式行内公式：$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $ 效果： $\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $ 1.2 行间公式行间公式：$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$ 效果： \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.2. 希腊字母 名称 大写 code 小写 code alpha A A α \\alpha beta B B β \\beta gamma Γ \\Gamma γ \\gamma delta Δ \\Delta δ \\delta epsilon E E ϵ \\epsilon zeta Z Z ζ \\zeta eta H H η \\eta theta Θ \\Theta θ \\theta iota I I ι \\iota kappa K K κ \\kappa lambda Λ \\Lambda λ \\lambda mu M M μ \\mu nu N N ν \\nu xi Ξ \\Xi ξ \\xi omicron O O ο \\omicron pi Π \\Pi π \\pi rho P P ρ \\rho sigma Σ \\Sigma σ \\sigma tau T T τ \\tau upsilon Υ υ υ \\upsilon phi Φ \\Phi ϕ \\phi chi X X χ \\chi psi Ψ \\Psi ψ \\psi omega Ω \\Omega ω \\omega 3. 上下标上标 $x^2$ : $x^2$ 下标$x_1$ : $x_1$ 组合$x^2_1$ : $x^2_1$ 注意：例如$x{12}$源码为： $x{12}$。注意其中的中括号{} 多级上标${x^5}^6$：需要用中括号{}划分界限${x\\^5}\\^6$, $x\\^{5\\^6}$ 两种方式均可以 4. 括号4.1 小括号与方括号使用原始的( ) ，[ ] 即可 如(2+3)[4+4]：$(2+3)[4+3]$ 复杂例子： $(\\frac{x}{y})$： 可表示为\\left(\\frac{x}{y}\\right) 或(\\frac{x}{y}) 4.2 大括号由于大括号&#123;&#125; 被用于分组，因此需要使用\\&#123;和\\&#125;表示大括号，也可以使用\\lbrace 和\\rbrace来表示。 如\\{a*b\\}:a∗b 或\\lbrace a*b\\rbrace :a*b表示：${a*b}:a∗b$ 4.3 尖括号 区分于小于号和大于号，使用\\langle 和\\rangle 表示左尖括号和右尖括号。如\\langle x \\rangle 表示：$\\langle x \\rangle$。 5. 求和与积分5.1 求和\\sum 用来表示求和符号，其下标表示求和下限，上标表示上限。 如:\\sum_{r=1}^n表示：$\\sum_{r=1}^n$ 5.2 积分\\int 用来表示积分符号，同样地，其上下标表示积分的上下限。如，\\int_{r=1}^\\infty表示：$\\int_{r=1}^\\infty$ 多重积分同样使用 int ，通过 i 的数量表示积分导数： \\iint表示： $\\iint$， \\iint\\表示： $\\iiint$， \\iiiint表示： $\\iiiint$， 5.3 连乘\\prod &#123;a+b&#125;，输出：$\\prod {a+b}$ \\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)，输出：$\\prod_{i=1}^{k}({a+b})$ \\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)，输出\\prod_{i=1}^{k}({a+b}) 5.4 其他类似\\prod : $\\prod$ \\bigcup : $\\bigcup$ \\bigcap : $\\bigcap$ \\arg\\,\\\\max_&#123;c_k&#125; : $arg\\, \\max{c_k}$ 6. 分式与根式6.1 分式第一种，使用\\frac ab，\\frac作用于其后的两个组a ，b ，结果为 $\\frac ab$ 如果你的分子或分母不是单个字符，请使用&#123;..&#125;来分组，比如\\frac &#123;a+c+1&#125;&#123;b+c+2&#125;表示：$\\frac {a+c+1}{b+c+2}$ 第二种，使用\\over来分隔一个组的前后两部分，如&#123;a+1\\over b+1&#125;：${a+1\\over b+1}$ 6.2 连分式书写连分数表达式时，请使用\\cfrac代替\\frac或者\\over两者效果对比如下：\\frac 表示如下： x=a_0 + \\frac &#123;1^2&#125;&#123;a_1 + \\frac &#123;2^2&#125;&#123;a_2 + \\frac &#123;3^2&#125;&#123;a_3 + \\frac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125; x=a_0 + \\frac {1^2}{a_1 + \\frac {2^2}{a_2 + \\frac {3^2}{a_3 + \\frac {4^2}{a_4 + ...}}}}\\cfrac 表示如下：x=a_0 + \\cfrac &#123;1^2&#125;&#123;a_1 + \\cfrac &#123;2^2&#125;&#123;a_2 + \\cfrac &#123;3^2&#125;&#123;a_3 + \\cfrac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125; x=a_0 + \\cfrac {1^2}{a_1 + \\cfrac {2^2}{a_2 + \\cfrac {3^2}{a_3 + \\cfrac {4^2}{a_4 + ...}}}}6.3 根式根式使用\\sqrt 来表示：$\\sqrt{\\pi}$ 如开4次方：\\sqrt[4]&#123;\\frac xy&#125;:$\\sqrt[4]{\\frac xy}$ 开平方：\\sqrt &#123;a+b&#125;：$\\sqrt {a+b}$ 7. 多行表达式7.1 分类表达式定义函数的时候经常需要分情况给出表达式，使用\\begin&#123;cases&#125;…\\end&#123;cases&#125; 。其中： 使用\\\\ 来分类 使用&amp; 指示需要对齐的位置， 使用\\ +空格表示空格。 例子 1： 1234567$$f(n)\\begin&#123;cases&#125;\\cfrac n2, &amp;if\\ n\\ is\\ even\\\\3n + 1, &amp;if\\ n\\ is\\ odd\\end&#123;cases&#125;$$ f(n) \\begin{cases} \\cfrac n2, &if\\ n\\ is\\ even\\\\ 3n + 1, &if\\ n\\ is\\ odd \\end{cases}例子 2： 1234567$$L(Y,f(X)) =\\begin&#123;cases&#125;0, &amp; \\text&#123;Y = f(X)&#125; \\\\1, &amp; \\text&#123;Y $\\neq$ f(X)&#125;\\end&#123;cases&#125;$$ L(Y, f(X)) = \\begin{cases} 0, & \\text{Y = f(X)}\\\\ 1, & \\text{Y $\\neq$ f(X)} \\end{cases}7.2 多行表达式有时候需要将一行公式分多行进行显示。 12345678$$\\begin&#123;equation&#125;\\begin&#123;split&#125; a&amp;=b+c-d \\\\ &amp;\\quad +e-f\\\\ &amp;=g+h\\\\ &amp; =i \\end&#123;split&#125;\\end&#123;equation&#125;$$ \\begin{equation} \\begin{split} a&=b+c -d\\\\ &\\quad +e-f\\\\ &=g+h\\\\ &=i \\end{split} \\end{equation} 其中begin{equation} 表示开始方程，end{equation} 表示方程结束；begin{split} 表示开始多行公式，end{split} 表示结束；公式中用\\ 表示回车到下一行，&amp; 表示对齐的位置。 7.3 方程组使用\\begin&#123;array&#125;...\\end&#123;array&#125; 与\\left \\&#123; 与\\right. 配合表示方程组: 123456789$$\\left \\&#123; \\begin&#123;array&#125;&#123;c&#125;a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3\\end&#123;array&#125;\\right.$$ \\left \\{ \\begin{array}{c} a_1x+b_1y+c_1z=d_1\\\\ a_2x+b_2y+c_2z=d_2\\\\ a_3x+b_3y+c_3z=d_3\\\\ \\end{array} \\right.8. 特殊函数与符号8.1 三角函数\\sin(x): $\\sin(x)$ \\arctan(x): $arctan(x)$ 8.2 比较运算符小于(\\lt )：$\\lt$ 大于(\\gt )：$\\gt$ 小于等于(\\le )：$\\le$ 大于等于(\\ge )：$\\ge$ 不等于(\\ne ) :$\\ne$ 可以在这些运算符前面加上\\not ，如\\not\\lt :$\\not \\lt$ 8.3 集合运算符并集(\\cup ): $\\cup$交集(\\cap ): $\\cap$差集(\\setminus ): $\\setminus$子集(\\subset ): $\\subset$真子集(\\subseteq ): $\\subseteq$非子集(\\subsetneq ): $\\subsetneq$父集(\\supset ): $\\supset$属于(\\in ): $\\in$不属于(\\notin ): $\\notin$空集(\\emptyset ): $\\emptyset$空(\\varnothing): $\\varnothing$ 8.4 排列\\binom&#123;n+1&#125;&#123;2k&#125;:$\\binom{n+1}{2k}$ &#123;n+1 \\choose 2k&#125;: ${n+1 \\choose 2k}$ 8.5 箭头\\to: $\\to$\\rightarrow: $\\rightarrow$\\leftarrow: $\\leftarrow$\\Rightarrow: $\\Rightarrow$\\Leftarrow: $\\Leftarrow$\\mapsto: $\\mapsto$ 8.6 逻辑运算符\\land:$\\land$\\lor: $\\lor$\\lnot: $\\lnot$\\forall: $\\forall$\\exists: $\\exists$\\top: $\\top$\\bot: $\\bot$\\vdash: $\\vdash$\\vDash: $\\vDash$ 8.7 模运算 \\mod 6: $\\mod 6$ 如a \\equiv b \\mod n : $a \\equiv b \\mod n$ 8.8 点\\ldots: $\\ldots$\\cdots: $\\cdots$\\cdot: $\\cdot$ 其区别是点的位置不同，\\ldots 位置稍低，\\cdots 位置居中。 123456$$\\begin&#123;equation&#125;a_1+a_2+\\ldots+a_n \\\\ a_1+a_2+\\cdots+a_n\\end&#123;equation&#125;$$ 表示： \\begin{equation} a_1+a_2+\\ldots+a_n\\\\ a_1+a_2+\\cdots+a_n\\\\ \\end{equation}9. 顶部符号对于单字符，\\hat x ：$\\hat x$多字符可以使用\\widehat &#123;xy&#125; ：$\\widehat {xy}$类似的还有:\\overline x : $\\overline x$矢量(\\vec x ): $\\vec x$向量(\\overrightarrow &#123;xy&#125; ): $\\overrightarrow {xy}$(\\dot x ): $\\dot x$(\\ddot x ): $\\ddot x$(\\dot &#123;\\dot x&#125; ): $\\dot {\\dot x}$ 10. 表格使用\\begin&#123;array&#125;&#123;列样式&#125;…\\end&#123;array&#125; 这样的形式来创建表格，列样式可以是clr 表示居中，左，右对齐，还可以使用| 表示一条竖线。表格中各行使用\\\\ 分隔，各列使用&amp; 分隔。使用\\hline 在本行前加入一条直线。 例如: 123456789$$\\begin&#123;array&#125;&#123;c|lcr&#125;n &amp; \\text&#123;Left&#125; &amp; \\text&#123;Center&#125; &amp; \\text&#123;Right&#125; \\\\\\hline1 &amp; 0.24 &amp; 1 &amp; 125 \\\\2 &amp; -1 &amp; 189 &amp; -8 \\\\3 &amp; -20 &amp; 2000 &amp; 1+10i \\\\\\end&#123;array&#125;$$ \\begin{array}{c|lcr} n & \\text{Left} & \\text{Center} & \\text{Right} \\\\ \\hline 1 & 0.24 & 1 & 125 \\\\ 2 & -1 & 189 & -8 \\\\ 3 & -20 & 2000 & 1+10i \\\\ \\end{array}11. 矩阵11.1 基本内容使用\\begin&#123;matrix&#125;…\\end&#123;matrix&#125; 这样的形式来表示矩阵，在\\begin 与\\end 之间加入矩阵中的元素即可。矩阵的行之间使用\\\\ 分隔，列之间使用&amp; 分隔，例如: 1234567$$\\begin&#123;matrix&#125;1 &amp; x &amp; x^2 \\\\1 &amp; y &amp; y^2 \\\\1 &amp; z &amp; z^2 \\\\\\end&#123;matrix&#125;$$ \\begin{matrix} 1 & x & x^2 \\\\ 1 & y & y^2 \\\\ 1 & z & z^2 \\\\ \\end{matrix}11.2 括号如果要对矩阵加括号，可以像上文中提到的一样，使用\\left 与\\right 配合表示括号符号。也可以使用特殊的matrix 。即替换\\begin&#123;matrix&#125;…\\end&#123;matrix&#125; 中matrix 为pmatrix ，bmatrix ，Bmatrix ，vmatrix , Vmatrix 。 pmatrix\\begin&#123;pmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;pmatrix&#125; : \\begin{pmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{pmatrix} bmatrix\\begin&#123;bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;bmatrix&#125; : \\begin{bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{bmatrix} Bmatrix\\begin&#123;Bmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Bmatrix&#125; : \\begin{Bmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Bmatrix} vmatrix\\begin&#123;vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;vmatrix&#125; : \\begin{vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{vmatrix} Vmatrix\\begin&#123;Vmatrix&#125;1 &amp; 2 \\\\ 3 &amp; 4\\\\ \\end&#123;Vmatrix&#125; : \\begin{Vmatrix}1 & 2 \\\\ 3 & 4\\\\ \\end{Vmatrix} 元素省略 可以使用\\cdots ：⋯，\\ddots：⋱ ，\\vdots：⋮ 来省略矩阵中的元素，如： 12345678$$\\begin&#123;pmatrix&#125;1&amp;a_1&amp;a_1^2&amp;\\cdots&amp;a_1^n\\\\1&amp;a_2&amp;a_2^2&amp;\\cdots&amp;a_2^n\\\\\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots&amp;\\vdots\\\\1&amp;a_m&amp;a_m^2&amp;\\cdots&amp;a_m^n\\\\\\end&#123;pmatrix&#125;$$ 表示： \\begin{pmatrix} 1&a_1&a_1^2&\\cdots&a_1^n\\\\ 1&a_2&a_2^2&\\cdots&a_2^n\\\\ \\vdots&\\vdots&\\vdots&\\ddots&\\vdots\\\\ 1&a_m&a_m^2&\\cdots&a_m^n\\\\ \\end{pmatrix}增广矩阵 增广矩阵需要使用前面的表格中使用到的\\begin&#123;array&#125; ... \\end&#123;array&#125; 来实现。 1234567$$\\left[ \\begin&#123;array&#125; &#123;c c | c&#125; %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6\\end&#123;array&#125; \\right]$$ 显示为： \\left[ \\begin{array} {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线 1 & 2 & 3 \\\\ 4 & 5 & 6 \\end{array} \\right]12. 公式标记与引用 使用\\tag&#123;yourtag&#125; 来标记公式，如果想在之后引用该公式，则还需要加上\\label&#123;yourlabel&#125; 在\\tag 之后，如a = x^2 - y^3 \\tag&#123;1&#125;\\label&#123;1&#125; 显示为： a = x^2 - y^3 \\tag{12.1} 如果不需要被引用，只使用\\tag&#123;yourtag&#125; ，x+y=z\\tag&#123;1.1&#125;显示为： x+y=z\\tag{12.2} \\tab&#123;yourtab&#125; 中的内容用于显示公式后面的标记。公式之间通过\\label&#123;&#125; 设置的内容来引用。为了引用公式，可以使用\\eqref&#123;yourlabel&#125; ，如a + y^3 \\stackrel&#123;\\eqref&#123;1&#125;&#125;= x^2 显示为： a + y^3 \\stackrel{\\eqref{1}}= x^2或者使用\\ref&#123;yourlabel&#125; 不带括号引用，如a + y^3 \\stackrel&#123;\\ref&#123;111&#125;&#125;= x^2 显示为： a + y^3 \\stackrel{\\ref{111}}= x^213. 字体黑板粗体字此字体经常用来表示代表实数、整数、有理数、复数的大写字母。 \\mathbb ABCDEF： \\Bbb ABCDEF： 黑体字\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ : $\\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$\\mathbf abcdefghijklmnopqrstuvwxyz :$\\mathbf abcdefghijklmnopqrstuvwxyz$ 打印机字体\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ : $\\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$","categories":[{"name":"语言","slug":"语言","permalink":"https://gitflhub.github.io/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"LaTex","slug":"LaTex","permalink":"https://gitflhub.github.io/tags/LaTex/"},{"name":"数学公式","slug":"数学公式","permalink":"https://gitflhub.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"}]}],"categories":[{"name":"AI","slug":"AI","permalink":"https://gitflhub.github.io/categories/AI/"},{"name":"算法","slug":"算法","permalink":"https://gitflhub.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://gitflhub.github.io/categories/Java/"},{"name":"资料整理","slug":"资料整理","permalink":"https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"name":"语言","slug":"语言","permalink":"https://gitflhub.github.io/categories/%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Octave","slug":"Octave","permalink":"https://gitflhub.github.io/tags/Octave/"},{"name":"工具","slug":"工具","permalink":"https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://gitflhub.github.io/tags/Machine-Learning/"},{"name":"排序","slug":"排序","permalink":"https://gitflhub.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"虚拟机","slug":"虚拟机","permalink":"https://gitflhub.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"Java 注解","slug":"Java-注解","permalink":"https://gitflhub.github.io/tags/Java-%E6%B3%A8%E8%A7%A3/"},{"name":"Bean","slug":"Bean","permalink":"https://gitflhub.github.io/tags/Bean/"},{"name":"Spring","slug":"Spring","permalink":"https://gitflhub.github.io/tags/Spring/"},{"name":"AOP","slug":"AOP","permalink":"https://gitflhub.github.io/tags/AOP/"},{"name":"锁","slug":"锁","permalink":"https://gitflhub.github.io/tags/%E9%94%81/"},{"name":"JVM","slug":"JVM","permalink":"https://gitflhub.github.io/tags/JVM/"},{"name":"Anki","slug":"Anki","permalink":"https://gitflhub.github.io/tags/Anki/"},{"name":"LaTex","slug":"LaTex","permalink":"https://gitflhub.github.io/tags/LaTex/"},{"name":"数学公式","slug":"数学公式","permalink":"https://gitflhub.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"}]}