<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RON BLOG</title>
  
  <subtitle>Ron, open the door.</subtitle>
  <link href="https://gitflhub.github.io/atom.xml" rel="self"/>
  
  <link href="https://gitflhub.github.io/"/>
  <updated>2022-03-03T05:48:53.609Z</updated>
  <id>https://gitflhub.github.io/</id>
  
  <author>
    <name>Ron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://gitflhub.github.io/2022/03/03/End-to-End%20Structure-Aware%20Convolutional%20Networks%20for%20Knowledge%20Base%20Completion/"/>
    <id>https://gitflhub.github.io/2022/03/03/End-to-End%20Structure-Aware%20Convolutional%20Networks%20for%20Knowledge%20Base%20Completion/</id>
    <published>2022-03-03T05:01:42.000Z</published>
    <updated>2022-03-03T05:48:53.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SACN"><a href="#SACN" class="headerlink" title="SACN"></a>SACN</h1><h2 id="End-to-End-Structure-Aware-Convolutional-Networks-for-Knowledge-Base-Completion"><a href="#End-to-End-Structure-Aware-Convolutional-Networks-for-Knowledge-Base-Completion" class="headerlink" title="End-to-End Structure-Aware Convolutional Networks for Knowledge Base Completion"></a>End-to-End Structure-Aware Convolutional Networks for Knowledge Base Completion</h2><h2 id="基于端到端结构感知卷积神经网络的知识构建"><a href="#基于端到端结构感知卷积神经网络的知识构建" class="headerlink" title="基于端到端结构感知卷积神经网络的知识构建"></a>基于端到端结构感知卷积神经网络的知识构建</h2><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><p>Structure-Aware Convolutional Network (SACN)</p><p>将GCN和ConvE结合</p><h2 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h2><p>加权图卷积网络 Weighted graph convolutional network (<a href="##WGCN">WGCN</a>)</p><p>WGCN 利用了图结构的节点信息和关系信息。图节点的权重可调（<strong>节点值？边值？</strong>），可以适应本地聚合中使用的来自邻居的信息量。</p><p>通过聚合的实体来表示实体（？）</p><h2 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h2><p>Conv-TransE (在之前的论文里，提到)</p><p>通过恢复原始的三元组来表示关系（？）</p><h2 id="Encoder-和-Decoder"><a href="#Encoder-和-Decoder" class="headerlink" title="Encoder 和 Decoder"></a>Encoder 和 Decoder</h2><p>编码器和解码器都通过 减小交叉熵误差 进行联合训练</p><h2 id="WGCN"><a href="#WGCN" class="headerlink" title="WGCN"></a>WGCN</h2><p>GCN的扩展，在聚合时，对不同类型的关系进行不同的加权。</p><p>WGCN将<strong>多关系</strong>KB图视为多个<strong>单关系子图</strong>，其中每个子图都包含特定类型的关系。WGCN确定在组合节点的GCN嵌入时给每个子图赋予不同的权重。</p><h1 id="WGCN-1"><a href="#WGCN-1" class="headerlink" title="WGCN"></a>WGCN</h1><h2 id="WGCN-Graph-Convolutional-Networks-with-Weighted-Structural-Features"><a href="#WGCN-Graph-Convolutional-Networks-with-Weighted-Structural-Features" class="headerlink" title="WGCN: Graph Convolutional Networks with Weighted Structural Features"></a>WGCN: Graph Convolutional Networks with Weighted Structural Features</h2><h2 id="具有加权结构特征的图卷积网络"><a href="#具有加权结构特征的图卷积网络" class="headerlink" title="具有加权结构特征的图卷积网络"></a>具有加权结构特征的图卷积网络</h2><p>通过图的连通性和拓扑性的信息,可以调整学习节点的表示.</p><p>针对已有的模型来考虑解决问题</p><ol><li>采用平均权重的方式</li><li>采用局部区分内外邻居的方式</li><li>没有考虑到局部拓扑的因素</li></ol><p>提出了一种 <strong>加权结构特征的图卷积网络</strong></p><p><strong>思路</strong>：</p><ol><li>WGCN 首先收集结构信息（有向边的方向和度数（出入度）感知的<strong><em>随机游走算法</em>？重启算法？</strong>）</li><li>前置过程的交互信息被作为节点的结构特征，进一步获取节点间的依赖和拓扑信息。</li></ol><p>其他模型：</p><ol><li>聚合节点的图内容和结构</li><li>GAT 采用注意力机制只考虑内容的相似性，没有考虑到拓扑结构的相似性</li><li>将边视为双向边，在获取节点的结构信息的时候，节点的权值与方向无关（会忽略不可逆转的信息，如时间序列想）。</li><li>区分方向结构使用单挑赋权参数的方式。（不能获取节点的密度，或者区分节点的几何重构关系）</li><li>GCN 不能获取到长依赖，<strong><em>GCN不能区分非同构图？</em></strong></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SACN&quot;&gt;&lt;a href=&quot;#SACN&quot; class=&quot;headerlink&quot; title=&quot;SACN&quot;&gt;&lt;/a&gt;SACN&lt;/h1&gt;&lt;h2 id=&quot;End-to-End-Structure-Aware-Convolutional-Networks-for-Kno</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Machine Learning" scheme="https://gitflhub.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SMO 的计算过程</title>
    <link href="https://gitflhub.github.io/2021/11/04/SMO%20%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/"/>
    <id>https://gitflhub.github.io/2021/11/04/SMO%20%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</id>
    <published>2021-11-04T08:49:50.000Z</published>
    <updated>2021-11-04T09:01:04.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SMO-的定义"><a href="#SMO-的定义" class="headerlink" title="SMO 的定义"></a>SMO 的定义</h3><p>SMO的思想类似坐标上升算法，我们需要优化一系列的αα的值，我们每次选择尽量少的$\alpha$  来优化，不断迭代直到函数收敛到最优值。</p><p>来到SVM的对偶问题上，对偶形式:</p><script type="math/tex; mode=display">arg \max \limits_{\alpha} \sum_{i=1}^{N} \alpha_{i} - \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}y_{i}y_{j}\alpha_{i}\alpha_{j}\langle x_{i}, x_{j} \rangle</script><p>subject to $\alpha<em>{i} \ge 0$ , $\sum</em>{i=1}^{N}\alpha<em>{i}y</em>{i}=0$</p><p>其中我们需要对$(\alpha<em>{1}, \alpha</em>{2}, …, \alpha_{N})$ 进行优化，但是这个凸二次优化问题的其他求解算法的复杂度很高，但是Platt提出的SMO算法可以高效的求解上述对偶问题，他把原始问题的求解$N$  个参数二次规划问题分解成多个二次规划问题求解，每个字问题只需要求解2各参数，节省了时间成本和内存需求。</p><p>与坐标上升算法不同的是，我们在SMO算法中我们每次需要选择<strong>一对</strong>变量 $(\alpha_i, \alpha_j)$ , 因为在SVM中，我们的 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="\alpha"> 并不是完全独立的，而是具有约束的:</p><script type="math/tex; mode=display">\sum_{i=1}^{N}\alpha_{i}y_{i} = 0</script><p>因此一个 $\alpha$ 改变，另一个也要随之变化以满足条件。</p><h3 id="SMO-的计算过程"><a href="#SMO-的计算过程" class="headerlink" title="SMO 的计算过程"></a>SMO 的计算过程</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>对以下数据点，求出其最优的超平面</p><script type="math/tex; mode=display">x_1=(1,2,3),y_1=+1\\x_2=(4,1,2),y_1=+1\\x_3=(-1,2,1),y_1=-1</script><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><p>构建训练集约束最优化问题：</p><script type="math/tex; mode=display">\begin{align}&\mathop{max}_{\lambda}(-\frac{1}{2}\sum_{i=0}^{n}\sum_{j=0}^{n}\lambda_{i}\lambda_{j}y_{i}y_{j}(x_{i},x_{j}) + \sum_{i=0}^{n}\lambda_{i})\\=&\mathop{min}_{\lambda}(\frac{1}{2}\sum_{i=0}^{n}\sum_{j=0}^{n}\lambda_{i}\lambda_{j}y_{i}y_{j}(x_{i},x_{j}) - \sum_{i=0}^{n}\lambda_{i})\\\end{align}</script><p>令</p><script type="math/tex; mode=display">\begin{align}&L(\lambda_1,\lambda_2,\lambda_3)\\=&\frac{1}{2}(\lambda_{1}\lambda_{1}(1*1)(x_{11}^{2}+x_{12}^{2}+x_{13}^{2})+\lambda_{1}\lambda_{2}(1*1)(x_{11}*x_{21}+x_{12}*x_{22}+x_{13}*x_{23})\\&+\lambda_{1}\lambda_{3}(1*-1)(x_{11}*x_{31}+x_{12}*x_{32}+x_{13}*x_{33})+\lambda_{2}\lambda_{1}(1*1)(x_{21}*x_{11}+x_{22}*x_{12}+x_{23}*x_{13})\\&+\lambda_{2}\lambda_{2}(1*1)(x_{21}^{2}+x_{22}^{2}+x_{23}^{2})+\lambda_{2}\lambda_{3}(1*-1)(x_{21}*x_{31}+x_{22}*x_{32}+x_{23}*x_{33})\\&+\lambda_{3}\lambda_{1}(1*-1)(x_{31}*x_{11}+x_{32}*x_{12}+x_{33}*x_{13})+\lambda_{3}\lambda_{2}(1*-1)(x_{31}*x_{21}+x_{32}*x_{22}+x_{33}*x_{23})\\&+\lambda_{3}\lambda_{3}(-1*-1)(x_{31}^{2}+x_{32}^{2}+x_{33}^{2})- \sum_{i=0}^{n}\lambda_{i}\\=&\frac{1}{2}(14\lambda_{1}^2+24\lambda_{1}\lambda_{2}+21\lambda_{2}^2+8\lambda_{2}\lambda_{3}+6\lambda_{3}^2)-\sum_{i=0}^{n}\lambda_{i}\\\end{align}</script><p>其中 </p><script type="math/tex; mode=display">1*\lambda_1 + 1 * \lambda_2-1*\lambda_3=0</script><p>所以 </p><script type="math/tex; mode=display">\lambda_3=\lambda_1+\lambda_2</script><p>代入上式得</p><script type="math/tex; mode=display">L(\lambda_1,\lambda_2)=\frac{1}{2}(20\lambda_{1}^2+44\lambda_{1}\lambda_{2}+35\lambda_{2}^2)-2(\lambda_1+\lambda_2)</script><p>为求$L(\lambda<em>1,\lambda_2)$的最小值，分别对$\lambda</em>{1},\lambda_{2}$求偏导的：</p><script type="math/tex; mode=display">\left \{ \begin{array}{c}20\lambda_1+22\lambda_2-2=0\\22\lambda_1+35\lambda_2-2=0\end{array}\right.</script><p>解得</p><script type="math/tex; mode=display">\left \{ \begin{array}{c}\lambda_1 = \frac{49}{270}\\\lambda_2= -\frac{2}{27}\end{array}\right.</script><p>不符合$\lambda_{i}(1\leqslant i\leqslant n) &gt; 0$，考虑极值点在边缘</p><p>当$\lambda_{1}=0$时，在点$(0,  \frac{2}{35})$取得极小值$-\frac{2}{35}$</p><p>当$\lambda_{2}=0$时，在点$(\frac{1}{10},  0)$取得极小值$-\frac{1}{10}$</p><p>所以在点$(\frac{1}{10},  0)$取得最小值$-\frac{1}{10}$</p><p>所以$\lambda_1 = \frac{1}{10}, \lambda_2=0,\lambda_2=\frac{1}{10}$</p><script type="math/tex; mode=display">\begin{align}W^*&=\lambda_1 * x_1 + \lambda_2 * x_2 + \lambda_3 * x_3\\ &=(0, \frac{2}{5}, \frac{1}{5})\\b&=1-(0, \frac{2}{5}, \frac{1}{5})\odot(1,2,3)\\&=-\frac{2}{5}\end{align}</script><p>最大间隔超平面的表达式为</p><script type="math/tex; mode=display">\begin{align}y&=W^*(x_1,x_2,x_3)^T+b\\&=\frac{2}{5}x_2+\frac{1}{5}x_3-\frac{2}{5}\end{align}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SMO-的定义&quot;&gt;&lt;a href=&quot;#SMO-的定义&quot; class=&quot;headerlink&quot; title=&quot;SMO 的定义&quot;&gt;&lt;/a&gt;SMO 的定义&lt;/h3&gt;&lt;p&gt;SMO的思想类似坐标上升算法，我们需要优化一系列的αα的值，我们每次选择尽量少的$\alpha$  </summary>
      
    
    
    
    
    <category term="SMO" scheme="https://gitflhub.github.io/tags/SMO/"/>
    
    <category term="SVM" scheme="https://gitflhub.github.io/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>Transformer 的 Position Embedding 理解</title>
    <link href="https://gitflhub.github.io/2021/10/21/Transformer%20%E7%9A%84%20Position%20Embedding%20%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://gitflhub.github.io/2021/10/21/Transformer%20%E7%9A%84%20Position%20Embedding%20%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-21T00:20:48.000Z</published>
    <updated>2021-10-21T04:04:43.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>视频：Bilibili:<a href="https://www.bilibili.com/video/BV1ff4y1a7VL?from=search&amp;seid=16603844718264150058&amp;spm_id_from=333.337.0.0">Transformer的位置编码（Position Encoding）进展梳理_哔哩哔哩_bilibili</a></p><p>笔记：<a href="https://ml-researcher.github.io/file/PosEnc.pdf">PosEnc</a></p><h3 id="模型示例"><a href="#模型示例" class="headerlink" title="模型示例:"></a>模型示例:</h3><p><img src="https://img.ron.zone/image-20211014193447739.png" alt="image-20211014193447739"></p><h3 id="位置编码公式："><a href="#位置编码公式：" class="headerlink" title="位置编码公式："></a>位置编码公式：</h3><script type="math/tex; mode=display">PE_{(k, 2i)} = \sin(k/10000^{\frac{2i}{d_{model}}})\\PE_{(k, 2i + 1)} = \cos(k/10000^{\frac{2i}{d_{model}}})\\k :{元素在序列中位置} \\i:{用于表示列数}\\d_{model}:模型的维数</script><h3 id="公式理解"><a href="#公式理解" class="headerlink" title="公式理解:"></a>公式理解:</h3><p>在Transformer中，输入Encoder或者Decoder中的向量为 Embedding Vector + Position Embedding Vector。</p><p>将 Embedding Vector 和 Position Embedding Vector 分别表示为$e_i$和$p_i$。</p><p>后续的计算过程可以视为</p><script type="math/tex; mode=display">\begin{equation}\begin{split} (e_i + p_i)^TW_Q^TW_k(e_j+p_j)&=e_i^TW_Q^TW_ke_j+p_i^TW_Q^TW_ke_j\\&+e_i^TW_Q^TW_kp_j+p_i^TW_Q^TW_kp_j\end{split}\end{equation}</script><p>$e_i^TW_Q^TW_ke_j$ 是表示词向量之间的运算</p><p>$p_i^TW_Q^TW_ke_j$ 和$e_i^TW_Q^TW_kp_j$分别包含了两个词向量的绝对位置的信息</p><p>$p_i^TW_Q^TW_kp_j$简化看成为$p_i^Tp_j$。现在想要将其转化为和<strong>相对位置</strong>有关的向量，即$i-j$的形式</p><p>又因为</p><script type="math/tex; mode=display">\begin{equation}\begin{split}p_i^Tp_j&=(p_{i1},p_{i2},...,p_{id_{model}})^T(p_{j1},p_{j2},...,p_{jd_{model}})\\&=p_{i1}p_{j1}+p_{i2}p_{j2}+...+p_{id_{model}}p_{jd_{model}}\end{split}\end{equation}</script><p>再结合</p><script type="math/tex; mode=display">PE_{(k, 2i)} = \sin(k/10000^{\frac{2i}{d_{model}}})\\PE_{(k, 2i + 1)} = \cos(k/10000^{\frac{2i}{d_{model}}})</script><p>可以理解为</p><script type="math/tex; mode=display">\begin{equation}\begin{split}p_i^Tp_j&=(p_{i1},p_{i2},...,p_{id_{model}})^T(p_{j1},p_{j2},...,p_{jd_{model}})\\&=p_{i1}p_{j1}+p_{i2}p_{j2}+...+p_{id_{model}}p_{jd_{model}}\\&=\cos(i/10000^{\frac{2*1}{d_{model}}})\cos(j/10000^{\frac{2*1}{d_{model}}}) + \sin(i/10000^{\frac{2*1}{d_{model}}})\sin(j/10000^{\frac{2*1}{d_{model}}})+...\\&=cos((i-j)/10000^{\frac{2*1}{d_{model}}}) + cos((i-j)/10000^{\frac{2*2}{d_{model}}}) + ... + cos((i-j)/10000^{\frac{2*d_{model}/2}{d_{model}}})\\&=g(i-j)\end{split}\end{equation}</script><p>于是最终被表示成了相对位置的形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考链接：&quot;&gt;&lt;a href=&quot;#参考链接：&quot; class=&quot;headerlink&quot; title=&quot;参考链接：&quot;&gt;&lt;/a&gt;参考链接：&lt;/h3&gt;&lt;p&gt;视频：Bilibili:&lt;a href=&quot;https://www.bilibili.com/video/BV1ff4</summary>
      
    
    
    
    
    <category term="NLP" scheme="https://gitflhub.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>PCA</title>
    <link href="https://gitflhub.github.io/2021/09/14/PCA/"/>
    <id>https://gitflhub.github.io/2021/09/14/PCA/</id>
    <published>2021-09-14T12:22:08.000Z</published>
    <updated>2021-09-14T12:25:49.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pca</span>(<span class="params">X, n_components=<span class="number">2</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        X: of dimension (m,n) where each row corresponds to a word vector</span></span><br><span class="line"><span class="string">        n_components: Number of components you want to keep.</span></span><br><span class="line"><span class="string">    Output:</span></span><br><span class="line"><span class="string">        X_reduced: data transformed in 2 dims/columns + regenerated original data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">### START CODE HERE (REPLACE INSTANCES OF &#x27;None&#x27; with your code) ###</span></span><br><span class="line">    <span class="comment"># mean center the data</span></span><br><span class="line">    X_demeaned = X- np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># calculate the covariance matrix</span></span><br><span class="line">    covariance_matrix = np.cov(X_demeaned, rowvar=<span class="literal">False</span>) <span class="comment"># 计算协方差采用的是去平均值矩阵，还要添加rowvar参数</span></span><br><span class="line">    <span class="comment"># calculate eigenvectors &amp; eigenvalues of the covariance matrix</span></span><br><span class="line">    eigen_vals, eigen_vecs = np.linalg.eigh(covariance_matrix)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># sort eigenvalue in increasing order (get the indices from the sort)</span></span><br><span class="line">    idx_sorted = np.argsort(eigen_vals)</span><br><span class="line">    <span class="comment"># reverse the order so that it&#x27;s from highest to lowest.</span></span><br><span class="line">    idx_sorted_decreasing = np.argsort(-eigen_vals)</span><br><span class="line">    <span class="comment"># sort the eigen values by idx_sorted_decreasing</span></span><br><span class="line">    eigen_vals_sorted = eigen_vals[idx_sorted_decreasing]</span><br><span class="line">    <span class="comment"># sort eigenvectors using the idx_sorted_decreasing indices</span></span><br><span class="line">    eigen_vecs_sorted = eigen_vecs[:,idx_sorted_decreasing] <span class="comment"># 选取特征向量的时候注意要采用matrix[:,排序索引] 不可采用 matrix[排序索引] 因为调整的是列向量的顺序</span></span><br><span class="line">    <span class="comment"># select the first n eigenvectors (n is desired dimension</span></span><br><span class="line">    <span class="comment"># of rescaled data array, or dims_rescaled_data)</span></span><br><span class="line">    eigen_vecs_subset = eigen_vecs_sorted[:,<span class="number">0</span>:n_components]</span><br><span class="line">    <span class="comment"># transform the data by multiplying the transpose of the eigenvectors </span></span><br><span class="line">    <span class="comment"># with the transpose of the de-meaned data</span></span><br><span class="line">    <span class="comment"># Then take the transpose of that product.</span></span><br><span class="line">    X_reduced = np.dot(X_demeaned, eigen_vecs_subset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X_reduced</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PCA&quot;&gt;&lt;a href=&quot;#PCA&quot; class=&quot;headerlink&quot; title=&quot;PCA&quot;&gt;&lt;/a&gt;PCA&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="categories" scheme="https://gitflhub.github.io/categories/categories/"/>
    
    
    <category term="机器学习" scheme="https://gitflhub.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="PCA" scheme="https://gitflhub.github.io/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>Anki 常用插件</title>
    <link href="https://gitflhub.github.io/2021/07/06/Anki%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://gitflhub.github.io/2021/07/06/Anki%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2021-07-06T02:44:21.000Z</published>
    <updated>2021-07-06T03:06:58.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anki-插件推荐"><a href="#Anki-插件推荐" class="headerlink" title="Anki 插件推荐"></a>Anki 插件推荐</h2><div class="table-container"><table><thead><tr><th>Anki 插件名称</th><th>插件介绍</th><th>插件ID</th></tr></thead><tbody><tr><td>AnkiConnect</td><td>实现 Anki 与外界通信</td><td>2055492159</td></tr><tr><td>Enhance main window</td><td>增强主页</td><td>877182321</td></tr><tr><td>Review Heatmap</td><td>复习热力图，记录学习日历</td><td>1771074083</td></tr><tr><td>Evernote Importer</td><td>支持印象笔记</td><td>831016260</td></tr><tr><td>Markdown and KaTeX Support</td><td>支持 MarkDown 和数学公式</td><td>1087328706</td></tr><tr><td>Word Query</td><td>(查询大卡片单词词义音标等)</td><td>775418273</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Anki-插件推荐&quot;&gt;&lt;a href=&quot;#Anki-插件推荐&quot; class=&quot;headerlink&quot; title=&quot;Anki 插件推荐&quot;&gt;&lt;/a&gt;Anki 插件推荐&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;</summary>
      
    
    
    
    <category term="资料整理" scheme="https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Anki" scheme="https://gitflhub.github.io/tags/Anki/"/>
    
    <category term="浏览器插件" scheme="https://gitflhub.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>开源数据集</title>
    <link href="https://gitflhub.github.io/2021/07/05/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://gitflhub.github.io/2021/07/05/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2021-07-05T13:49:03.000Z</published>
    <updated>2021-07-06T00:49:20.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开放数据集"><a href="#开放数据集" class="headerlink" title="开放数据集"></a>开放数据集</h2><p>•     DataHub (<a href="http://datahub.io/dataset">http://datahub.io/dataset</a>)<br>•     World Health Organization (<a href="http://www.who.int/research/en/">http://www.who.int/research/en/</a>)<br>•     Data.gov (<a href="http://data.gov">http://data.gov</a>)<br>•     European Union Open Data Portal (<a href="http://open-data.europa.eu/en/data/">http://open-data.europa.eu/en/data/</a>)<br>•     Amazon Web Service public datasets (<a href="http://aws.amazon.com/datasets">http://aws.amazon.com/datasets</a>)<br>•     Facebook Graph (<a href="http://developers.facebook.com/docs/graph-api">http://developers.facebook.com/docs/graph-api</a>)<br>•     Healthdata.gov (<a href="http://www.healthdata.gov">http://www.healthdata.gov</a>)<br>•     Google Trends (<a href="http://www.google.com/trends/explore">http://www.google.com/trends/explore</a>)<br>•     Google Finance (<a href="https://www.google.com/finance">https://www.google.com/finance</a>)<br>•     Google Books Ngrams (<a href="http://storage.googleapis.com/books/ngrams/books/datasetsv2.html">http://storage.googleapis.com/books/ngrams/books/datasetsv2.html</a>)<br>•     Machine Learning Repository (<a href="http://archive.ics.uci.edu/ml/">http://archive.ics.uci.edu/ml/</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开放数据集&quot;&gt;&lt;a href=&quot;#开放数据集&quot; class=&quot;headerlink&quot; title=&quot;开放数据集&quot;&gt;&lt;/a&gt;开放数据集&lt;/h2&gt;&lt;p&gt;•     DataHub (&lt;a href=&quot;http://datahub.io/dataset&quot;&gt;http://</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="开放数据集" scheme="https://gitflhub.github.io/tags/%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning</title>
    <link href="https://gitflhub.github.io/2021/07/05/Machine%20Learning/"/>
    <id>https://gitflhub.github.io/2021/07/05/Machine%20Learning/</id>
    <published>2021-07-05T13:01:42.000Z</published>
    <updated>2022-03-03T05:48:24.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习库"><a href="#学习库" class="headerlink" title="学习库"></a>学习库</h1><p>Numpy 科学计算库</p><p>Pandas 数据分析可视化</p><p>Matplotlib 数据可视化</p><p>Scikit-learn 机器学习库</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>数组</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>分类：最终属于1还是0</p><p>回归：最终一个具体值</p><h4 id="例子1：房价预测（回归）"><a href="#例子1：房价预测（回归）" class="headerlink" title="例子1：房价预测（回归）"></a>例子1：房价预测（回归）</h4><p><img src="http://img.ron.zone/20210527232253.png" alt="image-20210429100557314-1620280617770"></p><h4 id="例子2：肿瘤预测（分类）"><a href="#例子2：肿瘤预测（分类）" class="headerlink" title="例子2：肿瘤预测（分类）"></a>例子2：肿瘤预测（分类）</h4><p>一个属性</p><p><img src="http://img.ron.zone/20210527232327.png" alt="image-20210429100923353"></p><p>两个属性（特征）</p><p><img src="http://img.ron.zone/20210527232314.png" alt="image-20210429101713120"></p><p>无穷多特征：向量机</p><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><h5 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h5><p><img src="http://img.ron.zone/20210527232337.png" alt="image-20210429105008588"></p><p><img src="http://img.ron.zone/20210527232346.png" /></p><p><img src="http://img.ron.zone/20210527232354.png" alt="image-20210429105552665"></p><p>一个参数的代价函数可以化为一个一元二次函数</p><p>两个参数的代价函数可以化为一个二元二次函数</p><p>更多参数可以考虑梯度下降的方式</p><p><img src="http://img.ron.zone/20210527232404.png" alt="image-20210429163240652"></p><p>梯度下降需要考虑步伐大小，大小学习速率过慢，太大会错过最优解，甚至会导致发散</p><p><img src="http://img.ron.zone/20210527232414.png" alt="image-20210429164519908"></p><p>步长α是动态调整的， </p><p>梯度下降只适用于求解线性回归。（为弓形图像）</p><p><img src="http://img.ron.zone/20210527232425.png" alt="image-20210429170959267"></p><h5 id="多元梯度下降"><a href="#多元梯度下降" class="headerlink" title="多元梯度下降"></a>多元梯度下降</h5><p><img src="http://img.ron.zone/20210527232437.png" alt="image-20210430164149341"></p><h5 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h5><p><img src="http://img.ron.zone/20210527232448.png" alt="image-20210430165959029"></p><p>也可以采取减去均值再除以范围</p><p><img src="http://img.ron.zone/20210527232506.png" alt="image-20210430170710002"></p><p>特征或多项式回归</p><h5 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程<img src="http://img.ron.zone/20210527232516.png" alt="image-20210430174937134"></h5><p>如果X ^ TX是不可逆的，常见的原因可能是:</p><ul><li><p>冗余特征，即两个特征密切相关(即线性相关)</p></li><li><p>太多的特性(例如m≤n)。在这种情况下，删除一些特性或使用“正则化”</p></li></ul><h5 id="正规方程和梯度下降比较"><a href="#正规方程和梯度下降比较" class="headerlink" title="正规方程和梯度下降比较"></a>正规方程和梯度下降比较</h5><div class="table-container"><table><thead><tr><th style="text-align:left">梯度下降</th><th style="text-align:left">正规方程需要</th></tr></thead><tbody><tr><td style="text-align:left">需要选择确定学习速率α</td><td style="text-align:left">不需要选择确定学习速率α</td></tr><tr><td style="text-align:left">需要多次迭代</td><td style="text-align:left">不需要迭代</td></tr><tr><td style="text-align:left">O (kn^2)</td><td style="text-align:left">O (n^3), 需要计算 X^TX的逆矩阵</td></tr><tr><td style="text-align:left">n 非常大时任然适用</td><td style="text-align:left">n太大计算缓慢</td></tr></tbody></table></div><p>聚类算法</p><p><img src="http://img.ron.zone/20210527232523.png" alt="image-20210429102250061"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习库&quot;&gt;&lt;a href=&quot;#学习库&quot; class=&quot;headerlink&quot; title=&quot;学习库&quot;&gt;&lt;/a&gt;学习库&lt;/h1&gt;&lt;p&gt;Numpy 科学计算库&lt;/p&gt;
&lt;p&gt;Pandas 数据分析可视化&lt;/p&gt;
&lt;p&gt;Matplotlib 数据可视化&lt;/p&gt;
&lt;p&gt;S</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Machine Learning" scheme="https://gitflhub.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Vocabulary</title>
    <link href="https://gitflhub.github.io/2021/06/03/Vocabulary/"/>
    <id>https://gitflhub.github.io/2021/06/03/Vocabulary/</id>
    <published>2021-06-03T09:17:43.000Z</published>
    <updated>2021-07-05T14:06:57.273Z</updated>
    
    <content type="html"><![CDATA[<p>threshold</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;threshold&lt;/p&gt;
</summary>
      
    
    
    
    <category term="English" scheme="https://gitflhub.github.io/categories/English/"/>
    
    
    <category term="生词" scheme="https://gitflhub.github.io/tags/%E7%94%9F%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Octave 基础</title>
    <link href="https://gitflhub.github.io/2021/05/31/Octave-%E5%9F%BA%E7%A1%80/"/>
    <id>https://gitflhub.github.io/2021/05/31/Octave-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-31T13:01:42.000Z</published>
    <updated>2021-05-31T13:03:42.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="1-Octave"><a href="#1-Octave" class="headerlink" title="1. Octave"></a>1. Octave</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container"><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>svd</td><td>(singular value decomposition) 奇异值分解</td></tr><tr><td>pinv</td><td>求逆矩阵</td></tr><tr><td>inv</td><td>伪逆矩阵</td></tr><tr><td>‘</td><td>转置</td></tr><tr><td>^</td><td>指数运算</td></tr><tr><td>==</td><td>bool判断</td></tr><tr><td>~=</td><td>不等于判断</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>“双竖杠” 或 xor</td><td>逻辑或</td></tr><tr><td>PS1(“&gt;&gt; “)</td><td>定义默认的提示符</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>pi</td><td>圆周率</td></tr><tr><td>disp</td><td>打印字符串</td></tr><tr><td>sprintf</td><td>拼接字符串</td></tr><tr><td>format long</td><td>默认long型字符串</td></tr><tr><td>format short</td><td>默认short型字符串</td></tr><tr><td>A = [1 2; 3 4; 5 6]</td><td>定义矩阵</td></tr><tr><td>v = 1:0.1:2</td><td>从1到2，生成步长为0.1的数组</td></tr><tr><td>ones(2,3)</td><td>生成两行三列的1矩阵</td></tr><tr><td>zeros(1, 3)</td><td>生成一行三列的零矩阵</td></tr><tr><td>rand(1,3)</td><td>随机生成一行三列的行矩阵</td></tr><tr><td>randn(1,3)</td><td>生成三个符合方差，标准差为1的正态分布的随机数</td></tr><tr><td>hist(数组，默认5柱)</td><td>生成样本直方图</td></tr><tr><td>hist(数组,  50)</td><td>生成50柱直方图</td></tr><tr><td>eye(4)</td><td>四阶单位矩阵</td></tr><tr><td>help eye</td><td>查看eye指令的用法</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>size(A)</td><td>查看矩阵的大小，1x2的矩阵</td></tr><tr><td>size(A，n)</td><td>返回矩阵的第n个纬度大小</td></tr><tr><td>length(v)</td><td>最大维度的大小</td></tr></tbody></table></div><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><div class="table-container"><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>pwd</td><td>Octave当前路径</td></tr><tr><td>cd</td><td>改变路径</td></tr><tr><td>ls</td><td>列出当前路径文件</td></tr><tr><td>load feature.dat 或 load（‘feature.dat’）</td><td>加载文件</td></tr><tr><td>who</td><td>查看当前变量</td></tr><tr><td>whos</td><td>查看当前变量详情，大小，类别</td></tr><tr><td>clear featurex</td><td>删除 featurex</td></tr><tr><td>save hello.mat v;</td><td>将v写入hello.mat文件中</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;h3 id=&quot;1-Octave&quot;&gt;&lt;a href=&quot;#1-Octave&quot; class=&quot;headerlink&quot; title=&quot;1. Octave</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Octave" scheme="https://gitflhub.github.io/tags/Octave/"/>
    
    <category term="工具" scheme="https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Octave 绘制图像</title>
    <link href="https://gitflhub.github.io/2021/05/28/Octave%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/"/>
    <id>https://gitflhub.github.io/2021/05/28/Octave%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</id>
    <published>2021-05-28T13:01:42.000Z</published>
    <updated>2021-07-15T03:55:58.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Octace-绘制图像"><a href="#Octace-绘制图像" class="headerlink" title="Octace 绘制图像"></a>Octace 绘制图像</h2><h3 id="二维图像"><a href="#二维图像" class="headerlink" title="二维图像"></a>二维图像</h3><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 生成从<span class="number">0</span> 到 <span class="number">0.98</span> 的数组，步长为<span class="number">0.01</span></span><br><span class="line">t = [<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.98</span>]; </span><br><span class="line"># 构造y1 和 t的关系式</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">4</span>*t); </span><br><span class="line"># 生成二维图像</span><br><span class="line"><span class="built_in">plot</span>(t,y1); </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527232137.png" alt="image-20210527181550349"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 构造y21 和 t的关系式</span><br><span class="line">y2 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">4</span>*t); </span><br><span class="line"># 生成二维图像</span><br><span class="line"><span class="built_in">plot</span>(t,y2); </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527232146.png" alt="image-20210527182145214"></p><p>在原有基础上添加第一个图像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 保留绘制的第一个图</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"># 继续绘制第二个图</span><br><span class="line"><span class="built_in">plot</span>(t,y1,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527234311.png" alt="image-20210527234250205"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># x轴标签</span><br><span class="line">xlabel(<span class="string">&#x27;time&#x27;</span>) </span><br><span class="line"># y轴标签</span><br><span class="line">ylabel(<span class="string">&#x27;value&#x27;</span>) </span><br><span class="line"># 线型标注</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin&#x27;</span>,<span class="string">&#x27;cos&#x27;</span>) </span><br><span class="line"># 图表名称</span><br><span class="line">title(<span class="string">&#x27;my plot&#x27;</span>) </span><br><span class="line"># 输出图片</span><br><span class="line">print -dpng <span class="string">&#x27;myplot.png&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527235221.png" alt="image-20210527235201685"></p><h4 id="显示多个图像"><a href="#显示多个图像" class="headerlink" title="显示多个图像"></a>显示多个图像</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 分割出第一个子图 <span class="number">1</span> * <span class="number">2</span> 两个子图</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>); </span><br><span class="line"># 填充第一个子图</span><br><span class="line"><span class="built_in">plot</span>(t,y1); </span><br><span class="line"># 分割出第二个子图</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"># 填充第二个子图</span><br><span class="line"><span class="built_in">plot</span>(t,y2);</span><br><span class="line"># 设置第二个子图的坐标轴范围</span><br><span class="line">axis([<span class="number">0.5</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>]) </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210528000519.png" alt="image-20210528000514488"></p><h4 id="矩阵图示"><a href="#矩阵图示" class="headerlink" title="矩阵图示"></a>矩阵图示</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 随机生成<span class="number">5</span>*<span class="number">5</span>矩阵</span><br><span class="line">A = <span class="built_in">magic</span>(<span class="number">5</span>)</span><br><span class="line"># 图示矩阵</span><br><span class="line">imagesc(A)</span><br><span class="line">A =</span><br><span class="line">   <span class="number">17</span>   <span class="number">24</span>    <span class="number">1</span>    <span class="number">8</span>   <span class="number">15</span></span><br><span class="line">   <span class="number">23</span>    <span class="number">5</span>    <span class="number">7</span>   <span class="number">14</span>   <span class="number">16</span></span><br><span class="line">    <span class="number">4</span>    <span class="number">6</span>   <span class="number">13</span>   <span class="number">20</span>   <span class="number">22</span></span><br><span class="line">   <span class="number">10</span>   <span class="number">12</span>   <span class="number">19</span>   <span class="number">21</span>    <span class="number">3</span></span><br><span class="line">   <span class="number">11</span>   <span class="number">18</span>   <span class="number">25</span>    <span class="number">2</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/image-20210528001441719.png" alt="image-20210528001441719"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A =</span><br><span class="line">   <span class="number">17</span>   <span class="number">24</span>    <span class="number">1</span>    <span class="number">8</span>   <span class="number">15</span></span><br><span class="line">   <span class="number">23</span>    <span class="number">5</span>    <span class="number">7</span>   <span class="number">14</span>   <span class="number">16</span></span><br><span class="line">    <span class="number">4</span>    <span class="number">6</span>   <span class="number">13</span>   <span class="number">20</span>   <span class="number">22</span></span><br><span class="line">   <span class="number">10</span>   <span class="number">12</span>   <span class="number">19</span>   <span class="number">21</span>    <span class="number">3</span></span><br><span class="line">   <span class="number">11</span>   <span class="number">18</span>   <span class="number">25</span>    <span class="number">2</span>    <span class="number">9</span></span><br><span class="line"># 组合命令 colorbar 生成条状尺度图 gray 灰度图</span><br><span class="line">imagesc(A), colorbar, colormap gray;</span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/image-20210528002043991.png" alt="image-20210528002043991"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 更大的尺度图</span><br><span class="line">imagesc(<span class="built_in">magic</span>(<span class="number">25</span>)), colorbar, colormap gray;</span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/image-20210528002258670.png" alt="image-20210528002258670"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Octace-绘制图像&quot;&gt;&lt;a href=&quot;#Octace-绘制图像&quot; class=&quot;headerlink&quot; title=&quot;Octace 绘制图像&quot;&gt;&lt;/a&gt;Octace 绘制图像&lt;/h2&gt;&lt;h3 id=&quot;二维图像&quot;&gt;&lt;a href=&quot;#二维图像&quot; class=&quot;</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Octave" scheme="https://gitflhub.github.io/tags/Octave/"/>
    
    <category term="工具" scheme="https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 公式编辑</title>
    <link href="https://gitflhub.github.io/2021/05/27/Markdown-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/"/>
    <id>https://gitflhub.github.io/2021/05/27/Markdown-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</id>
    <published>2021-05-27T13:01:42.000Z</published>
    <updated>2021-11-10T12:27:53.023Z</updated>
    
    <content type="html"><![CDATA[<p>行内公式是在公式代码块的基础上前面加上<strong>$</strong> ，后面加上<strong>$</strong> 组成的，而行间公式则是在公式代码块前后使用<strong>$$</strong> 和<strong>$$</strong> 。</p><h3 id="1-1-行内公式"><a href="#1-1-行内公式" class="headerlink" title="1.1 行内公式"></a>1.1 行内公式</h3><p>行内公式：$ \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. $</p><p>效果：</p><p>$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. $</p><h3 id="1-2-行间公式"><a href="#1-2-行间公式" class="headerlink" title="1.2 行间公式"></a>1.2 行间公式</h3><p>行间公式：$$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.$$</p><p>效果：</p><script type="math/tex; mode=display">\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.</script><h2 id="2-希腊字母"><a href="#2-希腊字母" class="headerlink" title="2. 希腊字母"></a>2. 希腊字母</h2><div class="table-container"><table><thead><tr><th>名称</th><th>大写</th><th>code</th><th>小写</th><th>code</th></tr></thead><tbody><tr><td>alpha</td><td>A</td><td>A</td><td>α</td><td>\alpha</td></tr><tr><td>beta</td><td>B</td><td>B</td><td>β</td><td>\beta</td></tr><tr><td>gamma</td><td>Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td></tr><tr><td>delta</td><td>Δ</td><td>\Delta</td><td>δ</td><td>\delta</td></tr><tr><td>epsilon</td><td>E</td><td>E</td><td>ϵ</td><td>\epsilon</td></tr><tr><td>zeta</td><td>Z</td><td>Z</td><td>ζ</td><td>\zeta</td></tr><tr><td>eta</td><td>H</td><td>H</td><td>η</td><td>\eta</td></tr><tr><td>theta</td><td>Θ</td><td>\Theta</td><td>θ</td><td>\theta</td></tr><tr><td>iota</td><td>I</td><td>I</td><td>ι</td><td>\iota</td></tr><tr><td>kappa</td><td>K</td><td>K</td><td>κ</td><td>\kappa</td></tr><tr><td>lambda</td><td>Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td></tr><tr><td>mu</td><td>M</td><td>M</td><td>μ</td><td>\mu</td></tr><tr><td>nu</td><td>N</td><td>N</td><td>ν</td><td>\nu</td></tr><tr><td>xi</td><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td></tr><tr><td>omicron</td><td>O</td><td>O</td><td>ο</td><td>\omicron</td></tr><tr><td>pi</td><td>Π</td><td>\Pi</td><td>π</td><td>\pi</td></tr><tr><td>rho</td><td>P</td><td>P</td><td>ρ</td><td>\rho</td></tr><tr><td>sigma</td><td>Σ</td><td>\Sigma</td><td>σ</td><td>\sigma</td></tr><tr><td>tau</td><td>T</td><td>T</td><td>τ</td><td>\tau</td></tr><tr><td>upsilon</td><td>Υ</td><td>υ</td><td>υ</td><td>\upsilon</td></tr><tr><td>phi</td><td>Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td></tr><tr><td>chi</td><td>X</td><td>X</td><td>χ</td><td>\chi</td></tr><tr><td>psi</td><td>Ψ</td><td>\Psi</td><td>ψ</td><td>\psi</td></tr><tr><td>omega</td><td>Ω</td><td>\Omega</td><td>ω</td><td>\omega</td></tr></tbody></table></div><h2 id="3-上下标"><a href="#3-上下标" class="headerlink" title="3. 上下标"></a>3. 上下标</h2><p>上标 $x^2$ : $x^2$</p><p>下标$x_1$ : $x_1$</p><p>组合$x^2_1$ : $x^2_1$</p><ul><li>注意：例如$x<em>{12}$源码为： $x</em>{12}$。注意其中的<strong>中括号{}</strong></li></ul><p>多级上标${x^5}^6$：需要用<strong>中括号{}</strong>划分界限$<strong>{</strong>x\^5<strong>}</strong>\^6$, $x\^<strong>{</strong>5\^6<strong>}</strong>$ 两种方式均可以</p><h2 id="4-括号"><a href="#4-括号" class="headerlink" title="4. 括号"></a>4. 括号</h2><h3 id="4-1-小括号与方括号"><a href="#4-1-小括号与方括号" class="headerlink" title="4.1 小括号与方括号"></a>4.1 小括号与方括号</h3><p>使用原始的<code>( )</code> ，<code>[ ]</code> 即可</p><p>如<script type="math/tex">(2+3)[4+4]</script>：$(2+3)[4+3]$</p><ul><li>复杂例子：</li></ul><p>$(\frac{x}{y})$： 可表示为<script type="math/tex">\left(\frac{x}{y}\right)</script> 或<script type="math/tex">(\frac{x}{y})</script></p><h3 id="4-2-大括号"><a href="#4-2-大括号" class="headerlink" title="4.2 大括号"></a>4.2 大括号</h3><p>由于大括号<code>&#123;&#125;</code> 被用于分组，因此需要使用<code>\&#123;</code>和<code>\&#125;</code>表示大括号，也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示。</p><p>如<script type="math/tex">\{a*b\}:a∗b</script> 或<script type="math/tex">\lbrace a*b\rbrace :a*b</script>表示：${a*b}:a∗b$ </p><h3 id="4-3-尖括号"><a href="#4-3-尖括号" class="headerlink" title="4.3 尖括号"></a>4.3 尖括号</h3><p> 区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<script type="math/tex">\langle x \rangle</script> 表示：$\langle x \rangle$。</p><h2 id="5-求和与积分"><a href="#5-求和与积分" class="headerlink" title="5. 求和与积分"></a>5. 求和与积分</h2><h3 id="5-1-求和"><a href="#5-1-求和" class="headerlink" title="5.1 求和"></a>5.1 求和</h3><p><code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。</p><p>如:<script type="math/tex">\sum_{r=1}^n</script>表示：$\sum_{r=1}^n$</p><h3 id="5-2-积分"><a href="#5-2-积分" class="headerlink" title="5.2 积分"></a>5.2 积分</h3><p><code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<script type="math/tex">\int_{r=1}^\infty</script>表示：$\int_{r=1}^\infty$</p><p>多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：</p><p><code>\iint</code>表示： $\iint$，</p><p><code>\iint\</code>表示： $\iiint$，</p><p><code>\iiiint</code>表示： $\iiiint$，</p><h3 id="5-3-连乘"><a href="#5-3-连乘" class="headerlink" title="5.3 连乘"></a>5.3 连乘</h3><p><code>\prod &#123;a+b&#125;</code>，输出：$\prod {a+b}$</p><p><code>\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)</code>，输出：$\prod_{i=1}^{k}({a+b})$</p><p><code>\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)</code>，输出$\prod_{i=1}^{k}({a+b})$</p><p><code>a \times b</code> 输出$a \times b$</p><h3 id="5-4-其他类似"><a href="#5-4-其他类似" class="headerlink" title="5.4 其他类似"></a>5.4 其他类似</h3><p><code>\prod</code> :  $\prod$</p><p><code>\bigcup</code> :   $\bigcup$</p><p><code>\bigcap</code> :   $\bigcap$</p><p><code>\arg\,\\max_&#123;c_k&#125;</code> : $arg\, \max{c_k}$</p><h2 id="6-分式与根式"><a href="#6-分式与根式" class="headerlink" title="6. 分式与根式"></a>6. 分式与根式</h2><h3 id="6-1-分式"><a href="#6-1-分式" class="headerlink" title="6.1 分式"></a>6.1 分式</h3><p>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为 $\frac ab$</p><p>如果你的分子或分母不是单个字符，请使用<code>&#123;..&#125;</code>来分组，比如<code>\frac &#123;a+c+1&#125;&#123;b+c+2&#125;</code>表示：$\frac {a+c+1}{b+c+2}$</p><p>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>&#123;a+1\over b+1&#125;</code>：${a+1\over b+1}$</p><h3 id="6-2-连分式"><a href="#6-2-连分式" class="headerlink" title="6.2 连分式"></a>6.2 连分式</h3><p>书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：<br><code>\frac</code> 表示如下：</p><p><code>x=a_0 + \frac &#123;1^2&#125;&#123;a_1 + \frac &#123;2^2&#125;&#123;a_2 + \frac &#123;3^2&#125;&#123;a_3 + \frac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;</code></p><script type="math/tex; mode=display">x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + ...}}}}</script><p>\cfrac 表示如下：<code>x=a_0 + \cfrac &#123;1^2&#125;&#123;a_1 + \cfrac &#123;2^2&#125;&#123;a_2 + \cfrac &#123;3^2&#125;&#123;a_3 + \cfrac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;</code></p><script type="math/tex; mode=display">x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + ...}}}}</script><h3 id="6-3-根式"><a href="#6-3-根式" class="headerlink" title="6.3 根式"></a>6.3 根式</h3><p>根式使用<code>\sqrt</code> 来表示：$\sqrt{\pi}$</p><p>如开4次方：<code>\sqrt[4]&#123;\frac xy&#125;</code>:$\sqrt[4]{\frac xy}$</p><p>开平方：<code>\sqrt &#123;a+b&#125;</code>：$\sqrt {a+b}$</p><h2 id="7-多行表达式"><a href="#7-多行表达式" class="headerlink" title="7. 多行表达式"></a>7. 多行表达式</h2><h3 id="7-1-分类表达式"><a href="#7-1-分类表达式" class="headerlink" title="7.1 分类表达式"></a>7.1 分类表达式</h3><p>定义函数的时候经常需要分情况给出表达式，使用<code>\begin&#123;cases&#125;…\end&#123;cases&#125;</code> 。其中：</p><ul><li><p>使用<code>\\</code> 来分类</p></li><li><p>使用<code>&amp;</code> 指示需要对齐的位置，</p></li><li><p>使用<code>\</code> +<code>空格</code>表示空格。</p></li></ul><p>例子 1：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">f(n)</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">\cfrac n2, &amp;<span class="keyword">if</span>\ n\ is\ even\\</span><br><span class="line">3n + <span class="number">1</span>, &amp;<span class="keyword">if</span>\  n\ is\ odd</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">f(n)\begin{cases}\cfrac n2, &if\ n\ is\ even\\3n + 1, &if\  n\ is\ odd\end{cases}</script><p>例子 2：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">L(Y,f(X)) =</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line"><span class="number">0</span>, &amp; \text&#123;Y = f(X)&#125;  \\</span><br><span class="line"><span class="number">1</span>, &amp; \text&#123;Y <span class="variable">$\</span>neq<span class="variable">$ </span>f(X)&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">L(Y, f(X)) =\begin{cases}0, & \text{Y = f(X)}\\1, & \text{Y $\neq$ f(X)}\end{cases}</script><h3 id="7-2-多行表达式"><a href="#7-2-多行表达式" class="headerlink" title="7.2 多行表达式"></a>7.2 多行表达式</h3><p>有时候需要将一行公式分多行进行显示。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;\<span class="keyword">begin</span>&#123;split&#125; </span><br><span class="line">a&amp;=b+c-d \\ </span><br><span class="line">&amp;\quad +e-f\\ </span><br><span class="line">&amp;=g+h\\ </span><br><span class="line">&amp; =i </span><br><span class="line">\<span class="keyword">end</span>&#123;split&#125;\<span class="keyword">end</span>&#123;equation&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{equation}\begin{split}a&=b+c -d\\&\quad +e-f\\&=g+h\\&=i\end{split}\end{equation}</script><p> 其中begin{equation} 表示开始方程，end{equation} 表示方程结束；begin{split} 表示开始多行公式，end{split} 表示结束；公式中用\ 表示回车到下一行，&amp; 表示对齐的位置。</p><h3 id="7-3-方程组"><a href="#7-3-方程组" class="headerlink" title="7.3 方程组"></a>7.3 方程组</h3><p>使用<code>\begin&#123;array&#125;...\end&#123;array&#125;</code> 与<code>\left \&#123;</code> 与<code>\right.</code> 配合表示方程组:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\left \&#123; </span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left \{\begin{array}{c}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\\\end{array}\right.</script><h2 id="8-特殊函数与符号"><a href="#8-特殊函数与符号" class="headerlink" title="8. 特殊函数与符号"></a>8. 特殊函数与符号</h2><h3 id="8-1-三角函数"><a href="#8-1-三角函数" class="headerlink" title="8.1 三角函数"></a>8.1 三角函数</h3><p><code>\sin(x)</code>: $\sin(x)$</p><p><code>\arctan(x)</code>: $arctan(x)$</p><h3 id="8-2-比较运算符"><a href="#8-2-比较运算符" class="headerlink" title="8.2 比较运算符"></a>8.2 比较运算符</h3><p>小于(<code>\lt</code> )：$\lt$</p><p>大于(<code>\gt</code> )：$\gt$</p><p>小于等于(<code>\le</code> )：$\le$</p><p>大于等于(<code>\ge</code> )：$\ge$</p><p>不等于(<code>\ne</code> ) :$\ne$</p><p>可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> :$\not \lt$</p><h3 id="8-3-集合运算符"><a href="#8-3-集合运算符" class="headerlink" title="8.3 集合运算符"></a>8.3 集合运算符</h3><p>并集(<code>\cup</code> ): $\cup$<br>交集(<code>\cap</code> ): $\cap$<br>差集(<code>\setminus</code> ): $\setminus$<br>子集(<code>\subset</code> ): $\subset$<br>真子集(<code>\subseteq</code> ): $\subseteq$<br>非子集(<code>\subsetneq</code> ): $\subsetneq$<br>父集(<code>\supset</code> ): $\supset$<br>属于(<code>\in</code> ): $\in$<br>不属于(<code>\notin</code> ): $\notin$<br>空集(<code>\emptyset</code> ): $\emptyset$<br>空(<code>\varnothing</code>): $\varnothing$</p><h3 id="8-4-排列"><a href="#8-4-排列" class="headerlink" title="8.4 排列"></a>8.4 排列</h3><p><code>\binom&#123;n+1&#125;&#123;2k&#125;</code>:$\binom{n+1}{2k}$</p><p><code>&#123;n+1 \choose 2k&#125;</code>: ${n+1 \choose 2k}$</p><h3 id="8-5-箭头"><a href="#8-5-箭头" class="headerlink" title="8.5 箭头"></a>8.5 箭头</h3><p><code>\to</code>: $\to$<br><code>\rightarrow</code>: $\rightarrow$<br><code>\leftarrow</code>: $\leftarrow$<br><code>\Rightarrow</code>: $\Rightarrow$<br><code>\Leftarrow</code>: $\Leftarrow$<br><code>\mapsto</code>: $\mapsto$</p><h3 id="8-6-逻辑运算符"><a href="#8-6-逻辑运算符" class="headerlink" title="8.6 逻辑运算符"></a>8.6 逻辑运算符</h3><p><code>\land</code>:$\land$<br><code>\lor</code>: $\lor$<br><code>\lnot</code>: $\lnot$<br><code>\forall</code>: $\forall$<br><code>\exists</code>: $\exists$<br><code>\top</code>: $\top$<br><code>\bot</code>: $\bot$<br><code>\vdash</code>: $\vdash$<br><code>\vDash</code>: $\vDash$</p><h3 id="8-7-模运算"><a href="#8-7-模运算" class="headerlink" title="8.7 模运算"></a>8.7 模运算</h3><p> <code>\mod 6</code>: $\mod 6$</p><p>  如<code>a \equiv b \mod n</code> : $a \equiv b \mod n$</p><h3 id="8-8-点"><a href="#8-8-点" class="headerlink" title="8.8 点"></a>8.8 点</h3><p><code>\ldots</code>: $\ldots$<br><code>\cdots</code>: $\cdots$<br><code>\cdot</code>:  $\cdot$<br>  其区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line">a_1+a_2+\ldots+a_n \\ </span><br><span class="line">a_1+a_2+\cdots+a_n</span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><p>表示：</p><script type="math/tex; mode=display">\begin{equation}a_1+a_2+\ldots+a_n\\a_1+a_2+\cdots+a_n\\\end{equation}</script><h2 id="9-顶部符号"><a href="#9-顶部符号" class="headerlink" title="9. 顶部符号"></a>9. 顶部符号</h2><p>对于单字符，<code>\hat x</code> ：$\hat x$<br>多字符可以使用<code>\widehat &#123;xy&#125;</code> ：$\widehat {xy}$<br>类似的还有:<br><code>\overline x</code> : $\overline x$<br>矢量(<code>\vec x</code> ): $\vec x$<br>向量(<code>\overrightarrow &#123;xy&#125;</code> ): $\overrightarrow {xy}$<br>(<code>\dot x</code> ): $\dot x$<br>(<code>\ddot x</code> ): $\ddot x$<br>(<code>\dot &#123;\dot x&#125;</code> ): $\dot {\dot x}$</p><h2 id="10-表格"><a href="#10-表格" class="headerlink" title="10. 表格"></a>10. 表格</h2><p>使用<code>\begin&#123;array&#125;&#123;列样式&#125;…\end&#123;array&#125;</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。 例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c<span class="params">|lcr&#125;</span></span><br><span class="line"><span class="params">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\</span></span><br><span class="line"><span class="params">\hline</span></span><br><span class="line"><span class="params">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span></span><br><span class="line"><span class="params">2 &amp; -1 &amp; 189 &amp; -8 \\</span></span><br><span class="line"><span class="params">3 &amp; -20 &amp; 2000 &amp; 1+10i \\</span></span><br><span class="line"><span class="params">\<span class="keyword">end</span>&#123;array&#125;</span></span><br><span class="line"><span class="params">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{array}{c|lcr}n & \text{Left} & \text{Center} & \text{Right} \\\hline1 & 0.24 & 1 & 125 \\2 & -1 & 189 & -8 \\3 & -20 & 2000 & 1+10i \\\end{array}</script><h2 id="11-矩阵"><a href="#11-矩阵" class="headerlink" title="11. 矩阵"></a>11. 矩阵</h2><h3 id="11-1-基本内容"><a href="#11-1-基本内容" class="headerlink" title="11.1 基本内容"></a>11.1 基本内容</h3><p>使用<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="number">1</span> &amp; x &amp; x^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; y &amp; y^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; z &amp; z^<span class="number">2</span> \\</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{matrix}1 & x & x^2 \\1 & y & y^2 \\1 & z & z^2 \\\end{matrix}</script><h3 id="11-2-括号"><a href="#11-2-括号" class="headerlink" title="11.2 括号"></a>11.2 括号</h3><p>如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p><ol><li><p>pmatrix<code>\begin&#123;pmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;pmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{pmatrix}1 & 2 \\ 3 & 4\\ \end{pmatrix}</script></li><li><p>bmatrix<code>\begin&#123;bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;bmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 \\ 3 & 4\\ \end{bmatrix}</script></li><li><p>Bmatrix<code>\begin&#123;Bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Bmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{Bmatrix}1 & 2 \\ 3 & 4\\ \end{Bmatrix}</script></li><li><p>vmatrix<code>\begin&#123;vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;vmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{vmatrix}1 & 2 \\ 3 & 4\\ \end{vmatrix}</script></li><li><p>Vmatrix<code>\begin&#123;Vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Vmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{Vmatrix}1 & 2 \\ 3 & 4\\ \end{Vmatrix}</script></li></ol><h3 id="元素省略"><a href="#元素省略" class="headerlink" title="元素省略"></a>元素省略</h3><p>  可以使用<code>\cdots</code> ：⋯，<code>\ddots</code>：⋱ ，<code>\vdots</code>：⋮ 来省略矩阵中的元素，如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="number">1</span>&amp;a_1&amp;a_1^<span class="number">2</span>&amp;\cdots&amp;a_1^n\\</span><br><span class="line"><span class="number">1</span>&amp;a_2&amp;a_2^<span class="number">2</span>&amp;\cdots&amp;a_2^n\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line"><span class="number">1</span>&amp;a_m&amp;a_m^<span class="number">2</span>&amp;\cdots&amp;a_m^n\\</span><br><span class="line">\<span class="keyword">end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><p>  表示：</p><script type="math/tex; mode=display">\begin{pmatrix}1&a_1&a_1^2&\cdots&a_1^n\\1&a_2&a_2^2&\cdots&a_2^n\\\vdots&\vdots&\vdots&\ddots&\vdots\\1&a_m&a_m^2&\cdots&a_m^n\\\end{pmatrix}</script><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>  增广矩阵需要使用前面的表格中使用到的<code>\begin&#123;array&#125; ... \end&#123;array&#125;</code> 来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[  \begin&#123;array&#125;  &#123;c c <span class="operator">|</span> c&#125; <span class="operator">%</span>这里的c表示数组中元素对其方式：c居中<span class="operator">、</span>r右对齐<span class="operator">、</span>l左对齐，竖线表示<span class="number">2</span><span class="operator">、</span><span class="number">3</span>列间插入竖线</span><br><span class="line"><span class="number">1</span> <span class="operator">&amp;</span> <span class="number">2</span> <span class="operator">&amp;</span> <span class="number">3</span> \\</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="operator">&amp;</span> <span class="number">5</span> <span class="operator">&amp;</span> <span class="number">6</span></span><br><span class="line">\end&#123;array&#125;  \right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示为：</p><script type="math/tex; mode=display">\left[  \begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 & 2 & 3 \\4 & 5 & 6\end{array}  \right]</script><h2 id="12-公式标记与引用"><a href="#12-公式标记与引用" class="headerlink" title="12. 公式标记与引用"></a>12. 公式标记与引用</h2><p> 使用<code>\tag&#123;yourtag&#125;</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label&#123;yourlabel&#125;</code> 在<code>\tag</code> 之后，如<code>a = x^2 - y^3 \tag&#123;1&#125;\label&#123;1&#125;</code> 显示为：</p><script type="math/tex; mode=display">a = x^2 - y^3 \tag{12.1}</script><p>  如果不需要被引用，只使用<code>\tag&#123;yourtag&#125;</code> ，<code>x+y=z\tag&#123;1.1&#125;</code>显示为：</p><script type="math/tex; mode=display">x+y=z\tag{12.2}</script><p>  <code>\tab&#123;yourtab&#125;</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label&#123;&#125;</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref&#123;yourlabel&#125;</code> ，如<code>a + y^3 \stackrel&#123;\eqref&#123;1&#125;&#125;= x^2</code> 显示为：</p><script type="math/tex; mode=display">a + y^3 \stackrel{\eqref{1}}= x^2</script><p>或者使用<code>\ref&#123;yourlabel&#125;</code> 不带括号引用，如<code>a + y^3 \stackrel&#123;\ref&#123;111&#125;&#125;= x^2</code> 显示为：</p><script type="math/tex; mode=display">a + y^3 \stackrel{\ref{111}}= x^2</script><h2 id="13-字体"><a href="#13-字体" class="headerlink" title="13. 字体"></a>13. 字体</h2><h3 id="黑板粗体字"><a href="#黑板粗体字" class="headerlink" title="黑板粗体字"></a>黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br> <code>\mathbb ABCDEF</code>：</p><p> <script type="math/tex">\Bbb ABCDEF</script>：</p><h3 id="黑体字"><a href="#黑体字" class="headerlink" title="黑体字"></a>黑体字</h3><p><code>\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> : $\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$<br><code>\mathbf abcdefghijklmnopqrstuvwxyz</code> :$\mathbf abcdefghijklmnopqrstuvwxyz$</p><h3 id="打印机字体"><a href="#打印机字体" class="headerlink" title="打印机字体"></a>打印机字体</h3><p><code>\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> : $\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;行内公式是在公式代码块的基础上前面加上&lt;strong&gt;$&lt;/strong&gt; ，后面加上&lt;strong&gt;$&lt;/strong&gt; 组成的，而行间公式则是在公式代码块前后使用&lt;strong&gt;$$&lt;/strong&gt; 和&lt;strong&gt;$$&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="语言" scheme="https://gitflhub.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="LaTex" scheme="https://gitflhub.github.io/tags/LaTex/"/>
    
    <category term="数学公式" scheme="https://gitflhub.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java实现堆排序，快速排序，归并排序</title>
    <link href="https://gitflhub.github.io/2021/05/26/Java%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://gitflhub.github.io/2021/05/26/Java%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-05-26T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:33.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>堆排序(大根堆，降序排序为例)的算法思想</p><p>①将输入元素构造成堆</p><p>②构造完成后找到最右下元素的父节点开始进行局部调整</p><p>③依次往前，重复②的操作，直到调整到堆的根节点。</p><p>④输出堆顶元素</p><p>⑤重复②③④步骤，直到堆被清空。</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><p>主函数入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> solution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct.Heap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化堆</span></span><br><span class="line">        Heap heap = <span class="keyword">new</span> Heap(<span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">18</span>&#125;);</span><br><span class="line">        <span class="comment">// 调整为大根堆</span></span><br><span class="line">        heap.turnMaxHeap();</span><br><span class="line">        <span class="comment">// 输出堆顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (heap.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环输出堆顶元素</span></span><br><span class="line">            System.out.println(heap.peakHeapTop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Heap类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设堆的最大大小为100</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 存放数据的元素</span></span><br><span class="line">    <span class="keyword">public</span> Integer[] elems = <span class="keyword">new</span> Integer[MAX_SIZE];</span><br><span class="line">    <span class="comment">// 堆的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造堆的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(Integer[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            elems[i] = arr[i];</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造大根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnMaxHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最右下节点的父节点开始遍历</span></span><br><span class="line">        <span class="keyword">int</span> index = size / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 局部调整</span></span><br><span class="line">            turnPartialMaxHeap(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆进行局部调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentIndex 子树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnPartialMaxHeap</span><span class="params">(<span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左孩子索引</span></span><br><span class="line">        Integer leftChildIndex = getLeftChildIndex(currentIndex);</span><br><span class="line">        <span class="comment">// 右孩子索引</span></span><br><span class="line">        Integer rightChildIndex = getRightChildIndex(currentIndex);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (leftChildIndex == <span class="keyword">null</span> &amp;&amp; rightChildIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明当前已经找到了叶结点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftChildIndex != <span class="keyword">null</span> &amp;&amp; rightChildIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (elems[currentIndex] &lt; elems[leftChildIndex]) &#123;</span><br><span class="line">                Integer temp = elems[currentIndex];</span><br><span class="line">                elems[currentIndex] = elems[leftChildIndex];</span><br><span class="line">                elems[leftChildIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftChildIndex != <span class="keyword">null</span> &amp;&amp; rightChildIndex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 左孩子右孩子同时存在,取左右节点的最大值与父节点进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (elems[leftChildIndex] &gt; elems[rightChildIndex]) &#123;</span><br><span class="line">                <span class="comment">// 左孩子为孩子王</span></span><br><span class="line">                <span class="keyword">if</span> (elems[currentIndex] &lt; elems[leftChildIndex]) &#123;</span><br><span class="line">                    Integer temp = elems[currentIndex];</span><br><span class="line">                    elems[currentIndex] = elems[leftChildIndex];</span><br><span class="line">                    elems[leftChildIndex] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有孩子为孩子王或者左右孩子相等</span></span><br><span class="line">                <span class="keyword">if</span> (elems[currentIndex] &lt; elems[rightChildIndex]) &#123;</span><br><span class="line">                    Integer temp = elems[currentIndex];</span><br><span class="line">                    elems[currentIndex] = elems[rightChildIndex];</span><br><span class="line">                    elems[rightChildIndex] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续调整左右子树</span></span><br><span class="line">            turnPartialMaxHeap(<span class="number">2</span> * (currentIndex + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            turnPartialMaxHeap(<span class="number">2</span> * (currentIndex + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 摘取堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peakHeapTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果堆为空，则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取出堆顶元素</span></span><br><span class="line">            res = elems[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 补上堆顶元素</span></span><br><span class="line">            elems[<span class="number">0</span>] = elems[size - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// size 自减</span></span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// 重新建立大根堆</span></span><br><span class="line">            turnMaxHeap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的左孩子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLeftChild</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLeftChildIndex(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[getLeftChildIndex(index)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取左孩子索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLeftChildIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; (index + <span class="number">1</span>) * <span class="number">2</span> &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的右孩子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRightChild</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getRightChildIndex(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[getRightChildIndex(index)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取右孩子索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRightChildIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; (index + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span> &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>①将待排序数组的第一个元素作为标准，将比第一个元素小的放到参照元素的左边，将比第一个元素大的放到参照元素的右边。<br>②放置完成后，把原数组划分为参照元素前后两个子数组<br>③重复①②过程，直到子数组中只有一个元素时停止排序</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>主函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = quickSort(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>排序函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr        待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex   结束下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回开始结束下标之间的一次快排操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex) &#123;</span><br><span class="line">    <span class="comment">// 下标异常返回arr,跳出递归过程</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex || startIndex &lt; <span class="number">0</span> || endIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考值</span></span><br><span class="line">    <span class="keyword">int</span> splitNum = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> frontIndex = startIndex;</span><br><span class="line">    <span class="keyword">int</span> rearIndex = endIndex;</span><br><span class="line">    <span class="comment">// 起始下标小于结束下标时进行循环</span></span><br><span class="line">    <span class="keyword">boolean</span> lastMoveIsFront = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (rearIndex &gt; frontIndex) &#123;</span><br><span class="line">        <span class="comment">// 从数组尾巴上找到第一个比参考值小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (rearIndex &gt; frontIndex &amp;&amp; arr[rearIndex] &gt;= splitNum) &#123;</span><br><span class="line">            rearIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断循环跳出原因</span></span><br><span class="line">        <span class="keyword">if</span> (arr[rearIndex] &lt; splitNum) &#123;</span><br><span class="line">            <span class="comment">// 将小数左移</span></span><br><span class="line">            arr[frontIndex++] = arr[rearIndex];</span><br><span class="line">            <span class="comment">// 标记最后一次移动是头指针</span></span><br><span class="line">            lastMoveIsFront = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从数组头部找到一个比参考值大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (rearIndex &gt; frontIndex &amp;&amp; arr[frontIndex] &lt;= splitNum) &#123;</span><br><span class="line">            frontIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断循环跳出原因</span></span><br><span class="line">    <span class="keyword">if</span> (arr[frontIndex] &gt; splitNum) &#123;</span><br><span class="line">        <span class="comment">// 将大数后移</span></span><br><span class="line">        arr[rearIndex--] = arr[frontIndex];</span><br><span class="line">        <span class="comment">// 标记最后一次移动是尾指针</span></span><br><span class="line">        lastMoveIsFront = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将参考值放入合适的位置 此处犯过错误</span></span><br><span class="line">    <span class="keyword">if</span> (lastMoveIsFront) &#123;</span><br><span class="line">        arr[frontIndex--] = splitNum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[frontIndex++] = splitNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治处理当前参考值左右边子数组</span></span><br><span class="line">    quickSort(arr, startIndex, rearIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, rearIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>①将待排序数组的以2,4,8,,,2^n的步长划分为若干个子数组<br>②对这些子数组进行排序，这里选择的是快速排序</p><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 起始步长为1</span></span><br><span class="line">        <span class="keyword">int</span> spet = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (spet &lt; arr.length) &#123;</span><br><span class="line">            spet *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i += spet) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i;</span><br><span class="line">                <span class="keyword">int</span> end = i + spet - <span class="number">1</span> &lt; arr.length - <span class="number">1</span> ? i + spet - <span class="number">1</span> : arr.length - <span class="number">1</span>;</span><br><span class="line">                quickSort(arr, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思</summary>
      
    
    
    
    <category term="算法" scheme="https://gitflhub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://gitflhub.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 制作 Anki 卡片</title>
    <link href="https://gitflhub.github.io/2021/05/15/Markdown-%E5%88%B6%E4%BD%9C-Anki-%E5%8D%A1%E7%89%87/"/>
    <id>https://gitflhub.github.io/2021/05/15/Markdown-%E5%88%B6%E4%BD%9C-Anki-%E5%8D%A1%E7%89%87/</id>
    <published>2021-05-15T13:01:42.000Z</published>
    <updated>2021-07-15T04:02:49.863Z</updated>
    
    <content type="html"><![CDATA[<p>MarkDown 编辑器</p><h3 id="方式一：MarkDown-编辑器"><a href="#方式一：MarkDown-编辑器" class="headerlink" title="方式一：MarkDown 编辑器"></a>方式一：MarkDown 编辑器</h3><h4 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h4><p>这里以Typora为例：<br>1.打开MarkDown 编辑器<br>2.设置标题层级<br>3.四级标题#### 这层标题为面试的具体问题，如“JRE和JDK的区别？”<br>4.五级标题##### 这层标题为面试问题的具体答案,示例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># JAVA工程师面试</span><br><span class="line"></span><br><span class="line">## 1.JAVA </span><br><span class="line"></span><br><span class="line">### (1)Java基础</span><br><span class="line"></span><br><span class="line">#### JRE和JDK的区别</span><br><span class="line"></span><br><span class="line">##### JDK Java Development Kit,Java 开发工具包，提供了开发环境和运行环境</span><br><span class="line"></span><br><span class="line">##### JRE Java Runtime Environment Java 运行环境，为Java提供了所需的环境</span><br><span class="line"></span><br><span class="line">##### 运行Java程序，JRE即可</span><br><span class="line"></span><br><span class="line">##### 编写Java程序，需要安装JDK</span><br></pre></td></tr></table></figure></p><h4 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h4><h5 id="1-转为Anki批量格式CSV"><a href="#1-转为Anki批量格式CSV" class="headerlink" title="1.转为Anki批量格式CSV"></a>1.转为Anki批量格式CSV</h5><p>网上有一个大佬做了Markdown转Anki卡片的功能，链接如下<br><a href="https://hintsnet.com/tools/md2anki/index.html">https://hintsnet.com/tools/md2anki/index.html</a></p><h5 id="2-格式调整"><a href="#2-格式调整" class="headerlink" title="2.格式调整"></a>2.格式调整</h5><p>由于下载来的文件里面默认HTML标签是&lt; ol &gt;,在文本编辑器中批量替换为&lt; ul &gt;</p><h5 id="3-导入Anki"><a href="#3-导入Anki" class="headerlink" title="3.导入Anki"></a>3.导入Anki</h5><h3 id="方式二：网页数据爬取"><a href="#方式二：网页数据爬取" class="headerlink" title="方式二：网页数据爬取"></a>方式二：网页数据爬取</h3><h4 id="网页爬取数据"><a href="#网页爬取数据" class="headerlink" title="网页爬取数据"></a>网页爬取数据</h4><h5 id="爬取工具类"><a href="#爬取工具类" class="headerlink" title="爬取工具类"></a>爬取工具类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网页抓取工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> htmltest 要获取的资源URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> laber    anki标签</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">(String htmltest, String laber)</span> </span>&#123;</span><br><span class="line">        String html = htmltest;</span><br><span class="line">        <span class="comment">// HTML文档对象</span></span><br><span class="line">        Document doc = Jsoup.parse(html);</span><br><span class="line">        Elements rows = doc.select(<span class="string">&quot;div[class=interview_detail]&quot;</span>).get(<span class="number">0</span>).select(<span class="string">&quot;ul&quot;</span>).select(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        Elements rowTitle = doc.select(<span class="string">&quot;div[class=interview_detail]&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成Anki题目</span></span><br><span class="line">        Element pFirst = rowTitle.select(<span class="string">&quot;p&quot;</span>).first();</span><br><span class="line">        <span class="comment">// rowTitle.remove(pFirst);</span></span><br><span class="line"></span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String res = rowTitle.html();</span><br><span class="line">        <span class="keyword">if</span> (rows.size() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取网页结构指定的div[class=interview_wrap] 的代码信息</span></span><br><span class="line">            String title = doc.select(<span class="string">&quot;div[class=interview_wrap]&quot;</span>).select(<span class="string">&quot;h2&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="comment">// 替换回车</span></span><br><span class="line">            res = res.replaceAll(<span class="string">&quot;(\\r\\n|\\n|\\n\\r)&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">                    .replaceAll(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .replaceAll(<span class="string">&quot;class=\&quot;language-java\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pFirst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 删除空行</span></span><br><span class="line">                res = res.replaceAll(pFirst.html(), <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;&lt;p&gt;&lt;/p&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// title 是anki卡片正面</span></span><br><span class="line">            stringBuffer.append(title).append(<span class="string">&quot;\t &quot;</span>);</span><br><span class="line">            <span class="comment">// 标签分类</span></span><br><span class="line">            stringBuffer.append(laber).append(<span class="string">&quot;\t &quot;</span>);</span><br><span class="line">            <span class="comment">// res 是anki卡片反面</span></span><br><span class="line">            stringBuffer.append(res);</span><br><span class="line">            System.out.println(stringBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Script</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个文件里面存放了链接信息</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;src/main/resources/url.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取配置信息</span></span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">            String str;</span><br><span class="line">            String label = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> ((str = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取Anki标签</span></span><br><span class="line">                <span class="keyword">if</span> (str.contains(<span class="string">&quot;@&quot;</span>)) &#123;</span><br><span class="line">                    label = str.substring(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 链接拼接</span></span><br><span class="line">                    String urlStr = <span class="string">&quot;https://www.javanav.com/interview/&quot;</span> + str + <span class="string">&quot;.html&quot;</span>; <span class="comment">// 网址</span></span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">                    String result = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream()))</span><br><span class="line">                            .lines().parallel().collect(Collectors.joining(System.lineSeparator()));</span><br><span class="line">                    <span class="comment">// 调用爬取入口</span></span><br><span class="line">                    Test1.demo1(result, label);</span><br><span class="line">                    <span class="comment">// 读取太快会被反爬虫</span></span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="控制台打印结果（部分）"><a href="#控制台打印结果（部分）" class="headerlink" title="控制台打印结果（部分）"></a>控制台打印结果（部分）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==和equals的区别是什么? Java基础 &lt;ul&gt;   &lt;li&gt;== 是关系运算符，equals() 是方法，结果都返回布尔值&lt;/li&gt;   &lt;li&gt;Object 的 == 和 equals() 比较的都是地址，作用相同&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;== 作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;基本类型，比较值是否相等&lt;/li&gt;   &lt;li&gt;引用类型，比较内存地址值是否相等&lt;/li&gt;   &lt;li&gt;不能比较没有父子关系的两个对象&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;equals()方法的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;JDK 中的类一般已经重写了 equals()，比较的是内容&lt;/li&gt;   &lt;li&gt;自定义类如果没有重写 equals()，将调用父类（默认 Object 类）的 equals() 方法，Object 的 equals() 比较使用了 this == obj&lt;/li&gt;   &lt;li&gt;可以按照需求逻辑，重写对象的 equals() 方法（重写 equals方法，一般须重写 hashCode方法）&lt;/li&gt;  &lt;/ul&gt;  </span><br><span class="line">基本类型和包装类对象使用 == 和 equals进行比较的结果？ Java基础 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;1、值不同，使用 ＝＝ 和 equals() 比较都返回 false&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、值相同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;p&gt;使用 ＝＝ 比较：&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;基本类型 － 基本类型、基本类型 － 包装对象返回 true&lt;/li&gt;   &lt;li&gt;包装对象 － 包装对象，非同一个对象（对象的内存地址不同）返回 false；对象的内存地址相同返回 true，如下值等于 100 的两个 Integer 对象（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）&lt;/li&gt;  &lt;/ul&gt;  &lt;pre&gt; &lt;code&gt; Integer i1 = 100; &amp;nbsp;Integer i2 = 100; &amp;nbsp;Integer i3 = 200; &amp;nbsp;Integer i4 = 200; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(i1==i2); //打印true &amp;nbsp;System.out.println(i3==i4); //打印false&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;使用 equals() 比较&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;包装对象－基本类型返回 true&lt;/li&gt;   &lt;li&gt;包装对象－包装对象返回 true&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;3、不同类型的对象对比，返回 false&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;JDK1.8，实验代码&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;byte b1 = 127; Byte b2 = new Byte(&quot;127&quot;); Byte b3 = new Byte(&quot;127&quot;); System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2)); System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1)); System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3)); System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3)); System.out.println();  short s1 = 12; Short s2 = new Short(&quot;12&quot;); Short s3 = new Short(&quot;12&quot;); System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2)); System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1)); System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3)); System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3)); System.out.println();  char c1 = &#x27;A&#x27;; Character c2 = new Character(&#x27;A&#x27;); Character c3 = new Character(&#x27;A&#x27;); System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2)); System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1)); System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3)); System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3)); System.out.println();  int i1 = 10000; Integer i2 = new Integer(10000); Integer i3 = new Integer(10000); System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2)); System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1)); System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3)); System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3)); System.out.println();  long l1 = 1000000000000000L; Long l2 = new Long(&quot;1000000000000000&quot;); Long l3 = new Long(&quot;1000000000000000&quot;); System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2)); System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1)); System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3)); System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3)); System.out.println();  float f1 = 10000.111F; Float f2 = new Float(&quot;10000.111&quot;); Float f3 = new Float(&quot;10000.111&quot;); System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2)); System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1)); System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3)); System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3)); System.out.println();  double d1 = 10000.111; Double d2 = new Double(&quot;10000.111&quot;); Double d3 = new Double(&quot;10000.111&quot;); System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2)); System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1)); System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3)); System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3)); System.out.println();  boolean bl1 = true; Boolean bl2 = new Boolean(&quot;true&quot;); Boolean bl3 = new Boolean(&quot;true&quot;); System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2)); System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1)); System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3)); System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;br&gt; 运行结果&lt;/p&gt;  &lt;pre&gt; &lt;code&gt;Byte 基本类型和包装对象使用 == 比较 : true Byte 基本类型和包装对象使用 equals 比较 : true Byte 包装对象和包装对象使用 == 比较 : false Byte 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Short 基本类型和包装对象使用 == 比较 : true Short 基本类型和包装对象使用 equals 比较 : true Short 包装对象和包装对象使用 == 比较 : false Short 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Character 基本类型和包装对象使用 == 比较 : true Character 基本类型和包装对象使用 equals 比较 : true Character 包装对象和包装对象使用 == 比较 : false Character 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Integer 基本类型和包装对象使用 == 比较 : true Integer 基本类型和包装对象使用 equals 比较 : true Integer 包装对象和包装对象使用 == 比较 : false Integer 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Long 基本类型和包装对象使用 == 比较 : true Long 基本类型和包装对象使用 equals 比较 : true Long 包装对象和包装对象使用 == 比较 : false Long 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Float 基本类型和包装对象使用 == 比较 : true Float 基本类型和包装对象使用 equals 比较 : true Float 包装对象和包装对象使用 == 比较 : false Float 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Double 基本类型和包装对象使用 == 比较 : true Double 基本类型和包装对象使用 equals 比较 : true Double 包装对象和包装对象使用 == 比较 : false Double 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Boolean 基本类型和包装对象使用 == 比较 : true Boolean 基本类型和包装对象使用 equals 比较 : true Boolean 包装对象和包装对象使用 == 比较 : false Boolean 包装对象和包装对象使用 equals 比较 : true&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt;  &lt;p&gt;ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程&lt;/p&gt;</span><br><span class="line">什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？ Java基础   &lt;p&gt;装箱：基本类型转变为包装器类型的过程。&lt;br&gt; 拆箱：包装器类型转变为基本类型的过程。&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须 Integer i = new Integer(8); &amp;nbsp; //JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样 Integer i = 8; &amp;nbsp; int n = i;//自动拆箱&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、装箱和拆箱的执行过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;装箱是通过调用包装器类的 valueOf 方法实现的&lt;/li&gt;   &lt;li&gt;拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。&lt;/li&gt;   &lt;li&gt;如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;3、常见问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。&lt;/li&gt;   &lt;li&gt;浮点型的包装类 valueOf 方法返回新的对象。&lt;/li&gt;   &lt;li&gt;布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;实验代码&lt;/p&gt;  &lt;pre&gt; &lt;code&gt;Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1 == i2);//true System.out.println(i3 == i4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Double d1 = 100.0; Double d2 = 100.0; Double d3 = 200.0; Double d4 = 200.0; System.out.println(d1 == d2);//false System.out.println(d3 == d4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Boolean b1 = false; Boolean b2 = false; Boolean b3 = true; Boolean b4 = true; System.out.println(b1 == b2);//true System.out.println(b3 == b4);//true&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;包含算术运算会触发自动拆箱。&lt;/li&gt;   &lt;li&gt;存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;Integer s1 = 0; long t1 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s1 += i; &#125; long t2 = System.currentTimeMillis(); System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; int s2 = 0; long t3 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s2 += i; &#125; long t4 = System.currentTimeMillis(); System.out.println(&quot;使用int，递增相加耗时：&quot; + (t4 - t3));//使用int，递增相加耗时：6&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">hashCode()相同，equals()也一定为true吗？ Java基础 &lt;p&gt;首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。&lt;/li&gt;   &lt;li&gt;hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;关于 hashCode() 和 equals() 是方法是有一些 常规协定：&lt;/p&gt;  &lt;p&gt;1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。&lt;/p&gt;  &lt;p&gt;2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。&lt;/p&gt;  &lt;p&gt;3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;就像打人是你的能力，但打伤了就违法了。重写 equals 和 hashCode 方法返回是否为 true 是你的能力，但你不按照上述协议进行控制，在用到对象 hash 和 equals 逻辑判断相等时会出现意外情况，如 HashMap 的 key 是否相等。&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">final在java中的作用 Java基础   &lt;ul&gt;   &lt;li&gt;被 final 修饰的类，不能够被继承&lt;/li&gt;   &lt;li&gt;被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象&lt;/li&gt;   &lt;li&gt;被 final 修饰的方法不能重写&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">final finally finalize()区别 Java基础 &lt;ul&gt;   &lt;li&gt;final 表示最终的、不可改变的。用于修饰类、方法和变量。final 修饰的类不能被继承；final 方法也同样只能使用，不能重写，但能够重载；final 修饰的成员变量必须在声明时给定初值或者在构造方法内设置初始值，只能读取，不可修改；final 修饰的局部变量必须在声明时给定初值；final 修饰的变量是非基本类型，对象的引用地址不能变，但对象的属性值可以改变&lt;/li&gt;   &lt;li&gt;finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）&lt;/li&gt;   &lt;li&gt;finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。&lt;/li&gt;  &lt;/ul&gt;  </span><br><span class="line">finally语句块一定执行吗？ Java基础   &lt;ul&gt;   &lt;li&gt;直接返回未执行到 try-finally 语句块&lt;/li&gt;   &lt;li&gt;抛出异常未执行到 try-finally 语句块&lt;/li&gt;   &lt;li&gt;系统退出未执行到 finally 语句块&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;等...&lt;/p&gt;  &lt;p&gt;代码如下&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;public static String test() &#123;     String str = null;     int i = 0;     if (i == 0) &#123;         return str;//直接返回未执行到finally语句块     &#125;     try &#123;         System.out.println(&quot;try...&quot;);         return str;     &#125; finally &#123;         System.out.println(&quot;finally...&quot;);     &#125; &#125;   public static String test2() &#123;     String str = null;     int i = 0;     i = i / 0;//抛出异常未执行到finally语句块     try &#123;         System.out.println(&quot;try...&quot;);         return str;     &#125; finally &#123;         System.out.println(&quot;finally...&quot;);     &#125; &#125;   public static String test3() &#123;     String str = null;     try &#123;         System.out.println(&quot;try...&quot;);         System.exit(0);//系统退出未执行到finally语句块         return str;     &#125; finally &#123;         System.out.println(&quot;finally...&quot;);     &#125; &#125;&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">final与static的区别 Java基础   &lt;ul&gt;   &lt;li&gt;都可以修饰类、方法、成员变量。&lt;/li&gt;   &lt;li&gt;都不能用于修饰构造方法。&lt;/li&gt;   &lt;li&gt;static 可以修饰类的代码块，final 不可以。&lt;/li&gt;   &lt;li&gt;static 不可以修饰方法内的局部变量，final 可以。&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;static：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;static 修饰表示静态或全局，被修饰的属性和方法属于类，可以用类名.静态属性 / 方法名 访问&lt;/li&gt;   &lt;li&gt;static 修饰的代码块表示静态代码块，当 Java 虚拟机（JVM）加载类时，就会执行该代码块,只会被执行一次&lt;/li&gt;   &lt;li&gt;static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，只会被创建一次&lt;/li&gt;   &lt;li&gt;static 修饰的变量可以重新赋值&lt;/li&gt;   &lt;li&gt;static 方法中不能用 this 和 super 关键字&lt;/li&gt;   &lt;li&gt;static 方法必须被实现，而不能是抽象的abstract&lt;/li&gt;   &lt;li&gt;static 方法不能被重写&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;final：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;final 修饰表示常量、一旦创建不可改变&lt;/li&gt;   &lt;li&gt;final 标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可以重新赋值&lt;/li&gt;   &lt;li&gt;final 方法不能被子类重写&lt;/li&gt;   &lt;li&gt;final 类不能被继承，没有子类，final 类中的方法默认是 final 的&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;final 和 static 修饰成员变量加载过程例子&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;import java.util.Random;   public class TestStaticFinal &#123;   public static void main(String[] args) &#123; StaticFinal sf1 = new StaticFinal(); StaticFinal sf2 = new StaticFinal();  System.out.println(sf1.fValue == sf2.fValue);//打印false System.out.println(sf1.sValue == sf2.sValue);//打印true &#125; &#125;   class StaticFinal &#123;  final int fValue = new Random().nextInt(); static int sValue = new Random().nextInt();  &#125;&lt;/code&gt;&lt;/pre&gt;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MarkDown 编辑器&lt;/p&gt;
&lt;h3 id=&quot;方式一：MarkDown-编辑器&quot;&gt;&lt;a href=&quot;#方式一：MarkDown-编辑器&quot; class=&quot;headerlink&quot; title=&quot;方式一：MarkDown 编辑器&quot;&gt;&lt;/a&gt;方式一：MarkDown 编辑器&lt;/</summary>
      
    
    
    
    <category term="资料整理" scheme="https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Anki" scheme="https://gitflhub.github.io/tags/Anki/"/>
    
  </entry>
  
</feed>
