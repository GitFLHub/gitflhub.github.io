<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RON BLOG</title>
  
  <subtitle>Ron, open the door.</subtitle>
  <link href="https://gitflhub.github.io/atom.xml" rel="self"/>
  
  <link href="https://gitflhub.github.io/"/>
  <updated>2021-10-21T01:35:21.508Z</updated>
  <id>https://gitflhub.github.io/</id>
  
  <author>
    <name>Ron</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Transformer 的 Position Embedding 理解</title>
    <link href="https://gitflhub.github.io/2021/10/21/Transformer%20%E7%9A%84%20Position%20Embedding%20%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>https://gitflhub.github.io/2021/10/21/Transformer%20%E7%9A%84%20Position%20Embedding%20%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-10-21T00:20:48.000Z</published>
    <updated>2021-10-21T01:35:21.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p>视频：Bilibili:<a href="https://www.bilibili.com/video/BV1ff4y1a7VL?from=search&amp;seid=16603844718264150058&amp;spm_id_from=333.337.0.0">Transformer的位置编码（Position Encoding）进展梳理_哔哩哔哩_bilibili</a></p><p>笔记：<a href="extension://oikmahiipjniocckomdccmplodldodja/pdf-viewer/web/viewer.html?file=https%3A%2F%2Fml-researcher.github.io%2Ffile%2FPosEnc.pdf">PosEnc</a></p><h3 id="模型示例"><a href="#模型示例" class="headerlink" title="模型示例:"></a>模型示例:</h3><p><img src="https://img.ron.zone/image-20211014193447739.png" alt="image-20211014193447739"></p><h3 id="位置编码公式："><a href="#位置编码公式：" class="headerlink" title="位置编码公式："></a>位置编码公式：</h3><script type="math/tex; mode=display">PE_{(k, 2i)} = \sin(k/10000^{\frac{2i}{d_{model}}})\\PE_{(k, 2i + 1)} = \cos(k/10000^{\frac{2i}{d_{model}}})\\k :{元素在序列中位置} \\i:{用于表示列数}\\d_{model}:模型的维数</script><h3 id="公式理解"><a href="#公式理解" class="headerlink" title="公式理解:"></a>公式理解:</h3><p>在Transformer中，输入Encoder或者Decoder中的向量为 Embedding Vector + Position Embedding Vector。</p><p>将 Embedding Vector 和 Position Embedding Vector 分别表示为$e_i$和$p_i$。</p><p>后续的计算过程可以视为</p><script type="math/tex; mode=display">\begin{equation}\begin{split} (e_i + p_i)^TW_Q^TW_k(e_j+p_j)&=e_i^TW_Q^TW_ke_j+p_i^TW_Q^TW_ke_j\\&+e_i^TW_Q^TW_kp_j+p_i^TW_Q^TW_kp_j\end{split}\end{equation}</script><p>$e_i^TW_Q^TW_ke_j$ 是表示词向量之间的运算</p><p>$p_i^TW_Q^TW_ke_j$ 和$e_i^TW_Q^TW_kp_j$分别包含了两个词向量的绝对位置的信息</p><p>$p_i^TW_Q^TW_kp_j$简化看成为$p_i^Tp_j$。现在想要将其转化为和<strong>相对位置</strong>有关的向量，即$i-j$的形式</p><p>又因为</p><script type="math/tex; mode=display">\begin{equation}\begin{split}p_i^Tp_j&=(p_{i1},p_{i2},...,p_{id_{model}})^T(p_{j1},p_{j2},...,p_{jd_{model}})\\&=p_{i1}p_{j1}+p_{i2}p_{j2}+...+p_{id_{model}}p_{jd_{model}}\end{split}\end{equation}</script><p>再结合</p><script type="math/tex; mode=display">PE_{(k, 2i)} = \sin(k/10000^{\frac{2i}{d_{model}}})\\PE_{(k, 2i + 1)} = \cos(k/10000^{\frac{2i}{d_{model}}})</script><p>可以理解为</p><script type="math/tex; mode=display">\begin{equation}\begin{split}p_i^Tp_j&=(p_{i1},p_{i2},...,p_{id_{model}})^T(p_{j1},p_{j2},...,p_{jd_{model}})\\&=p_{i1}p_{j1}+p_{i2}p_{j2}+...+p_{id_{model}}p_{jd_{model}}\\&=\cos(i/10000^{\frac{2*1}{d_{model}}})\cos(j/10000^{\frac{2*1}{d_{model}}}) + \sin(i/10000^{\frac{2*1}{d_{model}}})\sin(j/10000^{\frac{2*1}{d_{model}}})+...\\&=cos((i-j)/10000^{\frac{2*1}{d_{model}}}) + cos((i-j)/10000^{\frac{2*2}{d_{model}}}) + ... + cos((i-j)/10000^{\frac{2*d_{model}/2}{d_{model}}})\\&=g(i-j)\end{split}\end{equation}</script><p>于是最终被表示成了相对位置的形式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;参考链接：&quot;&gt;&lt;a href=&quot;#参考链接：&quot; class=&quot;headerlink&quot; title=&quot;参考链接：&quot;&gt;&lt;/a&gt;参考链接：&lt;/h3&gt;&lt;p&gt;视频：Bilibili:&lt;a href=&quot;https://www.bilibili.com/video/BV1ff4</summary>
      
    
    
    
    
    <category term="NLP" scheme="https://gitflhub.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>PCA</title>
    <link href="https://gitflhub.github.io/2021/09/14/PCA/"/>
    <id>https://gitflhub.github.io/2021/09/14/PCA/</id>
    <published>2021-09-14T12:22:08.000Z</published>
    <updated>2021-09-14T12:25:49.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_pca</span>(<span class="params">X, n_components=<span class="number">2</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Input:</span></span><br><span class="line"><span class="string">        X: of dimension (m,n) where each row corresponds to a word vector</span></span><br><span class="line"><span class="string">        n_components: Number of components you want to keep.</span></span><br><span class="line"><span class="string">    Output:</span></span><br><span class="line"><span class="string">        X_reduced: data transformed in 2 dims/columns + regenerated original data</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment">### START CODE HERE (REPLACE INSTANCES OF &#x27;None&#x27; with your code) ###</span></span><br><span class="line">    <span class="comment"># mean center the data</span></span><br><span class="line">    X_demeaned = X- np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># calculate the covariance matrix</span></span><br><span class="line">    covariance_matrix = np.cov(X_demeaned, rowvar=<span class="literal">False</span>) <span class="comment"># 计算协方差采用的是去平均值矩阵，还要添加rowvar参数</span></span><br><span class="line">    <span class="comment"># calculate eigenvectors &amp; eigenvalues of the covariance matrix</span></span><br><span class="line">    eigen_vals, eigen_vecs = np.linalg.eigh(covariance_matrix)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># sort eigenvalue in increasing order (get the indices from the sort)</span></span><br><span class="line">    idx_sorted = np.argsort(eigen_vals)</span><br><span class="line">    <span class="comment"># reverse the order so that it&#x27;s from highest to lowest.</span></span><br><span class="line">    idx_sorted_decreasing = np.argsort(-eigen_vals)</span><br><span class="line">    <span class="comment"># sort the eigen values by idx_sorted_decreasing</span></span><br><span class="line">    eigen_vals_sorted = eigen_vals[idx_sorted_decreasing]</span><br><span class="line">    <span class="comment"># sort eigenvectors using the idx_sorted_decreasing indices</span></span><br><span class="line">    eigen_vecs_sorted = eigen_vecs[:,idx_sorted_decreasing] <span class="comment"># 选取特征向量的时候注意要采用matrix[:,排序索引] 不可采用 matrix[排序索引] 因为调整的是列向量的顺序</span></span><br><span class="line">    <span class="comment"># select the first n eigenvectors (n is desired dimension</span></span><br><span class="line">    <span class="comment"># of rescaled data array, or dims_rescaled_data)</span></span><br><span class="line">    eigen_vecs_subset = eigen_vecs_sorted[:,<span class="number">0</span>:n_components]</span><br><span class="line">    <span class="comment"># transform the data by multiplying the transpose of the eigenvectors </span></span><br><span class="line">    <span class="comment"># with the transpose of the de-meaned data</span></span><br><span class="line">    <span class="comment"># Then take the transpose of that product.</span></span><br><span class="line">    X_reduced = np.dot(X_demeaned, eigen_vecs_subset)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">### END CODE HERE ###</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> X_reduced</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PCA&quot;&gt;&lt;a href=&quot;#PCA&quot; class=&quot;headerlink&quot; title=&quot;PCA&quot;&gt;&lt;/a&gt;PCA&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="categories" scheme="https://gitflhub.github.io/categories/categories/"/>
    
    
    <category term="机器学习" scheme="https://gitflhub.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="PCA" scheme="https://gitflhub.github.io/tags/PCA/"/>
    
  </entry>
  
  <entry>
    <title>Anki 常用插件</title>
    <link href="https://gitflhub.github.io/2021/07/06/Anki%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://gitflhub.github.io/2021/07/06/Anki%20%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2021-07-06T02:44:21.000Z</published>
    <updated>2021-07-06T03:06:58.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anki-插件推荐"><a href="#Anki-插件推荐" class="headerlink" title="Anki 插件推荐"></a>Anki 插件推荐</h2><div class="table-container"><table><thead><tr><th>Anki 插件名称</th><th>插件介绍</th><th>插件ID</th></tr></thead><tbody><tr><td>AnkiConnect</td><td>实现 Anki 与外界通信</td><td>2055492159</td></tr><tr><td>Enhance main window</td><td>增强主页</td><td>877182321</td></tr><tr><td>Review Heatmap</td><td>复习热力图，记录学习日历</td><td>1771074083</td></tr><tr><td>Evernote Importer</td><td>支持印象笔记</td><td>831016260</td></tr><tr><td>Markdown and KaTeX Support</td><td>支持 MarkDown 和数学公式</td><td>1087328706</td></tr><tr><td>Word Query</td><td>(查询大卡片单词词义音标等)</td><td>775418273</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Anki-插件推荐&quot;&gt;&lt;a href=&quot;#Anki-插件推荐&quot; class=&quot;headerlink&quot; title=&quot;Anki 插件推荐&quot;&gt;&lt;/a&gt;Anki 插件推荐&lt;/h2&gt;&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;</summary>
      
    
    
    
    <category term="资料整理" scheme="https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Anki" scheme="https://gitflhub.github.io/tags/Anki/"/>
    
    <category term="浏览器插件" scheme="https://gitflhub.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>开源数据集</title>
    <link href="https://gitflhub.github.io/2021/07/05/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>https://gitflhub.github.io/2021/07/05/%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E9%9B%86/</id>
    <published>2021-07-05T13:49:03.000Z</published>
    <updated>2021-07-06T00:49:20.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开放数据集"><a href="#开放数据集" class="headerlink" title="开放数据集"></a>开放数据集</h2><p>•     DataHub (<a href="http://datahub.io/dataset">http://datahub.io/dataset</a>)<br>•     World Health Organization (<a href="http://www.who.int/research/en/">http://www.who.int/research/en/</a>)<br>•     Data.gov (<a href="http://data.gov">http://data.gov</a>)<br>•     European Union Open Data Portal (<a href="http://open-data.europa.eu/en/data/">http://open-data.europa.eu/en/data/</a>)<br>•     Amazon Web Service public datasets (<a href="http://aws.amazon.com/datasets">http://aws.amazon.com/datasets</a>)<br>•     Facebook Graph (<a href="http://developers.facebook.com/docs/graph-api">http://developers.facebook.com/docs/graph-api</a>)<br>•     Healthdata.gov (<a href="http://www.healthdata.gov">http://www.healthdata.gov</a>)<br>•     Google Trends (<a href="http://www.google.com/trends/explore">http://www.google.com/trends/explore</a>)<br>•     Google Finance (<a href="https://www.google.com/finance">https://www.google.com/finance</a>)<br>•     Google Books Ngrams (<a href="http://storage.googleapis.com/books/ngrams/books/datasetsv2.html">http://storage.googleapis.com/books/ngrams/books/datasetsv2.html</a>)<br>•     Machine Learning Repository (<a href="http://archive.ics.uci.edu/ml/">http://archive.ics.uci.edu/ml/</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开放数据集&quot;&gt;&lt;a href=&quot;#开放数据集&quot; class=&quot;headerlink&quot; title=&quot;开放数据集&quot;&gt;&lt;/a&gt;开放数据集&lt;/h2&gt;&lt;p&gt;•     DataHub (&lt;a href=&quot;http://datahub.io/dataset&quot;&gt;http://</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="开放数据集" scheme="https://gitflhub.github.io/tags/%E5%BC%80%E6%94%BE%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning</title>
    <link href="https://gitflhub.github.io/2021/07/05/Machine%20Learning/"/>
    <id>https://gitflhub.github.io/2021/07/05/Machine%20Learning/</id>
    <published>2021-07-05T13:01:42.000Z</published>
    <updated>2021-07-15T03:57:07.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习库"><a href="#学习库" class="headerlink" title="学习库"></a>学习库</h1><p>Numpy 科学计算库</p><p>Pandas 数据分析可视化</p><p>Matplotlib 数据可视化</p><p>Scikit-learn 机器学习库</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>数组</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>分类：最终属于1还是0</p><p>回归：最终一个具体值</p><h4 id="例子1：房价预测（回归）"><a href="#例子1：房价预测（回归）" class="headerlink" title="例子1：房价预测（回归）"></a>例子1：房价预测（回归）</h4><p><img src="http://img.ron.zone/20210527232253.png" alt="image-20210429100557314-1620280617770"></p><h4 id="例子2：肿瘤预测（分类）"><a href="#例子2：肿瘤预测（分类）" class="headerlink" title="例子2：肿瘤预测（分类）"></a>例子2：肿瘤预测（分类）</h4><p>一个属性</p><p><img src="http://img.ron.zone/20210527232327.png" alt="image-20210429100923353"></p><p>两个属性（特征）</p><p><img src="http://img.ron.zone/20210527232314.png" alt="image-20210429101713120"></p><p>无穷多特征：向量机</p><h4 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h4><h5 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h5><p><img src="http://img.ron.zone/20210527232337.png" alt="image-20210429105008588"></p><p><img src="http://img.ron.zone/20210527232346.png" /></p><p><img src="http://img.ron.zone/20210527232354.png" alt="image-20210429105552665"></p><p>一个参数的代价函数可以化为一个一元二次函数</p><p>两个参数的代价函数可以化为一个二元二次函数</p><p>更多参数可以考虑梯度下降的方式</p><p><img src="http://img.ron.zone/20210527232404.png" alt="image-20210429163240652"></p><p>梯度下降需要考虑步伐大小，大小学习速率过慢，太大会错过最优解，甚至会导致发散</p><p><img src="http://img.ron.zone/20210527232414.png" alt="image-20210429164519908"></p><p>步长α是动态调整的， </p><p>梯度下降只适用于求解线性回归。（为弓形图像）</p><p><img src="http://img.ron.zone/20210527232425.png" alt="image-20210429170959267"></p><h5 id="多元梯度下降"><a href="#多元梯度下降" class="headerlink" title="多元梯度下降"></a>多元梯度下降</h5><p><img src="http://img.ron.zone/20210527232437.png" alt="image-20210430164149341"></p><h5 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h5><p><img src="http://img.ron.zone/20210527232448.png" alt="image-20210430165959029"></p><p>也可以采取减去均值再除以范围</p><p><img src="http://img.ron.zone/20210527232506.png" alt="image-20210430170710002"></p><p>特征或多项式回归</p><h5 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程<img src="http://img.ron.zone/20210527232516.png" alt="image-20210430174937134"></h5><p>如果X ^ TX是不可逆的，常见的原因可能是:</p><ul><li><p>冗余特征，即两个特征密切相关(即线性相关)</p></li><li><p>太多的特性(例如m≤n)。在这种情况下，删除一些特性或使用“正则化”</p></li></ul><h5 id="正规方程和梯度下降比较"><a href="#正规方程和梯度下降比较" class="headerlink" title="正规方程和梯度下降比较"></a>正规方程和梯度下降比较</h5><div class="table-container"><table><thead><tr><th style="text-align:left">梯度下降</th><th style="text-align:left">正规方程需要</th></tr></thead><tbody><tr><td style="text-align:left">需要选择确定学习速率α</td><td style="text-align:left">不需要选择确定学习速率α</td></tr><tr><td style="text-align:left">需要多次迭代</td><td style="text-align:left">不需要迭代</td></tr><tr><td style="text-align:left">O (kn^2)</td><td style="text-align:left">O (n^3), 需要计算 X^TX的逆矩阵</td></tr><tr><td style="text-align:left">n 非常大时任然适用</td><td style="text-align:left">n太大计算缓慢</td></tr></tbody></table></div><p>聚类算法</p><p><img src="http://img.ron.zone/20210527232523.png" alt="image-20210429102250061"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;学习库&quot;&gt;&lt;a href=&quot;#学习库&quot; class=&quot;headerlink&quot; title=&quot;学习库&quot;&gt;&lt;/a&gt;学习库&lt;/h1&gt;&lt;p&gt;Numpy 科学计算库&lt;/p&gt;
&lt;p&gt;Pandas 数据分析可视化&lt;/p&gt;
&lt;p&gt;Matplotlib 数据可视化&lt;/p&gt;
&lt;p&gt;S</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Machine Learning" scheme="https://gitflhub.github.io/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Vocabulary</title>
    <link href="https://gitflhub.github.io/2021/06/03/Vocabulary/"/>
    <id>https://gitflhub.github.io/2021/06/03/Vocabulary/</id>
    <published>2021-06-03T09:17:43.000Z</published>
    <updated>2021-07-05T14:06:57.273Z</updated>
    
    <content type="html"><![CDATA[<p>threshold</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;threshold&lt;/p&gt;
</summary>
      
    
    
    
    <category term="English" scheme="https://gitflhub.github.io/categories/English/"/>
    
    
    <category term="生词" scheme="https://gitflhub.github.io/tags/%E7%94%9F%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Octave 基础</title>
    <link href="https://gitflhub.github.io/2021/05/31/Octave-%E5%9F%BA%E7%A1%80/"/>
    <id>https://gitflhub.github.io/2021/05/31/Octave-%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-31T13:01:42.000Z</published>
    <updated>2021-05-31T13:03:42.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="1-Octave"><a href="#1-Octave" class="headerlink" title="1. Octave"></a>1. Octave</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container"><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>svd</td><td>(singular value decomposition) 奇异值分解</td></tr><tr><td>pinv</td><td>求逆矩阵</td></tr><tr><td>inv</td><td>伪逆矩阵</td></tr><tr><td>‘</td><td>转置</td></tr><tr><td>^</td><td>指数运算</td></tr><tr><td>==</td><td>bool判断</td></tr><tr><td>~=</td><td>不等于判断</td></tr><tr><td>&amp;&amp;</td><td>逻辑与</td></tr><tr><td>“双竖杠” 或 xor</td><td>逻辑或</td></tr><tr><td>PS1(“&gt;&gt; “)</td><td>定义默认的提示符</td></tr><tr><td>=</td><td>赋值</td></tr><tr><td>pi</td><td>圆周率</td></tr><tr><td>disp</td><td>打印字符串</td></tr><tr><td>sprintf</td><td>拼接字符串</td></tr><tr><td>format long</td><td>默认long型字符串</td></tr><tr><td>format short</td><td>默认short型字符串</td></tr><tr><td>A = [1 2; 3 4; 5 6]</td><td>定义矩阵</td></tr><tr><td>v = 1:0.1:2</td><td>从1到2，生成步长为0.1的数组</td></tr><tr><td>ones(2,3)</td><td>生成两行三列的1矩阵</td></tr><tr><td>zeros(1, 3)</td><td>生成一行三列的零矩阵</td></tr><tr><td>rand(1,3)</td><td>随机生成一行三列的行矩阵</td></tr><tr><td>randn(1,3)</td><td>生成三个符合方差，标准差为1的正态分布的随机数</td></tr><tr><td>hist(数组，默认5柱)</td><td>生成样本直方图</td></tr><tr><td>hist(数组,  50)</td><td>生成50柱直方图</td></tr><tr><td>eye(4)</td><td>四阶单位矩阵</td></tr><tr><td>help eye</td><td>查看eye指令的用法</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>size(A)</td><td>查看矩阵的大小，1x2的矩阵</td></tr><tr><td>size(A，n)</td><td>返回矩阵的第n个纬度大小</td></tr><tr><td>length(v)</td><td>最大维度的大小</td></tr></tbody></table></div><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><div class="table-container"><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>pwd</td><td>Octave当前路径</td></tr><tr><td>cd</td><td>改变路径</td></tr><tr><td>ls</td><td>列出当前路径文件</td></tr><tr><td>load feature.dat 或 load（‘feature.dat’）</td><td>加载文件</td></tr><tr><td>who</td><td>查看当前变量</td></tr><tr><td>whos</td><td>查看当前变量详情，大小，类别</td></tr><tr><td>clear featurex</td><td>删除 featurex</td></tr><tr><td>save hello.mat v;</td><td>将v写入hello.mat文件中</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h2&gt;&lt;h3 id=&quot;1-Octave&quot;&gt;&lt;a href=&quot;#1-Octave&quot; class=&quot;headerlink&quot; title=&quot;1. Octave</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Octave" scheme="https://gitflhub.github.io/tags/Octave/"/>
    
    <category term="工具" scheme="https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Octave 绘制图像</title>
    <link href="https://gitflhub.github.io/2021/05/28/Octave%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/"/>
    <id>https://gitflhub.github.io/2021/05/28/Octave%20%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F/</id>
    <published>2021-05-28T13:01:42.000Z</published>
    <updated>2021-07-15T03:55:58.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Octace-绘制图像"><a href="#Octace-绘制图像" class="headerlink" title="Octace 绘制图像"></a>Octace 绘制图像</h2><h3 id="二维图像"><a href="#二维图像" class="headerlink" title="二维图像"></a>二维图像</h3><h4 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 生成从<span class="number">0</span> 到 <span class="number">0.98</span> 的数组，步长为<span class="number">0.01</span></span><br><span class="line">t = [<span class="number">0</span>:<span class="number">0.01</span>:<span class="number">0.98</span>]; </span><br><span class="line"># 构造y1 和 t的关系式</span><br><span class="line">y1 = <span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">4</span>*t); </span><br><span class="line"># 生成二维图像</span><br><span class="line"><span class="built_in">plot</span>(t,y1); </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527232137.png" alt="image-20210527181550349"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 构造y21 和 t的关系式</span><br><span class="line">y2 = <span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>*<span class="number">4</span>*t); </span><br><span class="line"># 生成二维图像</span><br><span class="line"><span class="built_in">plot</span>(t,y2); </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527232146.png" alt="image-20210527182145214"></p><p>在原有基础上添加第一个图像</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 保留绘制的第一个图</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"># 继续绘制第二个图</span><br><span class="line"><span class="built_in">plot</span>(t,y1,<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527234311.png" alt="image-20210527234250205"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># x轴标签</span><br><span class="line">xlabel(<span class="string">&#x27;time&#x27;</span>) </span><br><span class="line"># y轴标签</span><br><span class="line">ylabel(<span class="string">&#x27;value&#x27;</span>) </span><br><span class="line"># 线型标注</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;sin&#x27;</span>,<span class="string">&#x27;cos&#x27;</span>) </span><br><span class="line"># 图表名称</span><br><span class="line">title(<span class="string">&#x27;my plot&#x27;</span>) </span><br><span class="line"># 输出图片</span><br><span class="line">print -dpng <span class="string">&#x27;myplot.png&#x27;</span> </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210527235221.png" alt="image-20210527235201685"></p><h4 id="显示多个图像"><a href="#显示多个图像" class="headerlink" title="显示多个图像"></a>显示多个图像</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 分割出第一个子图 <span class="number">1</span> * <span class="number">2</span> 两个子图</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>); </span><br><span class="line"># 填充第一个子图</span><br><span class="line"><span class="built_in">plot</span>(t,y1); </span><br><span class="line"># 分割出第二个子图</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"># 填充第二个子图</span><br><span class="line"><span class="built_in">plot</span>(t,y2);</span><br><span class="line"># 设置第二个子图的坐标轴范围</span><br><span class="line">axis([<span class="number">0.5</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>]) </span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/20210528000519.png" alt="image-20210528000514488"></p><h4 id="矩阵图示"><a href="#矩阵图示" class="headerlink" title="矩阵图示"></a>矩阵图示</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 随机生成<span class="number">5</span>*<span class="number">5</span>矩阵</span><br><span class="line">A = <span class="built_in">magic</span>(<span class="number">5</span>)</span><br><span class="line"># 图示矩阵</span><br><span class="line">imagesc(A)</span><br><span class="line">A =</span><br><span class="line">   <span class="number">17</span>   <span class="number">24</span>    <span class="number">1</span>    <span class="number">8</span>   <span class="number">15</span></span><br><span class="line">   <span class="number">23</span>    <span class="number">5</span>    <span class="number">7</span>   <span class="number">14</span>   <span class="number">16</span></span><br><span class="line">    <span class="number">4</span>    <span class="number">6</span>   <span class="number">13</span>   <span class="number">20</span>   <span class="number">22</span></span><br><span class="line">   <span class="number">10</span>   <span class="number">12</span>   <span class="number">19</span>   <span class="number">21</span>    <span class="number">3</span></span><br><span class="line">   <span class="number">11</span>   <span class="number">18</span>   <span class="number">25</span>    <span class="number">2</span>    <span class="number">9</span></span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/image-20210528001441719.png" alt="image-20210528001441719"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A =</span><br><span class="line">   <span class="number">17</span>   <span class="number">24</span>    <span class="number">1</span>    <span class="number">8</span>   <span class="number">15</span></span><br><span class="line">   <span class="number">23</span>    <span class="number">5</span>    <span class="number">7</span>   <span class="number">14</span>   <span class="number">16</span></span><br><span class="line">    <span class="number">4</span>    <span class="number">6</span>   <span class="number">13</span>   <span class="number">20</span>   <span class="number">22</span></span><br><span class="line">   <span class="number">10</span>   <span class="number">12</span>   <span class="number">19</span>   <span class="number">21</span>    <span class="number">3</span></span><br><span class="line">   <span class="number">11</span>   <span class="number">18</span>   <span class="number">25</span>    <span class="number">2</span>    <span class="number">9</span></span><br><span class="line"># 组合命令 colorbar 生成条状尺度图 gray 灰度图</span><br><span class="line">imagesc(A), colorbar, colormap gray;</span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/image-20210528002043991.png" alt="image-20210528002043991"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 更大的尺度图</span><br><span class="line">imagesc(<span class="built_in">magic</span>(<span class="number">25</span>)), colorbar, colormap gray;</span><br></pre></td></tr></table></figure><p><img src="http://img.ron.zone/image-20210528002258670.png" alt="image-20210528002258670"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Octace-绘制图像&quot;&gt;&lt;a href=&quot;#Octace-绘制图像&quot; class=&quot;headerlink&quot; title=&quot;Octace 绘制图像&quot;&gt;&lt;/a&gt;Octace 绘制图像&lt;/h2&gt;&lt;h3 id=&quot;二维图像&quot;&gt;&lt;a href=&quot;#二维图像&quot; class=&quot;</summary>
      
    
    
    
    <category term="AI" scheme="https://gitflhub.github.io/categories/AI/"/>
    
    
    <category term="Octave" scheme="https://gitflhub.github.io/tags/Octave/"/>
    
    <category term="工具" scheme="https://gitflhub.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JAVA虚拟机基础概念</title>
    <link href="https://gitflhub.github.io/2021/05/27/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://gitflhub.github.io/2021/05/27/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-05-27T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:06.737Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.ron.zone/oneblog/article/20210319023906389.png" alt="file"></p><h3 id="类装载子系统"><a href="#类装载子系统" class="headerlink" title="类装载子系统"></a>类装载子系统</h3><p>将编译好的.class文件装载到运行时数据区</p><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>new 出来的对象放在内存堆<br>首先是新生代的伊甸园区，然后minor gc 定期检查该（伊甸园区和survivor区）对象，检查后将有用对象将对象放入另一个 survivor 区域<br>伊甸园：Survivor ：Survivor = 8 : 1: 1<br>当Survivor 区中的年代数达到15， 则会被移入老年代，新生代放中Survivor 对象大小超过Survivor大小的50%，也会直接被放入老年代<br><img src="http://img.ron.zone/oneblog/article/20210319025844233.png" alt="file"></p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>栈帧：<br>调用一个方法，生成自己专属的内存空间（栈帧），符合FILO，<br>存放局部变量、操作数、动态链接、方法出口</p><p>例如java源代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tuling.redission;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intData = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c =(a + b) * <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Math math = <span class="keyword">new</span> Math();</span><br><span class="line">        System.out.println(math.compute());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>可使用cmd命令来反汇编class文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c xxx.class &gt; xxx.txt</span><br></pre></td></tr></table></figure><br>得到该目录下的反汇编指令文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;Math.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tuling</span>.<span class="title">redission</span>.<span class="title">Math</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> intData;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.tuling.redission.HelloWorld helloWorld;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.tuling.redission.Math();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">   <span class="number">0</span>: iconst_1 </span><br><span class="line">       <span class="number">1</span>: istore_1</span><br><span class="line">       <span class="number">2</span>: iconst_2</span><br><span class="line">       <span class="number">3</span>: istore_2</span><br><span class="line">       <span class="number">4</span>: iload_1</span><br><span class="line">       <span class="number">5</span>: iload_2</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: bipush        <span class="number">10</span></span><br><span class="line">       <span class="number">9</span>: imul</span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_3</span><br><span class="line">      <span class="number">12</span>: <span class="function">ireturn</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class com/tuling/redission/Math</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method compute:()I</span></span><br><span class="line">      <span class="number">15</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">      <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">7</span>                  <span class="comment">// class com/tuling/redission/HelloWorld</span></span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       <span class="number">4</span>: invokespecial #<span class="number">8</span>                  <span class="comment">// Method com/tuling/redission/HelloWorld.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">7</span>: putstatic     #<span class="number">9</span>                  <span class="comment">// Field helloWorld:Lcom/tuling/redission/HelloWorld;</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>指令解释链接：<a href="http://www.ronblog.cn//article/6">http://www.ronblog.cn//article/6</a></p><h5 id="局部变量-和-操作数"><a href="#局部变量-和-操作数" class="headerlink" title="局部变量 和 操作数"></a>局部变量 和 操作数</h5><p><img src="http://img.ron.zone/oneblog/article/20210319020336510.png" alt="file"><br>如对指令进行分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>就是给变量a 分配 局部变量栈空间，再将1复制到操作数栈。然后操作数1出栈，写入a的局部变量空间。<br><strong>局部变量 0 </strong> 调用当前方法的this指针<br><strong>局部变量math</strong><br><img src="http://img.ron.zone/oneblog/article/20210319022656643.png" alt="file"><br><em>栈和堆的关系也可以理解为：</em><br>栈 中有很多指向 堆的指针</p><h5 id="动态链接："><a href="#动态链接：" class="headerlink" title="动态链接："></a>动态链接：</h5><p>把符号引用换成直接引用。实现函数的调用，找到函数名称对应的方法内存入口</p><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>存放下一条指令的行号（其实是方法区的指令内存空间地址）。目的是为了进行线程切换。<br>其值由字节码执行引擎进行修改。</p><h5 id="方法出口"><a href="#方法出口" class="headerlink" title="方法出口"></a>方法出口</h5><p>指向调用函数 如main（）方法</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>又叫元空间，存放常量、静态变量、类信息、函数方法<br>例如静态变量user<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure><br>静态变量user存放在方法区中，但还是一个指针，指向了堆<br><img src="http:///oneblog/article/20210319023122673.png" alt="file"></p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>一些JAVA的底层C++ 的具体实现：<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread().start();</span><br></pre></td></tr></table></figure><br>查看源码能看见底层<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="字节码执行引擎"><a href="#字节码执行引擎" class="headerlink" title="字节码执行引擎"></a>字节码执行引擎</h3><p>1.执行内存里的代码<br>2.开启垃圾收集线程，收集的垃圾对象</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="算法：可达性分析（类比数据结构）"><a href="#算法：可达性分析（类比数据结构）" class="headerlink" title="算法：可达性分析（类比数据结构）"></a>算法：可达性分析（类比数据结构）</h5><p>将GC root 对象作为起点，线程的本地变量、静态变量、本地方法栈等等<br>从这些起点开始向下搜索文件。从直接引用找到间接引用，这些对象都是非垃圾对象<br><img src="http://img.ron.zone/oneblog/article/20210319024402200.png" alt="file"><br> minor gc 会回收整个年轻代的内存空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://img.ron.zone/oneblog/article/20210319023906389.png&quot; alt=&quot;file&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;类装载子系统&quot;&gt;&lt;a href=&quot;#类装载子系统&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="JVM" scheme="https://gitflhub.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 虚拟机基础</title>
    <link href="https://gitflhub.github.io/2021/05/27/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    <id>https://gitflhub.github.io/2021/05/27/JVM-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80/</id>
    <published>2021-05-27T13:01:42.000Z</published>
    <updated>2021-07-15T03:57:19.455Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.ron.zone/oneblog/article/20210323010135389.png" alt="file"><br>JVM中的堆一般分为三部分，新生代、老年代和永久代。</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>主要是用来存放新生的对象。一般占据堆空间的1/3，由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。<br>新生代分为Eden区、ServivorFrom、ServivorTo三个区。</p><h4 id="Eden区："><a href="#Eden区：" class="headerlink" title="Eden区："></a>Eden区：</h4><p>Java新对象的出生地(如果新创建的对象占用内存很大则直接分配给老年代)。当Eden区内存不够的时候就会触发一次MinorGc，对新生代区进行一次垃圾回收。</p><h4 id="ServivorTo："><a href="#ServivorTo：" class="headerlink" title="ServivorTo："></a>ServivorTo：</h4><p>保留了一次MinorGc过程中的幸存者。</p><h4 id="ServivorFrom"><a href="#ServivorFrom" class="headerlink" title="ServivorFrom:"></a>ServivorFrom:</h4><p>上一次GC的幸存者，作为这一次GC的被扫描者。<br>当JVM无法为新建对象分配内存空间的时候(Eden区满的时候)，JVM触发MinorGc。<strong>因此新生代空间占用越低，MinorGc越频繁。MinorGC采用复制算法。</strong></p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>老年代的对象比较稳定，所以MajorGC不会频繁执行。</p><h4 id="触发MinorGC的条件："><a href="#触发MinorGC的条件：" class="headerlink" title="触发MinorGC的条件："></a>触发MinorGC的条件：</h4><p>1 在进行MajorGC之前，一般都先进行了一次MinorGC，使得有新生代的对象进入老年代，<strong>当老年代空间不足时就会触发MajorGC。</strong><br>2 当<strong>无法找到足够大的连续空间</strong>分配给新创建的较大对象时，也会触发MajorGC进行垃圾回收腾出空间。</p><p>MajorGC采用<strong>标记—清除</strong>算法(或者标记—整理算法)<br>MajorGC的耗时比较长，因为<strong>要先整体扫描再回收</strong>，<strong>MajorGC会产生内存碎片</strong>。为了减少内存损耗，一般需要<strong>合并或者标记出来方便下次直接分配</strong>。</p><p>当<strong>老年代也满了装不下</strong>的时候，就会抛出<strong>OOM</strong>。</p><h3 id="永久代-元数据区"><a href="#永久代-元数据区" class="headerlink" title="永久代(元数据区)"></a>永久代(元数据区)</h3><p>指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。<br><strong>Class在被加载的时候元数据信息会放入永久区域</strong>，但是GC不会在主程序运行的时候清除永久代的信息。所以这也导致永久代的信息会随着类加载的增多而膨胀，<strong>最终导致OOM</strong>。<br>注意: 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<br>1.元空间并<strong>不在虚拟机中</strong>，而是使用<strong>本地内存</strong>。因此默认情况下元空间的大小仅仅受<strong>本地内存的大小限制</strong>。类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中。 这样可以加载多少类的元数据就<strong>不再由MaxPermSize</strong>控制, 而由系统的<strong>实际可用空间</strong>来控制。</p><h3 id="MajorGC和FullGC的区别"><a href="#MajorGC和FullGC的区别" class="headerlink" title="MajorGC和FullGC的区别"></a>MajorGC和FullGC的区别</h3><p>(这里参考1建议不要纠结这两个概念的区别，而是应该专注于解决问题)</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>是清理整个堆空间—包括年轻代和老年代。</p><h4 id="Major-GC"><a href="#Major-GC" class="headerlink" title="Major GC"></a>Major GC</h4><p>是清理老年代。</p><h4 id="MinorGC-触发机制"><a href="#MinorGC-触发机制" class="headerlink" title="MinorGC 触发机制"></a>MinorGC 触发机制</h4><p>1 Eden区满的时候，JVM会触发MinorGC。</p><h4 id="MajorGC-触发机制"><a href="#MajorGC-触发机制" class="headerlink" title="MajorGC 触发机制"></a>MajorGC 触发机制</h4><p>1 在进行MajorGC之前，一般都先进行了一次MinorGC，使得有新生代的对象进入老年代，当老年代空间不足时就会触发MajorGC。<br>2 当无法找到足够大的连续空间分配给新创建的<strong>较大对象时</strong>(如大数组)，也会触发MajorGC进行垃圾回收腾出空间。</p><h4 id="Full-GC触发机制："><a href="#Full-GC触发机制：" class="headerlink" title="Full GC触发机制："></a>Full GC触发机制：</h4><p>1 调用System.gc时，系统建议执行Full GC，但是不必然执行<br>2 <strong>老年代空间</strong>不足<br>3 <strong>方法区空间</strong>不足<br>4 通过<strong>Minor GC</strong>后进入老年代的<strong>平均大小大</strong>于老年代的可用内存<br>5 由Eden区、survivor space1（From Space）区向survivor space2（To Space）区复制时，<br>4 当<strong>永久代满时也会引发Full GC</strong>，会导致<strong>Class、Method元信息的卸载</strong>。</p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，　　当它的年龄增加到一定程度（默认为 15 岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold (阈值)来设置。</p><p>参考：<br>1 原文: Minor GC vs Major GC vs Full GC<br>2 Java中的新生代、老年代、永久代和各种GC</p><p>作者：Aaron_Swartz<br>链接：<a href="https://www.jianshu.com/p/d3a0b4e36c28">https://www.jianshu.com/p/d3a0b4e36c28</a><br>来源：简书</p><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;http://img.ron.zone/oneblog/article/20210323010135389.png&quot; alt=&quot;file&quot;&gt;&lt;br&gt;JVM中的堆一般分为三部分，新生代、老年代和永久代。&lt;/p&gt;
&lt;h3 id=&quot;新生代&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="虚拟机" scheme="https://gitflhub.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的锁</title>
    <link href="https://gitflhub.github.io/2021/05/27/Java-%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>https://gitflhub.github.io/2021/05/27/Java-%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2021-05-27T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:09.333Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>序号</th><th>锁名称</th><th>应用</th><th></th></tr></thead><tbody><tr><td>1</td><td><a href="#h1">乐观锁</a></td><td>CAS</td><td></td></tr><tr><td>2</td><td><a href="#h2">悲观锁</a></td><td>synchronized、vector、hashtable</td><td></td></tr><tr><td>3</td><td><a href="#h3">自旋锁</a></td><td>CAS</td><td></td></tr><tr><td>4</td><td><a href="#h4">可重入锁</a></td><td>synchronized、Reentrantlock、Lock</td><td></td></tr><tr><td>5</td><td><a href="#h5">读写锁</a></td><td>ReentrantReadWriteLock，CopyOnWriteArrayList、CopyOnWriteArraySet</td><td></td></tr><tr><td>6</td><td><a href="#h6">公平锁</a></td><td>Reentrantlock(true)</td><td></td></tr><tr><td>7</td><td><a href="#h7">非公平锁</a></td><td>synchronized、reentrantlock(false)</td><td></td></tr><tr><td>8</td><td><a href="#h8">共享锁</a></td><td>ReentrantReadWriteLock中读锁</td><td></td></tr><tr><td>9</td><td><a href="#h9">独占锁</a></td><td>synchronized、vector、hashtable、ReentrantReadWriteLock中写锁</td><td></td></tr><tr><td>10</td><td><a href="#h10">重量级锁</a></td><td>synchronized</td><td></td></tr><tr><td>11</td><td><a href="#h11">轻量级锁</a></td><td>锁优化技术</td><td></td></tr><tr><td>12</td><td><a href="#h12">偏向锁</a></td><td>锁优化技术</td><td></td></tr><tr><td>13</td><td><a href="#h13">分段锁</a></td><td>concurrentHashMap</td><td></td></tr><tr><td>14</td><td><a href="#h14">互斥锁</a></td><td>synchronized</td><td></td></tr><tr><td>15</td><td><a href="#h15">同步锁</a></td><td>synchronized</td><td></td></tr><tr><td>16</td><td><a href="#h16">死锁</a></td><td>相互请求对方的资源</td><td></td></tr><tr><td>17</td><td><a href="#h17">锁粗化</a></td><td>锁优化技术</td><td></td></tr><tr><td>18</td><td><a href="#h18">锁消除</a></td><td>锁优化技术</td></tr></tbody></table></div><h2 id="1、乐观锁"><a href="#1、乐观锁" class="headerlink" title="1、乐观锁"></a>1、乐观锁<a id = "h1"></a></h2><p> 乐观锁是一种乐观思想，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前 与期望值是否相同，如果相同则进行更新<strong>（更新期间加锁，保证是原子性的）</strong>。<br>Java中的乐观锁：CAS，比较并替换，比较当前值（主内存中的值），与预期值（当前    线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。<br>**可以同时进行读操作，读的时候其他线程不能进行写操作。</p><h2 id="2、悲观锁"><a href="#2、悲观锁" class="headerlink" title="2、悲观锁"></a>2、悲观锁<a id = "h2"></a></h2><p>悲观锁是一种悲观思想，即认为写多读少，遇到并发写的可能性高，每次去拿数据的时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。<br><strong>Java中的悲观锁：synchronized修饰的方法和方法块、ReentrantLock</strong>。<br><strong>只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行。</strong></p><h2 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁<a id = "h3"></a></h2><p>自旋锁是一种技术： 为了让线程等待，我们只须让线程执行一个忙循环（自旋）。现在绝大多数的个人电脑和服务器都是多路（核）处理器系统，如果物理机器有一个以上的处理器或者处理器核心，能让两个或以上的线程同时并行执行，就可以让后面    请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是    否很快就会释放锁。<br>自旋锁的优点：<br>避免了线程切换的开销。挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给Java虚拟机的并发性能带来了很大的压力。<br>自旋锁的缺点： 占用处理器的时间，如果占用的时间很长，会白白消耗处理器资源， 而不会做任何有价值的工作，带来性能的浪费。因此自旋等待的时间必须有一定的限    度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起    线程。<br>自旋次数默认值：10次，可以使用参数-XX:PreBlockSpin来自行更改。</p><p>自适应自旋： 自适应意味着自旋的时间不再是固定的，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。有了自适应自旋，随着程序运行时间的增长   及性能监控信息的不断完善，虚拟机对程序锁的状态预测就会越来越精准。<br>Java中的自旋锁： CAS操作中的比较操作失败后的自旋等待。</p><h2 id="4、可重入锁（递归锁）"><a href="#4、可重入锁（递归锁）" class="headerlink" title="4、可重入锁（递归锁）"></a>4、可重入锁（递归锁）<a id = "h4"></a></h2><p>可重入锁是一种技术： 任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞。<br>可重入锁的原理： 通过组合自定义同步器来实现锁的获取与释放。<br>再次获取锁：识别获取锁的线程是否为当前占据锁的线程，如果是，则再   次成功获取。获取锁后，进行计数自增，<br>释放锁：释放锁时，进行计数自减。<br>Java中的可重入锁： ReentrantLock、synchronized修饰的方法或代码段。<br>可重入锁的作用： 避免死锁。<br>面试题1： 可重入锁如果加了两把，但是只释放了一把会出现什么问题？<br>答：程序卡死，线程不能出来，也就是说我们申请了几把锁，就需要释放几把锁。    面试题2： 如果只加了一把锁，释放两次会出现什么问题？</p><p>答：会报错，java.lang.IllegalMonitorStateException。</p><h2 id="5、读写锁"><a href="#5、读写锁" class="headerlink" title="5、读写锁"></a>5、读写锁<a id = "h5"></a></h2><p>读写锁是一种技术： 通过ReentrantReadWriteLock类来实现。为了提高性能， Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的，在一定程度上提高了程序的执行效率。 读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的。<br>读锁： 允许多个线程获取读锁，同时访问同一个资源。</p><p>写锁： 只允许一个线程获取写锁，不允许同时访问同一个资源。</p><p>如何使用：<br>/<em>** 创建一个读写锁</em> 它是一个读写融为一体的锁，在使用的时候，需要转换*/private ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();复制代码<br>获取读锁和释放读锁<br>// 获取读锁rwLock.readLock().lock();// 释放读锁rwLock.readLock().unlock();复制代码<br>获取写锁和释放写锁<br>// 创建一个写锁rwLock.writeLock().lock();// 写锁 释放rwLock.writeLock().unlock();复制代码<br>Java中的读写锁：ReentrantReadWriteLock</p><h2 id="6、公平锁"><a href="#6、公平锁" class="headerlink" title="6、公平锁"></a>6、公平锁<a id = "h6"></a></h2><p>公平锁是一种思想： 多个线程按照申请锁的顺序来获取锁。在并发环境中，每个线程会先查看此锁维护的等待队列，如果当前等待队列为空，则占有锁，如果等待队列不    为空，则加入到等待队列的末尾，按照FIFO的原则从队列中拿到线程，然后占有锁。</p><h2 id="7、非公平锁"><a href="#7、非公平锁" class="headerlink" title="7、非公平锁"></a>7、非公平锁<a id = "h7"></a></h2><p>非公平锁是一种思想： 线程尝试获取锁，如果获取不到，则再采用公平锁的方式。多个线程获取锁的顺序，不是按照先到先得的顺序，有可能后申请锁的线程比先申请的    线程优先获取锁。<br>优点： 非公平锁的性能高于公平锁。<br>缺点： 有可能造成线程饥饿（某个线程很长一段时间获取不到锁）<br>Java中的非公平锁：synchronized是非公平锁，ReentrantLock通过构造函数指定    该锁是公平的还是非公平的，默认是非公平的。</p><h2 id="8、共享锁"><a href="#8、共享锁" class="headerlink" title="8、共享锁"></a>8、共享锁<a id = "h8"></a></h2><p>共享锁<br>共享锁是一种思想： 可以有多个线程获取读锁，以共享的方式持有锁。和乐观锁、读写锁同义。<br>Java中用到的共享锁：ReentrantReadWriteLock。</p><h2 id="9、独占锁"><a href="#9、独占锁" class="headerlink" title="9、独占锁"></a>9、独占锁<a id = "h9"></a></h2><p>独占锁是一种思想： 只能有一个线程获取锁，以独占的方式持有锁。和悲观锁、互斥锁同义。<br>Java中用到的独占锁： synchronized，ReentrantLock</p><h2 id="10、重量级锁"><a href="#10、重量级锁" class="headerlink" title="10、重量级锁"></a>10、重量级锁<a id = "h10"></a></h2><p>重量级锁是一种称谓：synchronized是通过对象内部的一个叫做监视器锁<br>（monitor）来实现的，监视器锁本身依赖底层的操作系统的 Mutex Lock来实现。操作系统实现线程的切换需要从用户态切换到核心态，成本非常高。这种依赖于操作系    统 Mutex Lock来实现的锁称为重量级锁。为了优化synchonized，引入了轻量级锁， 偏向锁。<br>Java中的重量级锁： synchronized</p><h2 id="11、轻量级锁"><a href="#11、轻量级锁" class="headerlink" title="11、轻量级锁"></a>11、轻量级锁<a id = "h11"></a></h2><p>轻量级锁是JDK6时加入的一种锁优化机制： 轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量。轻量级是相对于使用操作系统互斥量来实现的重量级锁而言的。轻量级锁在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁将不会有效，必须膨胀为重量级锁。<br>优点： 如果没有竞争，通过CAS操作成功避免了使用互斥量的开销。<br>缺点： 如果存在竞争，除了互斥量本身的开销外，还额外产生了CAS操作的开销，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。</p><h2 id="12、偏向锁"><a href="#12、偏向锁" class="headerlink" title="12、偏向锁"></a>12、偏向锁<a id = "h12"></a></h2><p>偏向锁是JDK6时加入的一种锁优化机制： 在无竞争的情况下把整个同步都消除掉， 连CAS操作都不去做了。偏是指偏心，它的意思是这个锁会偏向于第一个获得它的线   程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的    线程将永远不需要再进行同步。持有偏向锁的线程以后每次进入这个锁相关的同步块</p><p>时，虚拟机都可以不再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作等）。<br>优点： 把整个同步都消除掉，连CAS操作都不去做了，优于轻量级锁。<br>缺点： 如果程序中大多数的锁都总是被多个不同的线程访问，那偏向锁就是多余的。</p><h2 id="13、分段锁"><a href="#13、分段锁" class="headerlink" title="13、分段锁"></a>13、分段锁<a id = "h13"></a></h2><p>分段锁是一种机制： 最好的例子来说明分段锁是ConcurrentHashMap。ConcurrentHashMap原理：它内部细分了若干个小的 HashMap，称之为段(Segment)。 默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段，既就是锁的并发度。如果需要在 ConcurrentHashMap 添加一项key-value，并不是将整个 HashMap 加锁，而是首先根据 hashcode 得到该key-value应该存放在哪个段中，然后对该段加锁，并完成 put 操作。在多线程环境中，如果多个线程同时进行</p><p>put操作，只要被加入的key-value不存放在同一个段中，则线程间可以做到真正的并    行。<br>线程安全：ConcurrentHashMap 是一个 Segment 数组， Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全</p><h2 id="14、互斥锁"><a href="#14、互斥锁" class="headerlink" title="14、互斥锁"></a>14、互斥锁<a id = "h14"></a></h2><p>互斥锁与悲观锁、独占锁同义，表示某个资源只能被一个线程访问，其他线程不能访    问。<br>读-读互斥读-写互斥写-读互斥</p><p>写-写互斥<br>Java中的同步锁： synchronized</p><h2 id="15、同步锁"><a href="#15、同步锁" class="headerlink" title="15、同步锁"></a>15、同步锁<a id = "h15"></a></h2><p>同步锁与互斥锁同义，表示并发执行的多个线程，在同一时间内只允许一个线程访问    共享数据。<br>Java中的同步锁： synchronized</p><h2 id="16、死锁"><a href="#16、死锁" class="headerlink" title="16、死锁"></a>16、死锁<a id = "h16"></a></h2><p>死锁是一种现象：如线程A持有资源x，线程B持有资源y，线程A等待线程B释放资源<br>y，线程B等待线程A释放资源x，两个线程都不释放自己持有的资源，则两个线程都获    取不到对方的资源，就会造成死锁。<br>Java中的死锁不能自行打破，所以线程死锁后，线程不能进行响应。所以一定要注意    程序的并发场景，避免造成死锁。</p><h2 id="17、锁粗化"><a href="#17、锁粗化" class="headerlink" title="17、锁粗化"></a>17、锁粗化<a id = "h17"></a></h2><p>锁粗化是一种优化技术： 如果一系列的连续操作都对同一个对象反复加锁和解锁，甚<br>至加锁操作都是出现在循环体体之中，就算真的没有线程竞争，频繁地进行互斥同步    操作将会导致不必要的性能损耗，所以就采取了一种方案：把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损    耗。</p><h2 id="18、锁消除"><a href="#18、锁消除" class="headerlink" title="18、锁消除"></a>18、锁消除<a id = "h18"></a></h2><p>锁消除是一种优化技术： 就是把锁干掉。当Java虚拟机运行时发现有些共享数据不会被线程竞争时就可以进行锁消除。<br>那如何判断共享数据不会被线程竞争？<br>利用逃逸分析技术：分析对象的作用域，如果对象在A方法中定义后，被作为参数传递到B方法中，则称为方法逃逸；如果被其他线程访问，则称为线程逃逸。<br>在堆上的某个数据不会逃逸出去被其他线程访问到，就可以把它当作栈上数据对待，    认为它是线程私有的，同步加锁就不需要了。</p><h2 id="19、synchronized"><a href="#19、synchronized" class="headerlink" title="19、synchronized"></a>19、synchronized<a id = "h19"></a></h2><p>synchronized是Java中的关键字：用来修饰方法、对象实例。属于独占锁、悲观锁、可重入锁、非公平锁。</p><ol><li><p>作用于实例方法时，锁住的是对象的实例(this)；<br>2.当作用于静态方法时，锁住的是 Class类，相当于类的一个全局锁，会锁所有调用该方法的线程；<br>3.synchronized 作用于一个非 NULL的对象实例时，锁住的是所有以该对象为锁的代码块。 它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。<br>每个对象都有个 monitor 对象， 加锁就是在竞争 monitor 对象，代码块加锁是在代码块前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。<br>20、Lock和synchronized的区别<br>Lock： 是Java中的接口，可重入锁、悲观锁、独占锁、互斥锁、同步锁。1.Lock需要手动获取锁和释放锁。就好比自动挡和手动挡的区别2.Lock 是一个接口，而 synchronized 是 Java 中的关键字，<br>synchronized 是内置的语言实现。<br>3.synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放<br>锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。</p><p>4.Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断。<br>5.通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。6.Lock 可以通过实现读写锁提高多个线程进行读操作的效率。<br>synchronized的优势：<br>足够清晰简单，只需要基础的同步功能时，用synchronized。<br>Lock应该确保在finally块中释放锁。如果使用synchronized，JVM确保即   使出现异常，锁也能被自动释放。<br>使用Lock时，Java虚拟机很难得知哪些锁对象是由特定线程锁持有的。<br>21、ReentrantLock 和synchronized的区别</p></li></ol><p>ReentrantLock是Java中的类 ： 继承了Lock类，可重入锁、悲观锁、独占锁、互斥锁、同步锁。<br>划重点<br>相同点：</p><p>不同点：</p><ol><li><p>主要解决共享变量如何安全访问的问题<br>2.都是可重入锁，也叫做递归锁，同一线程可以多次获得同一个锁，<br>3.保证了线程安全的两大特性：可见性、原子性。</p><p>1.ReentrantLock 就像手动汽车，需要显示的调用lock和unlock方法， synchronized 隐式获得释放锁。<br>2.ReentrantLock 可响应中断， synchronized 是不可以响应中断的， ReentrantLock 为处理锁的不可用性提供了更高的灵活性<br>3.ReentrantLock 是 API 级别的， synchronized 是 JVM 级别的4.ReentrantLock 可以实现公平锁、非公平锁，默认非公平锁，<br>synchronized 是非公平锁，且不可更改。5.ReentrantLock 通过 Condition 可以绑定多个条件</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;锁名称&lt;/th&gt;
&lt;th&gt;应用&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td</summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="锁" scheme="https://gitflhub.github.io/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://gitflhub.github.io/2021/05/27/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://gitflhub.github.io/2021/05/27/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-05-27T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:13.517Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直以为注释=注解，em…..<br>Java5之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解。例如在方法覆盖中使用@Override，注解，注解都是用@符号开头的。<br>有的注解可以在运行时读写字节码文件信息</p><h2 id="1-基本注解"><a href="#1-基本注解" class="headerlink" title="1.基本注解"></a>1.基本注解</h2><p>无论哪一种注解，本质上都是一种数据类型，是一种接口类型。到Java8为止，Java提供了11种内置注解。其中有5种是基本注解，他们来自于java.lang包；<br>有六种是元注解（meta annotation），他们来自于java.lang.annotation包，自定义注解会用到元注解。<br>基本注解类型包括@Override,@Deprecated,@SuppressWarnings,@SafeVarargs,@FunctionalInterface。下面逐一介绍</p><h3 id="1-1-Override"><a href="#1-1-Override" class="headerlink" title="1.1 @Override:"></a>1.1 @Override:</h3><p>@Override只能用于方法，子类覆盖父类方法（或者实现接口方法）时可以@Override注解。编译器会检查被@Override的方法，确保该父类中存在的方法，否则会有编译错误。</p><h3 id="1-2-Deprecated"><a href="#1-2-Deprecated" class="headerlink" title="1.2 @Deprecated"></a>1.2 @Deprecated</h3><p>@Deprecated用来指示API已经过时了。@Deprecated可以用来注释类，接口，成员方法和变量。调用@Deprecated方法的代码会出现删除线</p><h3 id="1-3-SuppressWarnnings"><a href="#1-3-SuppressWarnnings" class="headerlink" title="1.3@SuppressWarnnings"></a>1.3@SuppressWarnnings</h3><p>@SuppressWarnnings注释用来抑制编译器警告，如果确认程序中的警告没有问题，可以不用理会。若是不想看到相关警告，可以使用@SuppressWarnning方法来消除警告。</p><h3 id="1-4-SafeVarargs"><a href="#1-4-SafeVarargs" class="headerlink" title="1.4@SafeVarargs"></a>1.4@SafeVarargs</h3><p>@SafeVarargs可以抑制将非范型变量值赋值给范型变量值</p><h3 id="1-5-FunctionalInterface"><a href="#1-5-FunctionalInterface" class="headerlink" title="1.5@FunctionalInterface"></a>1.5@FunctionalInterface</h3><p>@FunctionalInterface用于接口注释</p><h2 id="2-元注解"><a href="#2-元注解" class="headerlink" title="2.元注解"></a>2.元注解</h2><p>元注解包括@Documented，@Tagget，@Retention，@Inherited，@Repeatable，@Native。元注解是为其他注解进行说明的注释。<br>当自定义一个新的注解类型时，其中可以使用元注解。</p><h3 id="1-Documented"><a href="#1-Documented" class="headerlink" title="1.@Documented"></a>1.@Documented</h3><p>如果在一个自定义注解中引用@Documented注解，那么该注解可以修饰代码元素(类、接口、成员变量和成员方法)，javadoc等工具可以提取这些元素</p><h3 id="2-Target"><a href="#2-Target" class="headerlink" title="2.@Target"></a>2.@Target</h3><p>@Target注解用来指定一个新注解的适用目标。@Target注解中有一个成员（value）用来设置目标，value是java.lang.annotation.ElementType枚举类型的数组，ElementType描述Java程序元素类型，他有10个枚举常量。<br>枚举常量    说明<br>ANNOTATION_TYPE    其他注释类型声明<br>CONSTRUCTOR    构造方法声明<br>FIELD    成员变量或常量声明<br>LOCAL_VARIABLE    局部变量声明<br>METHOD    方法声明<br>PACKAGE    包声明<br>PARAMETER    参数声明<br>TYPE    类、接口声明<br>TYPE_PARAMETER    用于泛型中类型参数的声明<br>TYPE_USE    用于任何类型的声明，Java8推出</p><h3 id="3-Retention"><a href="#3-Retention" class="headerlink" title="3,@Retention"></a>3,@Retention</h3><p>@Rentention注释用来指定一个新注解的有效范围，@Retention注解一个成员（value）用来设置保留策略，value是java.lang.annotation.RetentionPolicy枚举类型，RetentionPolicy描述注释保留类型策略，他有三个枚举常量<br>枚举常量    说明<br>SOURCE    只适用于Java源代码文件中，此范围最小<br>CLASS    编译器把注释信息记录在字节码文件中，此范围居中<br>RUNTIME    编译器把注释信息记录在字节码文件中，并在运行时可以读取这些信息，此范围最大</p><h3 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4.@Inherited"></a>4.@Inherited</h3><p>@Inherited注释用来指定一个新注解可以被继承。假定一个类A被该注释修饰，那么这个A类的子类会继承该新注解</p><h3 id="5-Repeatable"><a href="#5-Repeatable" class="headerlink" title="5.@Repeatable"></a>5.@Repeatable</h3><p>@Repeatable注解允许在相同的程序元素中重复注解。可重复的注解必须使用@Repeatable进行注解。</p><h3 id="6-Native"><a href="#6-Native" class="headerlink" title="6.@Native"></a>6.@Native</h3><p>@Native 注释一个成员变量，指示这个变量可以被本地代码引用。常常被代码生成工具使用</p><h2 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3.自定义注解"></a>3.自定义注解</h2><h3 id="1-声明注解"><a href="#1-声明注解" class="headerlink" title="1.声明注解"></a>1.声明注解</h3><p>声明自定义注解可以使用@Interface关键字实现，最简单的形式的注释实例代码如下：<br>//Marker.java文件<br>package.com.a51work6;<br>public @Interface Marker{}<br>一个源文件中可以声明多个注解，但是只有一个是公有访问权限的，源文件命名与公有访问权限的注解名一致。<br>Marker注解中不包含任何成员，这种注解称为标记注解，基本注解中的@Override就属于标记注解。根据需要，注解中可以包含一些成员，实例代码<br>//Marker.java文件<br>package.com.a51work6;  //单值注解<br>@Interface MyAnnotation{<br>    String value();<br>}<br>代码中声明MyAnnotation注解，他有一个成员value，注意value后面有对小括号。value前面的是数据类型。成员也可以有访问权限修饰符，但是只能是公有权限和默认权限。<br>注释中的成员也可以有默认值，示例代码如下：<br>//Marker.java文件<br>package.com.a51work6;<br>//单值注解<br>@Interface MyAnnotation1{<br>    String value() default “注解信息”;<br>    int count() default 0;<br>}</p><h3 id="2-案例：使用元注解"><a href="#2-案例：使用元注解" class="headerlink" title="2.案例：使用元注解"></a>2.案例：使用元注解</h3><p>前面啰嗦了一大堆，直接写个例子吧，不然要睡着了。<br>例子：<br>import javax.xml.bind.Element;<br>import java.lang.annotation.*;<br>//指定MyAnnotation注解信息可以被javadoc工具读取<br>@Documented<br>//指定注解用于修饰类和接口等类型<br>@Target({ ElementType.TYPE })<br>//指定注释信息可以在运行时被读取<br>@Retention( RetentionPolicy.RUNTIME )<br>public @interface MyAnnotation {<br>    //注解的成员<br>    String description();<br>}<br>还是不知道这个用来干嘛。再来一个例子试试<br>//MemberAnnotation.java<br>import java.lang.annotation.Documented;<br>import java.lang.annotation.ElementType;<br>import java.lang.annotation.Retention;<br>import java.lang.annotation.RetentionPolicy;<br>import java.lang.annotation.Target;</p><p>@Documented<br>@Retention(RetentionPolicy.RUNTIME)<br>//指定MemberAnnotation注解用于修饰类中的成员<br>@Target({ ElementType.FIELD, ElementType.METHOD })<br>public @interface MemberAnnotation {<br>    //type类型是Class<T>，默认值是void.class<br>    //&lt;?&gt;表示不限定类型，用？作为占位符<br>    Class&lt;?&gt; type() default void.class;<br>    //description类型是String，没有默认值<br>    String description();<br>}<br>import javax.xml.bind.Element;<br>import java.lang.annotation.*;<br>//指定MyAnnotation注解信息可以被javadoc工具读取<br>@Documented<br>//指定注解用于修饰类和接口等类型<br>@Target({ ElementType.TYPE})<br>//指定注释信息可以在运行时被读取<br>@Retention( RetentionPolicy.RUNTIME )<br>public @interface MyAnnotation {<br>    //注解的成员<br>    String description();<br>}<br>@MyAnnotation(description = “这是一个测试类”)<br>public class Person {<br>    //修饰成员变量<br>    @MemberAnnotation(type = String.class, description = “名字”)<br>    private String name;</p><pre><code>@MemberAnnotation(type = int.class, description = &quot;年龄&quot;)private int age;@MemberAnnotation(type = String.class, description = &quot;获得名字&quot;)public String getName() &#123;    return name;&#125;//修饰成员方法@MemberAnnotation(type = int.class, description = &quot;获得年龄&quot;)public int getAge() &#123;    return age;&#125;@MemberAnnotation(description = &quot;设置姓名和年龄&quot;)public void setNameAndAge(String name, int age) &#123;    this.name = name;    this.age = age;&#125;@Overridepublic String toString() &#123;    return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;&#125;</code></pre><p>}<br>还是不知道要干嘛。。。。</p><h3 id="3-案例读取运行时注解信息"><a href="#3-案例读取运行时注解信息" class="headerlink" title="3.案例读取运行时注解信息"></a>3.案例读取运行时注解信息</h3><p>注解是为工具读取信息而准备的。有些工具可以读取源代码文件中的注解信息；有的可以读取字节码文件中的注解信息；有的可以在运行时读取注解信息。但是读取这些注解信息都是一样的，区别只在于自定义注解中@Retention的保留策略不同。<br>读取注解信息要反射相关API，Class类有如下方法。</p><p><A extends Annotation>A getAnnotation(Class<A> annotation Class):如果此元素存在annotationClass类型的注解，则返回注解，否则返回null。<br>Annotation[] getAnnotations():返回此元素上存在的所有注解。<br>Annotation[] getDeclaredAnnotations():返回直接存在于此元素上的所有注解。与getAnnotations()区别在于，该方法将不返回继承的注释。<br>boolbean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass):如果此元素存在annotationClass的注解，则返回true，否则返回false。<br>boolbean isAnnotation():如果此Class对象表示一个注解类型，则返回true。<br>运行时Person类中注解信息代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mainFun</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建Person类对应的对象</span></span><br><span class="line">            Class&lt;?&gt; clz = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">            <span class="comment">//读取类注解</span></span><br><span class="line">            <span class="comment">//判断Person类是否存在MyAnnotation注解</span></span><br><span class="line">            <span class="keyword">if</span> (clz.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">                <span class="comment">//返回注解实例</span></span><br><span class="line">                MyAnnotation myAnnotation = (MyAnnotation) clz.getAnnotation(MyAnnotation.class);</span><br><span class="line">                <span class="comment">//读取注解中的表达式</span></span><br><span class="line">                System.out.printf(<span class="string">&quot;类%s,读取注释描述：%s\n&quot;</span>, clz.getName(), myAnnotation.description());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读取成员方法的注解详情</span></span><br><span class="line">            Method[] methods = clz.getDeclaredMethods();</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                <span class="comment">//判断方法是否存在MemberAnnotation注解</span></span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(MemberAnnotation.class)) &#123;</span><br><span class="line">                    <span class="comment">//返回MemberAnnotation注解实例</span></span><br><span class="line">                    MemberAnnotation memberAnnotation = method.getAnnotation(MemberAnnotation.class);</span><br><span class="line">                    <span class="comment">//读取MemberAnnotation实例的注解表达式</span></span><br><span class="line">                    System.out.printf(<span class="string">&quot;方法%s，读取注解描述： %s\n&quot;</span>, method.getName(), memberAnnotation.description());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//读取成员变量的注解信息</span></span><br><span class="line">            Field[] fields = clz.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                <span class="comment">//判断变量是否存在MemberAnnotation注解</span></span><br><span class="line">                <span class="keyword">if</span> (field.isAnnotationPresent(MemberAnnotation.class)) &#123;</span><br><span class="line">                    <span class="comment">//返回MemberAnnotation注解实例</span></span><br><span class="line">                    MemberAnnotation memberAnnotation = field.getAnnotation(MemberAnnotation.class);</span><br><span class="line">                    <span class="comment">//读取MemberAnnotation实例的注解表达式</span></span><br><span class="line">                    System.out.printf(<span class="string">&quot;成员变量%s,读取注解描述:%s\n&quot;</span>, field.getName(), memberAnnotation.description());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot;C:\Program Files\Java\jdk1.8.0_181\bin\java.exe&quot; &quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\lib\idea_rt.jar=55483:C:\Program Files\JetBrains\IntelliJ IDEA 2019.1.3\bin&quot; -Dfile.encoding=UTF-8 -classpath &quot;C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;E:\编程\eclipseJavaCode\IXml\out\production\IXml;E:\编程\eclipseJavaCode\IXml\lib\jaxws-api.jar;E:\编程\eclipseJavaCode\IXml\lib\jaxws-rt.jar;E:\编程\eclipseJavaCode\IXml\lib\jaxws-tools.jar;E:\编程\eclipseJavaCode\IXml\lib\activation.jar;E:\编程\eclipseJavaCode\IXml\lib\FastInfoset.jar;E:\编程\eclipseJavaCode\IXml\lib\gmbal-api-only.jar;E:\编程\eclipseJavaCode\IXml\lib\http.jar;E:\编程\eclipseJavaCode\IXml\lib\jaxb-api.jar;E:\编程\eclipseJavaCode\IXml\lib\jaxb-impl.jar;E:\编程\eclipseJavaCode\IXml\lib\jsr173_api.jar;E:\编程\eclipseJavaCode\IXml\lib\jsr181-api.jar;E:\编程\eclipseJavaCode\IXml\lib\jsr250-api.jar;E:\编程\eclipseJavaCode\IXml\lib\management-api.jar;E:\编程\eclipseJavaCode\IXml\lib\mimepull.jar;E:\编程\eclipseJavaCode\IXml\lib\policy.jar;E:\编程\eclipseJavaCode\IXml\lib\resolver.jar;E:\编程\eclipseJavaCode\IXml\lib\saaj-api.jar;E:\编程\eclipseJavaCode\IXml\lib\saaj-impl.jar;E:\编程\eclipseJavaCode\IXml\lib\stax-ex.jar;E:\编程\eclipseJavaCode\IXml\lib\streambuffer.jar;E:\编程\eclipseJavaCode\IXml\lib\woodstox.jar;E:\编程\eclipseJavaCode\IXml\lib\jaxb-xjc.jar&quot; mainFun</span><br><span class="line">类Person,读取注释描述：这是一个测试类</span><br><span class="line">方法getName，读取注解描述： 获得名字</span><br><span class="line">方法getAge，读取注解描述： 获得年龄</span><br><span class="line">方法setNameAndAge，读取注解描述： 设置姓名和年龄</span><br><span class="line">成员变量name,读取注解描述:名字</span><br><span class="line">成员变量age,读取注解描述:年龄</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>终于知道要干嘛了。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前一直以为注释=注解，em…..&lt;br&gt;Java5之后可以在源代码中嵌入一些补充信息，这种补充信息称为注解。例如在方法覆盖中使用@Override，注解，注解都是用@符号开头的。&lt;br&gt;有的注解可以在运行时读写字节码文件信息&lt;/p&gt;
&lt;h2 id=&quot;1-基本注解&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="Java 注解" scheme="https://gitflhub.github.io/tags/Java-%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 公式编辑</title>
    <link href="https://gitflhub.github.io/2021/05/27/Markdown-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/"/>
    <id>https://gitflhub.github.io/2021/05/27/Markdown-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</id>
    <published>2021-05-27T13:01:42.000Z</published>
    <updated>2021-10-17T11:36:22.320Z</updated>
    
    <content type="html"><![CDATA[<p>行内公式是在公式代码块的基础上前面加上<strong>$</strong> ，后面加上<strong>$</strong> 组成的，而行间公式则是在公式代码块前后使用<strong>$$</strong> 和<strong>$$</strong> 。</p><h3 id="1-1-行内公式"><a href="#1-1-行内公式" class="headerlink" title="1.1 行内公式"></a>1.1 行内公式</h3><p>行内公式：$ \Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. $</p><p>效果：</p><p>$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,. $</p><h3 id="1-2-行间公式"><a href="#1-2-行间公式" class="headerlink" title="1.2 行间公式"></a>1.2 行间公式</h3><p>行间公式：$$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.$$</p><p>效果：</p><script type="math/tex; mode=display">\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.</script><h2 id="2-希腊字母"><a href="#2-希腊字母" class="headerlink" title="2. 希腊字母"></a>2. 希腊字母</h2><div class="table-container"><table><thead><tr><th>名称</th><th>大写</th><th>code</th><th>小写</th><th>code</th></tr></thead><tbody><tr><td>alpha</td><td>A</td><td>A</td><td>α</td><td>\alpha</td></tr><tr><td>beta</td><td>B</td><td>B</td><td>β</td><td>\beta</td></tr><tr><td>gamma</td><td>Γ</td><td>\Gamma</td><td>γ</td><td>\gamma</td></tr><tr><td>delta</td><td>Δ</td><td>\Delta</td><td>δ</td><td>\delta</td></tr><tr><td>epsilon</td><td>E</td><td>E</td><td>ϵ</td><td>\epsilon</td></tr><tr><td>zeta</td><td>Z</td><td>Z</td><td>ζ</td><td>\zeta</td></tr><tr><td>eta</td><td>H</td><td>H</td><td>η</td><td>\eta</td></tr><tr><td>theta</td><td>Θ</td><td>\Theta</td><td>θ</td><td>\theta</td></tr><tr><td>iota</td><td>I</td><td>I</td><td>ι</td><td>\iota</td></tr><tr><td>kappa</td><td>K</td><td>K</td><td>κ</td><td>\kappa</td></tr><tr><td>lambda</td><td>Λ</td><td>\Lambda</td><td>λ</td><td>\lambda</td></tr><tr><td>mu</td><td>M</td><td>M</td><td>μ</td><td>\mu</td></tr><tr><td>nu</td><td>N</td><td>N</td><td>ν</td><td>\nu</td></tr><tr><td>xi</td><td>Ξ</td><td>\Xi</td><td>ξ</td><td>\xi</td></tr><tr><td>omicron</td><td>O</td><td>O</td><td>ο</td><td>\omicron</td></tr><tr><td>pi</td><td>Π</td><td>\Pi</td><td>π</td><td>\pi</td></tr><tr><td>rho</td><td>P</td><td>P</td><td>ρ</td><td>\rho</td></tr><tr><td>sigma</td><td>Σ</td><td>\Sigma</td><td>σ</td><td>\sigma</td></tr><tr><td>tau</td><td>T</td><td>T</td><td>τ</td><td>\tau</td></tr><tr><td>upsilon</td><td>Υ</td><td>υ</td><td>υ</td><td>\upsilon</td></tr><tr><td>phi</td><td>Φ</td><td>\Phi</td><td>ϕ</td><td>\phi</td></tr><tr><td>chi</td><td>X</td><td>X</td><td>χ</td><td>\chi</td></tr><tr><td>psi</td><td>Ψ</td><td>\Psi</td><td>ψ</td><td>\psi</td></tr><tr><td>omega</td><td>Ω</td><td>\Omega</td><td>ω</td><td>\omega</td></tr></tbody></table></div><h2 id="3-上下标"><a href="#3-上下标" class="headerlink" title="3. 上下标"></a>3. 上下标</h2><p>上标 $x^2$ : $x^2$</p><p>下标$x_1$ : $x_1$</p><p>组合$x^2_1$ : $x^2_1$</p><ul><li>注意：例如$x<em>{12}$源码为： $x</em>{12}$。注意其中的<strong>中括号{}</strong></li></ul><p>多级上标${x^5}^6$：需要用<strong>中括号{}</strong>划分界限$<strong>{</strong>x\^5<strong>}</strong>\^6$, $x\^<strong>{</strong>5\^6<strong>}</strong>$ 两种方式均可以</p><h2 id="4-括号"><a href="#4-括号" class="headerlink" title="4. 括号"></a>4. 括号</h2><h3 id="4-1-小括号与方括号"><a href="#4-1-小括号与方括号" class="headerlink" title="4.1 小括号与方括号"></a>4.1 小括号与方括号</h3><p>使用原始的<code>( )</code> ，<code>[ ]</code> 即可</p><p>如<script type="math/tex">(2+3)[4+4]</script>：$(2+3)[4+3]$</p><ul><li>复杂例子：</li></ul><p>$(\frac{x}{y})$： 可表示为<script type="math/tex">\left(\frac{x}{y}\right)</script> 或<script type="math/tex">(\frac{x}{y})</script></p><h3 id="4-2-大括号"><a href="#4-2-大括号" class="headerlink" title="4.2 大括号"></a>4.2 大括号</h3><p>由于大括号<code>&#123;&#125;</code> 被用于分组，因此需要使用<code>\&#123;</code>和<code>\&#125;</code>表示大括号，也可以使用<code>\lbrace</code> 和<code>\rbrace</code>来表示。</p><p>如<script type="math/tex">\{a*b\}:a∗b</script> 或<script type="math/tex">\lbrace a*b\rbrace :a*b</script>表示：${a*b}:a∗b$ </p><h3 id="4-3-尖括号"><a href="#4-3-尖括号" class="headerlink" title="4.3 尖括号"></a>4.3 尖括号</h3><p> 区分于小于号和大于号，使用<code>\langle</code> 和<code>\rangle</code> 表示左尖括号和右尖括号。如<script type="math/tex">\langle x \rangle</script> 表示：$\langle x \rangle$。</p><h2 id="5-求和与积分"><a href="#5-求和与积分" class="headerlink" title="5. 求和与积分"></a>5. 求和与积分</h2><h3 id="5-1-求和"><a href="#5-1-求和" class="headerlink" title="5.1 求和"></a>5.1 求和</h3><p><code>\sum</code> 用来表示求和符号，其下标表示求和下限，上标表示上限。</p><p>如:<script type="math/tex">\sum_{r=1}^n</script>表示：$\sum_{r=1}^n$</p><h3 id="5-2-积分"><a href="#5-2-积分" class="headerlink" title="5.2 积分"></a>5.2 积分</h3><p><code>\int</code> 用来表示积分符号，同样地，其上下标表示积分的上下限。如，<script type="math/tex">\int_{r=1}^\infty</script>表示：$\int_{r=1}^\infty$</p><p>多重积分同样使用 <strong>int</strong> ，通过 <strong>i</strong> 的数量表示积分导数：</p><p><code>\iint</code>表示： $\iint$，</p><p><code>\iint\</code>表示： $\iiint$，</p><p><code>\iiiint</code>表示： $\iiiint$，</p><h3 id="5-3-连乘"><a href="#5-3-连乘" class="headerlink" title="5.3 连乘"></a>5.3 连乘</h3><p><code>\prod &#123;a+b&#125;</code>，输出：$\prod {a+b}$</p><p><code>\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)</code>，输出：$\prod_{i=1}^{k}({a+b})$</p><p><code>\prod_&#123;i=1&#125;^&#123;k&#125;(&#123;a+b&#125;)</code>，输出<script type="math/tex">\prod_{i=1}^{k}({a+b})</script></p><h3 id="5-4-其他类似"><a href="#5-4-其他类似" class="headerlink" title="5.4 其他类似"></a>5.4 其他类似</h3><p><code>\prod</code> :  $\prod$</p><p><code>\bigcup</code> :   $\bigcup$</p><p><code>\bigcap</code> :   $\bigcap$</p><p><code>\arg\,\\max_&#123;c_k&#125;</code> : $arg\, \max{c_k}$</p><h2 id="6-分式与根式"><a href="#6-分式与根式" class="headerlink" title="6. 分式与根式"></a>6. 分式与根式</h2><h3 id="6-1-分式"><a href="#6-1-分式" class="headerlink" title="6.1 分式"></a>6.1 分式</h3><p>第一种，使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code> ，<code>b</code> ，结果为 $\frac ab$</p><p>如果你的分子或分母不是单个字符，请使用<code>&#123;..&#125;</code>来分组，比如<code>\frac &#123;a+c+1&#125;&#123;b+c+2&#125;</code>表示：$\frac {a+c+1}{b+c+2}$</p><p>第二种，使用<code>\over</code>来分隔一个组的前后两部分，如<code>&#123;a+1\over b+1&#125;</code>：${a+1\over b+1}$</p><h3 id="6-2-连分式"><a href="#6-2-连分式" class="headerlink" title="6.2 连分式"></a>6.2 连分式</h3><p>书写连分数表达式时，请使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：<br><code>\frac</code> 表示如下：</p><p><code>x=a_0 + \frac &#123;1^2&#125;&#123;a_1 + \frac &#123;2^2&#125;&#123;a_2 + \frac &#123;3^2&#125;&#123;a_3 + \frac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;</code></p><script type="math/tex; mode=display">x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + ...}}}}</script><p>\cfrac 表示如下：<code>x=a_0 + \cfrac &#123;1^2&#125;&#123;a_1 + \cfrac &#123;2^2&#125;&#123;a_2 + \cfrac &#123;3^2&#125;&#123;a_3 + \cfrac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;</code></p><script type="math/tex; mode=display">x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + ...}}}}</script><h3 id="6-3-根式"><a href="#6-3-根式" class="headerlink" title="6.3 根式"></a>6.3 根式</h3><p>根式使用<code>\sqrt</code> 来表示：$\sqrt{\pi}$</p><p>如开4次方：<code>\sqrt[4]&#123;\frac xy&#125;</code>:$\sqrt[4]{\frac xy}$</p><p>开平方：<code>\sqrt &#123;a+b&#125;</code>：$\sqrt {a+b}$</p><h2 id="7-多行表达式"><a href="#7-多行表达式" class="headerlink" title="7. 多行表达式"></a>7. 多行表达式</h2><h3 id="7-1-分类表达式"><a href="#7-1-分类表达式" class="headerlink" title="7.1 分类表达式"></a>7.1 分类表达式</h3><p>定义函数的时候经常需要分情况给出表达式，使用<code>\begin&#123;cases&#125;…\end&#123;cases&#125;</code> 。其中：</p><ul><li><p>使用<code>\\</code> 来分类</p></li><li><p>使用<code>&amp;</code> 指示需要对齐的位置，</p></li><li><p>使用<code>\</code> +<code>空格</code>表示空格。</p></li></ul><p>例子 1：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">f(n)</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line">\cfrac n2, &amp;<span class="keyword">if</span>\ n\ is\ even\\</span><br><span class="line">3n + <span class="number">1</span>, &amp;<span class="keyword">if</span>\  n\ is\ odd</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">f(n)\begin{cases}\cfrac n2, &if\ n\ is\ even\\3n + 1, &if\  n\ is\ odd\end{cases}</script><p>例子 2：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">L(Y,f(X)) =</span><br><span class="line">\<span class="keyword">begin</span>&#123;cases&#125;</span><br><span class="line"><span class="number">0</span>, &amp; \text&#123;Y = f(X)&#125;  \\</span><br><span class="line"><span class="number">1</span>, &amp; \text&#123;Y <span class="variable">$\</span>neq<span class="variable">$ </span>f(X)&#125;</span><br><span class="line">\<span class="keyword">end</span>&#123;cases&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">L(Y, f(X)) =\begin{cases}0, & \text{Y = f(X)}\\1, & \text{Y $\neq$ f(X)}\end{cases}</script><h3 id="7-2-多行表达式"><a href="#7-2-多行表达式" class="headerlink" title="7.2 多行表达式"></a>7.2 多行表达式</h3><p>有时候需要将一行公式分多行进行显示。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;\<span class="keyword">begin</span>&#123;split&#125; </span><br><span class="line">a&amp;=b+c-d \\ </span><br><span class="line">&amp;\quad +e-f\\ </span><br><span class="line">&amp;=g+h\\ </span><br><span class="line">&amp; =i </span><br><span class="line">\<span class="keyword">end</span>&#123;split&#125;\<span class="keyword">end</span>&#123;equation&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{equation}\begin{split}a&=b+c -d\\&\quad +e-f\\&=g+h\\&=i\end{split}\end{equation}</script><p> 其中begin{equation} 表示开始方程，end{equation} 表示方程结束；begin{split} 表示开始多行公式，end{split} 表示结束；公式中用\ 表示回车到下一行，&amp; 表示对齐的位置。</p><h3 id="7-3-方程组"><a href="#7-3-方程组" class="headerlink" title="7.3 方程组"></a>7.3 方程组</h3><p>使用<code>\begin&#123;array&#125;...\end&#123;array&#125;</code> 与<code>\left \&#123;</code> 与<code>\right.</code> 配合表示方程组:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\left \&#123; </span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\<span class="keyword">end</span>&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\left \{\begin{array}{c}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\\\end{array}\right.</script><h2 id="8-特殊函数与符号"><a href="#8-特殊函数与符号" class="headerlink" title="8. 特殊函数与符号"></a>8. 特殊函数与符号</h2><h3 id="8-1-三角函数"><a href="#8-1-三角函数" class="headerlink" title="8.1 三角函数"></a>8.1 三角函数</h3><p><code>\sin(x)</code>: $\sin(x)$</p><p><code>\arctan(x)</code>: $arctan(x)$</p><h3 id="8-2-比较运算符"><a href="#8-2-比较运算符" class="headerlink" title="8.2 比较运算符"></a>8.2 比较运算符</h3><p>小于(<code>\lt</code> )：$\lt$</p><p>大于(<code>\gt</code> )：$\gt$</p><p>小于等于(<code>\le</code> )：$\le$</p><p>大于等于(<code>\ge</code> )：$\ge$</p><p>不等于(<code>\ne</code> ) :$\ne$</p><p>可以在这些运算符前面加上<code>\not</code> ，如<code>\not\lt</code> :$\not \lt$</p><h3 id="8-3-集合运算符"><a href="#8-3-集合运算符" class="headerlink" title="8.3 集合运算符"></a>8.3 集合运算符</h3><p>并集(<code>\cup</code> ): $\cup$<br>交集(<code>\cap</code> ): $\cap$<br>差集(<code>\setminus</code> ): $\setminus$<br>子集(<code>\subset</code> ): $\subset$<br>真子集(<code>\subseteq</code> ): $\subseteq$<br>非子集(<code>\subsetneq</code> ): $\subsetneq$<br>父集(<code>\supset</code> ): $\supset$<br>属于(<code>\in</code> ): $\in$<br>不属于(<code>\notin</code> ): $\notin$<br>空集(<code>\emptyset</code> ): $\emptyset$<br>空(<code>\varnothing</code>): $\varnothing$</p><h3 id="8-4-排列"><a href="#8-4-排列" class="headerlink" title="8.4 排列"></a>8.4 排列</h3><p><code>\binom&#123;n+1&#125;&#123;2k&#125;</code>:$\binom{n+1}{2k}$</p><p><code>&#123;n+1 \choose 2k&#125;</code>: ${n+1 \choose 2k}$</p><h3 id="8-5-箭头"><a href="#8-5-箭头" class="headerlink" title="8.5 箭头"></a>8.5 箭头</h3><p><code>\to</code>: $\to$<br><code>\rightarrow</code>: $\rightarrow$<br><code>\leftarrow</code>: $\leftarrow$<br><code>\Rightarrow</code>: $\Rightarrow$<br><code>\Leftarrow</code>: $\Leftarrow$<br><code>\mapsto</code>: $\mapsto$</p><h3 id="8-6-逻辑运算符"><a href="#8-6-逻辑运算符" class="headerlink" title="8.6 逻辑运算符"></a>8.6 逻辑运算符</h3><p><code>\land</code>:$\land$<br><code>\lor</code>: $\lor$<br><code>\lnot</code>: $\lnot$<br><code>\forall</code>: $\forall$<br><code>\exists</code>: $\exists$<br><code>\top</code>: $\top$<br><code>\bot</code>: $\bot$<br><code>\vdash</code>: $\vdash$<br><code>\vDash</code>: $\vDash$</p><h3 id="8-7-模运算"><a href="#8-7-模运算" class="headerlink" title="8.7 模运算"></a>8.7 模运算</h3><p> <code>\mod 6</code>: $\mod 6$</p><p>  如<code>a \equiv b \mod n</code> : $a \equiv b \mod n$</p><h3 id="8-8-点"><a href="#8-8-点" class="headerlink" title="8.8 点"></a>8.8 点</h3><p><code>\ldots</code>: $\ldots$<br><code>\cdots</code>: $\cdots$<br><code>\cdot</code>:  $\cdot$<br>  其区别是点的位置不同，<code>\ldots</code> 位置稍低，<code>\cdots</code> 位置居中。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;equation&#125;</span><br><span class="line">a_1+a_2+\ldots+a_n \\ </span><br><span class="line">a_1+a_2+\cdots+a_n</span><br><span class="line">\<span class="keyword">end</span>&#123;equation&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><p>表示：</p><script type="math/tex; mode=display">\begin{equation}a_1+a_2+\ldots+a_n\\a_1+a_2+\cdots+a_n\\\end{equation}</script><h2 id="9-顶部符号"><a href="#9-顶部符号" class="headerlink" title="9. 顶部符号"></a>9. 顶部符号</h2><p>对于单字符，<code>\hat x</code> ：$\hat x$<br>多字符可以使用<code>\widehat &#123;xy&#125;</code> ：$\widehat {xy}$<br>类似的还有:<br><code>\overline x</code> : $\overline x$<br>矢量(<code>\vec x</code> ): $\vec x$<br>向量(<code>\overrightarrow &#123;xy&#125;</code> ): $\overrightarrow {xy}$<br>(<code>\dot x</code> ): $\dot x$<br>(<code>\ddot x</code> ): $\ddot x$<br>(<code>\dot &#123;\dot x&#125;</code> ): $\dot {\dot x}$</p><h2 id="10-表格"><a href="#10-表格" class="headerlink" title="10. 表格"></a>10. 表格</h2><p>使用<code>\begin&#123;array&#125;&#123;列样式&#125;…\end&#123;array&#125;</code> 这样的形式来创建表格，列样式可以是<code>clr</code> 表示居中，左，右对齐，还可以使用<code>|</code> 表示一条竖线。表格中各行使用<code>\\</code> 分隔，各列使用<code>&amp;</code> 分隔。使用<code>\hline</code> 在本行前加入一条直线。 例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;array&#125;&#123;c<span class="params">|lcr&#125;</span></span><br><span class="line"><span class="params">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\</span></span><br><span class="line"><span class="params">\hline</span></span><br><span class="line"><span class="params">1 &amp; 0.24 &amp; 1 &amp; 125 \\</span></span><br><span class="line"><span class="params">2 &amp; -1 &amp; 189 &amp; -8 \\</span></span><br><span class="line"><span class="params">3 &amp; -20 &amp; 2000 &amp; 1+10i \\</span></span><br><span class="line"><span class="params">\<span class="keyword">end</span>&#123;array&#125;</span></span><br><span class="line"><span class="params">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{array}{c|lcr}n & \text{Left} & \text{Center} & \text{Right} \\\hline1 & 0.24 & 1 & 125 \\2 & -1 & 189 & -8 \\3 & -20 & 2000 & 1+10i \\\end{array}</script><h2 id="11-矩阵"><a href="#11-矩阵" class="headerlink" title="11. 矩阵"></a>11. 矩阵</h2><h3 id="11-1-基本内容"><a href="#11-1-基本内容" class="headerlink" title="11.1 基本内容"></a>11.1 基本内容</h3><p>使用<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code> 这样的形式来表示矩阵，在<code>\begin</code> 与<code>\end</code> 之间加入矩阵中的元素即可。矩阵的行之间使用<code>\\</code> 分隔，列之间使用<code>&amp;</code> 分隔，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;matrix&#125;</span><br><span class="line"><span class="number">1</span> &amp; x &amp; x^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; y &amp; y^<span class="number">2</span> \\</span><br><span class="line"><span class="number">1</span> &amp; z &amp; z^<span class="number">2</span> \\</span><br><span class="line">\<span class="keyword">end</span>&#123;matrix&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{matrix}1 & x & x^2 \\1 & y & y^2 \\1 & z & z^2 \\\end{matrix}</script><h3 id="11-2-括号"><a href="#11-2-括号" class="headerlink" title="11.2 括号"></a>11.2 括号</h3><p>如果要对矩阵加括号，可以像上文中提到的一样，使用<code>\left</code> 与<code>\right</code> 配合表示括号符号。也可以使用特殊的<code>matrix</code> 。即替换<code>\begin&#123;matrix&#125;…\end&#123;matrix&#125;</code> 中<code>matrix</code> 为<code>pmatrix</code> ，<code>bmatrix</code> ，<code>Bmatrix</code> ，<code>vmatrix</code> , <code>Vmatrix</code> 。</p><ol><li><p>pmatrix<code>\begin&#123;pmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;pmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{pmatrix}1 & 2 \\ 3 & 4\\ \end{pmatrix}</script></li><li><p>bmatrix<code>\begin&#123;bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;bmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{bmatrix}1 & 2 \\ 3 & 4\\ \end{bmatrix}</script></li><li><p>Bmatrix<code>\begin&#123;Bmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Bmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{Bmatrix}1 & 2 \\ 3 & 4\\ \end{Bmatrix}</script></li><li><p>vmatrix<code>\begin&#123;vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;vmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{vmatrix}1 & 2 \\ 3 & 4\\ \end{vmatrix}</script></li><li><p>Vmatrix<code>\begin&#123;Vmatrix&#125;1 &amp; 2 \\ 3 &amp; 4\\ \end&#123;Vmatrix&#125;</code> : </p><script type="math/tex; mode=display">\begin{Vmatrix}1 & 2 \\ 3 & 4\\ \end{Vmatrix}</script></li></ol><h3 id="元素省略"><a href="#元素省略" class="headerlink" title="元素省略"></a>元素省略</h3><p>  可以使用<code>\cdots</code> ：⋯，<code>\ddots</code>：⋱ ，<code>\vdots</code>：⋮ 来省略矩阵中的元素，如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$$</span></span><br><span class="line">\<span class="keyword">begin</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="number">1</span>&amp;a_1&amp;a_1^<span class="number">2</span>&amp;\cdots&amp;a_1^n\\</span><br><span class="line"><span class="number">1</span>&amp;a_2&amp;a_2^<span class="number">2</span>&amp;\cdots&amp;a_2^n\\</span><br><span class="line">\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\</span><br><span class="line"><span class="number">1</span>&amp;a_m&amp;a_m^<span class="number">2</span>&amp;\cdots&amp;a_m^n\\</span><br><span class="line">\<span class="keyword">end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="variable">$$</span></span><br></pre></td></tr></table></figure><p>  表示：</p><script type="math/tex; mode=display">\begin{pmatrix}1&a_1&a_1^2&\cdots&a_1^n\\1&a_2&a_2^2&\cdots&a_2^n\\\vdots&\vdots&\vdots&\ddots&\vdots\\1&a_m&a_m^2&\cdots&a_m^n\\\end{pmatrix}</script><h3 id="增广矩阵"><a href="#增广矩阵" class="headerlink" title="增广矩阵"></a>增广矩阵</h3><p>  增广矩阵需要使用前面的表格中使用到的<code>\begin&#123;array&#125; ... \end&#123;array&#125;</code> 来实现。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\left[  \begin&#123;array&#125;  &#123;c c <span class="operator">|</span> c&#125; <span class="operator">%</span>这里的c表示数组中元素对其方式：c居中<span class="operator">、</span>r右对齐<span class="operator">、</span>l左对齐，竖线表示<span class="number">2</span><span class="operator">、</span><span class="number">3</span>列间插入竖线</span><br><span class="line"><span class="number">1</span> <span class="operator">&amp;</span> <span class="number">2</span> <span class="operator">&amp;</span> <span class="number">3</span> \\</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="operator">&amp;</span> <span class="number">5</span> <span class="operator">&amp;</span> <span class="number">6</span></span><br><span class="line">\end&#123;array&#125;  \right]</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示为：</p><script type="math/tex; mode=display">\left[  \begin{array}  {c c | c} %这里的c表示数组中元素对其方式：c居中、r右对齐、l左对齐，竖线表示2、3列间插入竖线1 & 2 & 3 \\4 & 5 & 6\end{array}  \right]</script><h2 id="12-公式标记与引用"><a href="#12-公式标记与引用" class="headerlink" title="12. 公式标记与引用"></a>12. 公式标记与引用</h2><p> 使用<code>\tag&#123;yourtag&#125;</code> 来标记公式，如果想在之后引用该公式，则还需要加上<code>\label&#123;yourlabel&#125;</code> 在<code>\tag</code> 之后，如<code>a = x^2 - y^3 \tag&#123;1&#125;\label&#123;1&#125;</code> 显示为：</p><script type="math/tex; mode=display">a = x^2 - y^3 \tag{12.1}</script><p>  如果不需要被引用，只使用<code>\tag&#123;yourtag&#125;</code> ，<code>x+y=z\tag&#123;1.1&#125;</code>显示为：</p><script type="math/tex; mode=display">x+y=z\tag{12.2}</script><p>  <code>\tab&#123;yourtab&#125;</code> 中的内容用于显示公式后面的标记。公式之间通过<code>\label&#123;&#125;</code> 设置的内容来引用。为了引用公式，可以使用<code>\eqref&#123;yourlabel&#125;</code> ，如<code>a + y^3 \stackrel&#123;\eqref&#123;1&#125;&#125;= x^2</code> 显示为：</p><script type="math/tex; mode=display">a + y^3 \stackrel{\eqref{1}}= x^2</script><p>或者使用<code>\ref&#123;yourlabel&#125;</code> 不带括号引用，如<code>a + y^3 \stackrel&#123;\ref&#123;111&#125;&#125;= x^2</code> 显示为：</p><script type="math/tex; mode=display">a + y^3 \stackrel{\ref{111}}= x^2</script><h2 id="13-字体"><a href="#13-字体" class="headerlink" title="13. 字体"></a>13. 字体</h2><h3 id="黑板粗体字"><a href="#黑板粗体字" class="headerlink" title="黑板粗体字"></a>黑板粗体字</h3><p>此字体经常用来表示代表实数、整数、有理数、复数的大写字母。<br> <code>\mathbb ABCDEF</code>：</p><p> <script type="math/tex">\Bbb ABCDEF</script>：</p><h3 id="黑体字"><a href="#黑体字" class="headerlink" title="黑体字"></a>黑体字</h3><p><code>\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> : $\mathbf ABCDEFGHIJKLMNOPQRSTUVWXYZ$<br><code>\mathbf abcdefghijklmnopqrstuvwxyz</code> :$\mathbf abcdefghijklmnopqrstuvwxyz$</p><h3 id="打印机字体"><a href="#打印机字体" class="headerlink" title="打印机字体"></a>打印机字体</h3><p><code>\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ</code> : $\mathtt ABCDEFGHIJKLMNOPQRSTUVWXYZ$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;行内公式是在公式代码块的基础上前面加上&lt;strong&gt;$&lt;/strong&gt; ，后面加上&lt;strong&gt;$&lt;/strong&gt; 组成的，而行间公式则是在公式代码块前后使用&lt;strong&gt;$$&lt;/strong&gt; 和&lt;strong&gt;$$&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=</summary>
      
    
    
    
    <category term="语言" scheme="https://gitflhub.github.io/categories/%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="LaTex" scheme="https://gitflhub.github.io/tags/LaTex/"/>
    
    <category term="数学公式" scheme="https://gitflhub.github.io/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AOP 面向切面编程</title>
    <link href="https://gitflhub.github.io/2021/05/26/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    <id>https://gitflhub.github.io/2021/05/26/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-26T13:01:42.000Z</published>
    <updated>2021-07-15T03:59:08.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1-面向切面编程的介绍"><a href="#4-1-面向切面编程的介绍" class="headerlink" title="4.1 面向切面编程的介绍"></a>4.1 面向切面编程的介绍</h3><p>横切关注点可以被描述为影响应用多处的功能。例如，安全就是一个横切关注点，应用中的许多方法都会涉及安全规则。图4.1直观呈现了横切关注点的概念。<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566608872495_E766F569F1A3A6E089CAE2976F7E7FD0" alt="图片说明" title="图片标题"><br>切面提供了取代继承和委托的另一种选择，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，可以通过声明的方式定义这个功能以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面。<br>好处：<br>每个关注点现在都只集中于一处，而不是分散到多处代码中；<br>其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</p><h4 id="4-1-1-定义AOP术语"><a href="#4-1-1-定义AOP术语" class="headerlink" title="4.1.1 定义AOP术语"></a>4.1.1 定义AOP术语</h4><p>AOP的术语：<br>通知（advice）、切点（pointcut）和连接点（joinpoint）。<br>他们之间的联系<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566608898589_FB8366D59260D0AF5790285AFF941560" alt="图片说明" title="图片标题"><br>通知（advice）：<br>切面的工作内容被称为通知。<br>通知定义了切面是什么以及何时使用。除了描述切面要完成的工作，通知还解决了何时执行这个工作的问题。它应该应用于某个方法被调用之前？之后？之前和之后？还是只在方法抛出异常时？Spring切面可以应用5种类型的通知。<br>■Before——在方法被调用之前调用通知。<br>■After——在方法完成之后调用通知，无论方法执行是否成功。<br>■After-returning——在方法成功执行之后调用通知。<br>■After-throwing——在方法抛出异常后调用通知。<br>■Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。<br><strong>连接点（Joinpoint）</strong><br>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。<br><strong>切点（Poincut）</strong><br>切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称模式来指定这些切点。有些AOP框架允许我们创建动态的切点，可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。<br><strong>切面（Aspect）</strong><br>切面是通知和切点的结合。通知和切点共同定义了关于切面的全部内容——它是什么，在何时和何处完成其功能。<br><strong>引入（Introduction）</strong><br>引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知类，该类记录了对象最后一次修改时的状态。这很简单，只需一种方法，setLastModified(Date)，和一个实例变量来保存这个状态。然后，这个新方法和实例变量就可以被引入到现有的类中。从而可以在无需修改这些现有的类的情况下，让它们具有新的行为和状态。<br><strong>织入（Weaving）</strong><br>织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入。<br>■编译期——切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译器就是以这种方式织入切面的。<br>■类加载期——切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5的LTW（load-timeweaving）就支持以这种方式织入切面。<br>■运行期——切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面的。</p><h4 id="4-1-2-Spring对AOP的支持"><a href="#4-1-2-Spring对AOP的支持" class="headerlink" title="4.1.2 Spring对AOP的支持"></a>4.1.2 Spring对AOP的支持</h4><p>Spring 提供 了 4 种 各具特色 的 AOP 支持：<br>■ 基于 代理 的 经典 AOP；<br>■@ AspectJ 注解 驱动 的 切面；<br>■ 纯 POJO 切面；<br>■ 注入 式 AspectJ 切面（ 适合 Spring 各 版本）。<br><strong>Spring通知是Java编写的</strong><br>Spring所创建的通知都是用标准的Java类编写的。这样的话，我们就可以使用与普通Java开发一样的集成开发环境（IDE）来开发切面。而且，定义通知所应用的切点通常在Spring配置文件里采用XML来编写的。这意味着切面的代码和配置语法对于Java开发人员来说是相当熟悉的。<br>AspectJ与之相反。虽然AspectJ现在支持基于注解的切面，但是AspectJ最初是以Java语言扩展的方式实现的。这种方式既有优点也有缺点。通过特有的AOP语言，我们可以获得更强大和细粒度的控制，以及更丰富的AOP工具集，但是我们需要额外学习新的工具和语法。<br><strong>Spring在运行期通知对象</strong><br>通过在代理类中包裹切面，Spring在运行期将切面织入到Spring管理的Bean中。代理类封装了目标类，并拦截被通知的方法的调用，再将调用转发给真正的目标Bean。<br>当拦截到方法调用时，在调用目标Bean方法之前，代理会执行切面逻辑。直到应用需要被代理的Bean时，Spring才创建代理对象。如果使用的是ApplicationContext，在ApplicationContext从BeanFactory中加载所有Bean时，Spring创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。<br>Spring只支持方法连接点正如前面所探讨过的，通过各种AOP实现可以支持多种连接点模型。因为Spring基于动态代理，所以Spring只支持方法连接点。这与其他一些AOP框架是不同的，例如AspectJ和Jboss，除了方法切点，它们还提供了字段和构造器接入点。Spring缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且Spring也不支持构造器连接点，我们也无法在Bean创建时应用通知。但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截，我们可以利用Aspect来协助SpringAOP。</p><h3 id="4-2-使用切点选择连接点"><a href="#4-2-使用切点选择连接点" class="headerlink" title="4.2 使用切点选择连接点"></a>4.2 使用切点选择连接点</h3><p>在SpringAOP中，需要使用AspectJ的切点表达式语言来定义切点。Spring仅支持AspectJ切点指示器（pointcutdesignator）的一个子集。Spring是基于代理的，而某些切点表达式是与基于代理的AOP无关的。<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566608972613_3A0E6EE02FAD7B1848A6B22C6A624FDC" alt="图片说明" title="图片标题"><br>在Spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。</p><h4 id="4-2-1-编写切点"><a href="#4-2-1-编写切点" class="headerlink" title="4.2.1 编写切点"></a>4.2.1 编写切点</h4><p>例如，如图4.4所示的切点表达式表示当Instrument的play()方法执行时会触发通知。我们使用execution()指示器选择Instrument的play()方法。方法表达式以*号开始，标识了我们不关心方法返回值的类型。然后，我们指定了全限定类名和方法名。对于方法参数列表，我们使用（..）标识切点选择任意的play()方法，无论该方法的入参是什么。<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566608994487_E1878029C2E9DA654BAFC131C8E6CDC9" alt="图片说明" title="图片标题"><br>现在 假设 我们 需要 配置 切点 仅 匹配 com. springinaction. springidol 包。 在此 场景 下， 可以 使用 within() 指示器 来 限制 匹配， 如图 4. 5 所示。<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566609010087_1BF8C8A5BE45566350FFE74F647784F3" alt="图片说明" title="图片标题"><br>&amp;&amp;操作符把execution()和within()指示器连接在一起形成and关系（切点必须匹配所有的指示器）。<br>因为&amp;在XML中有特殊含义，所以在使用Spring的基于XML配置来描述切点时，我们可以使用and来代替&amp;&amp;。同样，or和not可以使用||和!来分别代替。</p><h4 id="4-2-2-使用Spring的bean-指示器"><a href="#4-2-2-使用Spring的bean-指示器" class="headerlink" title="4.2.2 使用Spring的bean()指示器"></a>4.2.2 使用Spring的bean()指示器</h4><p>Spring2.5还引入了一个新的bean()指示器，该指示器允许我们在切点表达式中使用Bean的ID来标识Bean。bean()使用BeanID或Bean名称作为参数来限制切点只匹配特定的Bean。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com. springinaction. springidol. Instrument. play()) <span class="function">and <span class="title">bean</span><span class="params">(eddie)</span>。</span></span><br></pre></td></tr></table></figure><p>希望在执行Instrument的play()方法时应用通知，但限定Bean的ID为eddie。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* com. springinaction. springidol. Instrument. play()) and !bean(eddie) </span><br></pre></td></tr></table></figure><p>在此场景下，切面的通知会被编织到所有的ID不为eddie的Bean中。</p><h3 id="4-3在XML中声明切面"><a href="#4-3在XML中声明切面" class="headerlink" title="4.3在XML中声明切面"></a>4.3在XML中声明切面</h3><p>Spring的AOP配置元素简化了基于POJO切面的声明<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566609242460_B7EE8D40DFA2D4C41D33A35BAF9BDD02" alt="图片说明" title="图片标题"><br>定义一个类，然后再XML中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springidol;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : FL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> : com.springidol.Audience</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> :</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2019-08-21 21:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@describe</span> :</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;taking seats&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOffCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;turnOffCellPhones&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applaud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;applaud&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandrefund</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boo!We what our money back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件中声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audience&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Audience&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-1-声明前置后后置通知"><a href="#4-3-1-声明前置后后置通知" class="headerlink" title="4.3.1 声明前置后后置通知"></a>4.3.1 声明前置后后置通知</h4><p>把audienceBean变成一个切面<br>配置文件修改如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;takeSeats&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.springidol.Performer.perform(..))&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;turnOffCellPhones&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.springidol.Performer.perform(..))&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;applaud&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.springidol.Performer.perform())&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;demandrefund&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.springidol.Performer.perform())&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><aop:config>元素内，可以声明多个通知器、切面或者切点<br>两个<aop:before>元素定义了匹配切点的方法执行之前调用前置通知方法——audienceBean的takeSeats()和turnOffCellPhones()方法（由method属性所声明）。<aop:after-returning>元素定义了一个返回后（after-returning）通知，在切点所匹配的方法调用之后再执行applaud()方法。同样，<aop:after-throwing>元素定义了抛出后通知，如果所匹配的方式执行时抛出任何异常，都将调用demandRefund()方法。图4.6展示了通知逻辑如何编织到业务逻辑中。<br> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566609263845_5F9DE531E571A90987342F3D36B3C60E" alt="图片说明" title="图片标题"><br>在所有的通知元素中，pointcut属性定义了通知所应用的切点。pointcut属性的值是使用AspectJ切点表达式语法所定义的切点。<br>使用<aop:pointcut>元素来定义一个可以在所有的通知元素中使用的命名切点。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;audience&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Audience&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;performance&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.springidol.Performer.perform())&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;takeSeats&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;turnOffCellPhones&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;applaud&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;demandrefund&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-2-声明环绕通知"><a href="#4-3-2-声明环绕通知" class="headerlink" title="4.3.2 声明环绕通知"></a>4.3.2 声明环绕通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;takingSeats&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;turningoffphone&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;clap&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;time:&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;money back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于新的通知方法，我们首先会注意到它使用了ProceedingJoinPoint作为方法的入参。这个对象非常重要，因为它能让我们在通知里调用被通知方法。通知方法可以完成任何它所需要做的事情，而且如果希望把控制转给被通知的方法时，我们可以调用ProceedingJoinPoint的proceed()方法。谨记我们必须调用proceed()方法。如果忘记这样做，通知将会阻止被通知的方法的调用。或许这正是我们所需要的，但是更好的方式是在某一点执行被通知的方法。更有意思的是，正如我们可以忽略调用proceed()方法来阻止执行被通知的方法，我们还可以在通知里多次调用被通知的方法。这样做的一个原因是实现重试逻辑，在被通知的方法执行失败时反复重试。在此示例中的audience切面，watchPerformance()方法包含之前4个通知方法的所有逻辑，但所有的逻辑都放在一个单独的方法中了，而且该方法还会负责自身的异常处理。同时我们也注意到在连接点的proceed()方法被调用之前，当前时间被记录在一个局部变量中；当方法返回后，系统会打印执行时间。声明环绕通知与声明其他类型的通知并没有太大区别。我们所需要做的仅仅是使用</p><p><aop:around>元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;audience&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;performance2&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.springidol.Performer.perform())&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;watchPerformance&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;performance2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-3-3-为通知传递参数"><a href="#4-3-3-为通知传递参数" class="headerlink" title="4.3.3 为通知传递参数"></a>4.3.3 为通知传递参数</h4><p>切面和实例化对象进行传参：<br>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;volunteer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Volunteer&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;magician&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Magician&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;magician&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;thinking1&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.springidol.Volunteer.setVolunteerThoughts(String)) and args(thoughts)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;thinking1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;interceptThoughts&quot;</span> <span class="attr">arg-names</span>=<span class="string">&quot;thoughts&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中Volunteer和Magician的定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volunteer</span> <span class="keyword">implements</span> <span class="title">Thinker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String volunteerThoughts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thinkOfSomething</span><span class="params">(String volunteerThoughts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.volunteerThoughts = volunteerThoughts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getThoughts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> volunteerThoughts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Magician</span> <span class="keyword">implements</span> <span class="title">MindReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String thoughts;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interceptThoughts</span><span class="params">(String thoughts)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Intercepting...............&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.thoughts = thoughts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getThoughts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thoughts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-通过切面引入新功能"><a href="#4-3-4-通过切面引入新功能" class="headerlink" title="4.3.4 通过切面引入新功能"></a>4.3.4 通过切面引入新功能</h4><p> <img src="https://uploadfiles.nowcoder.com/images/20190824/802092387_1566609281913_A131396199707E772EC51BF27DC0DFA4" alt="图片说明" title="图片标题"><br>当引入接口的方法被调用时，代理将此调用委托给实现了新接口的某个其他对象。实际上，Bean的实现被拆分到了多个类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:aspect&gt;</span><br><span class="line">        &lt;aop:declare-parents types-matching=&quot;com.springidol.Performer+&quot; implement-interface=&quot;com.springidol.Contestant&quot; default-impl=&quot;com.springidol.GraciousContestant&quot; /&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p>暂时不懂要干嘛</p><h3 id="4-4注解切面"><a href="#4-4注解切面" class="headerlink" title="4.4注解切面"></a>4.4注解切面</h3><p>使用注解来创建切面是AspectJ5所引入的关键特性。AspectJ5之前，编写As-pectJ切面需要学习一种Java语言的扩展，但是AspectJ面向注解的模型可以非常简便地通过少量注解把任意类转变为切面。这种新特性通常称为@AspectJ。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audience</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.springidol.Performer.perform())&quot;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeSeats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;taking seats&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOffCellPhones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;turnOffCellPhones&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;performance()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applaud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;applaud&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demandFraud</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Boo!We what our money back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//            System.out.println(&quot;takingSeats&quot;);</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;turningoffphone&quot;);</span></span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//            System.out.println(&quot;clap&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;time:&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;money back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的Audience类现在已经使用@AspectJ注解进行了标注。该注解标识了Audience不仅仅是一个POJO，还是一个切面。@Pointcut注解用于定义一个可以在@AspectJ切面内可重用的切点。@Pointcut注解的值是一个AspectJ切点表达式——这里标识该切点必须匹配Performer的perform()方法。切点的名称来源于注解所应用的方法名称。因此，该切点的名称为performance()。performance()方法的实际内容并不重要，在这里它事实上是空的。其实该方法本身只是一个标识，供@Pointcut注解依附。<br>Audience的每一个方法都使用了通知注解来标注。takeSeats()和turnOffCellPhones()方法使用@Before注解来标识它们是前置通知方法。applaud()方法使用@AfterReturning注解来标识它是后置通知方法，而demandRefund()方法使用了@AfterThrowing注解，所以如果在表演时抛出任何异常，该方法都会被调用。<br>performance()切点的名称作为参数的值赋给了所有的通知注解。以这种方式来标识每一个通知方法应该应用在哪里。注意，除了那些注解和无操作的performance()方法，Audience类在实现上并没有任何改变。这意味着Audience仍然是一个简单的Java对象，能够像以前一样使用。该类仍然可以像下面一样在Spring中进行装配：</p><p><bean id="audience" class="com.springinaction.springidol.Audience"/><br>因为Audience类本身包含了所有它所需要定义的切点和通知，所以我们不再需要在XML配置中声明切点和通知。最后一件需要做的事是让Spring将Audience应用为一个切面。我们需要在Spring上下文中声明一个自动代理Bean，该Bean知道如何把@AspectJ注解所标注的Bean转变为代理通知。<br>为此，Spring自带了名为AnnotationAwareAspectJAutoProxyCreator的自动代理创建类。我们可以在Spring上下文中把AnnotationAwareAspectJAutoProxyCreator注册为一个Bean，但是我们需要需要 敲一大段的文字（相信我……我之前敲过几次了）。因此，为了简化如此长的名字，Spring在aop命名空间中提供了一个自定义的配置元素，该元素很容易被记住：</p><p><aop:aspectj-autoproxy/></p><p><aop:aspectj-autoproxy/>将在Spring上下文中创建一个AnnotationAwareAspectJAutoProxyCreator类，它会自动代理一些Bean，这些Bean的方法需要与使用@Aspect注解的Bean中所定义的切点相匹配，而这些切点又是使用@Pointcut注解定义出来的。<br>为了使用<aop:asepctj-autoproxy>配置元素，我们需要在Spring的配置文件中包含aop命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance xmlns:aop=”http://www.springframework.org/schema/aop” xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><p>我们需要记住<aop:asepectj-autoproxy>仅仅使用@AspectJ注解作为指引来创建基于代理的切面，但本质上它仍然是一个Spring风格的切面。这非常有意义，因为这意味着虽然我们使用@AspectJ的注解，但是我们仍然限于代理方法的调用。如果想利用AspectJ的所有能力，我们必须在运行时使用AspectJ并不依赖Spring来创建基于代理的切面。<br>同样值得一提的是，<aop:aspect>元素和@AspectJ注解都是把一个POJO转变为一个切面的有效方式。但是<aop:aspect>相对于@AspectJ的一个明显优势是我们不需要实现切面功能的源码。通过@AspectJ，我们必须标注类和方法，它需要有源码。而<aop:aspect>可以引用任意一个Bean。</p><h4 id="4-4-1-注解环绕通知"><a href="#4-4-1-注解环绕通知" class="headerlink" title="4.4.1 注解环绕通知"></a>4.4.1 注解环绕通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot; performance()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchPerformance</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;takingSeats&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;turningoffphone&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;clap&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;time:&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;money back&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是简单地使用@Around注解来标注方法并不足以调用proceed()方法，因此，被环绕通知的方法必须接受一个ProceedingJoinPoint对象作为方法入参，并在对象上调用proceed()方法。</p><h4 id="4-4-2-传递参数给所标注的通知"><a href="#4-4-2-传递参数给所标注的通知" class="headerlink" title="4.4.2 传递参数给所标注的通知"></a>4.4.2 传递参数给所标注的通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Magician</span> <span class="keyword">implements</span> <span class="title">MindReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String thoughts;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.springidol.&quot; + &quot;Thinker.thinkOfSomething(String)) &amp;&amp; args(thoughts)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thinking</span><span class="params">(String thoughts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;thinking(thoughts)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interceptThoughts</span><span class="params">(String thoughts)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Intercepting...............&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.thoughts = thoughts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getThoughts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thoughts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><aop:pointcut>元素变为@Pointcut注解，而<aop:before>元素变为@Before注解。在这里，唯一发生显著变化的是@AspectJ能够依靠Java语法来判断为通知所传递参数的细节。因此，这里并不需要与<aop:before>元素的argnames属性所对应的注解。</p><p>Spring提供了几种技巧，可以帮助我们减少XML的配置数量。<br><strong>自动装配</strong>（autowiring）有助于减少甚至消除配置<property>元素和<constructor-arg>元素，让Spring自动识别如何装配Bean的依赖关系。<br><strong>自动检测</strong>（autodiscovery）比自动装配更进了一步，让Spring能够自动识别哪些类需要被配置成SpringBean，从而减少对<bean>元素的使用。当自动装配和自动检测一起使用时，它们可以显著减少Spring的XML配置数量。通常只需要配置少量的几行XML代码，而无需知道在Spring的应用上下文中究竟有多少Bean。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;4-1-面向切面编程的介绍&quot;&gt;&lt;a href=&quot;#4-1-面向切面编程的介绍&quot; class=&quot;headerlink&quot; title=&quot;4.1 面向切面编程的介绍&quot;&gt;&lt;/a&gt;4.1 面向切面编程的介绍&lt;/h3&gt;&lt;p&gt;横切关注点可以被描述为影响应用多处的功能。例如，安全</summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="AOP" scheme="https://gitflhub.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Bean的操作</title>
    <link href="https://gitflhub.github.io/2021/05/26/Bean%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://gitflhub.github.io/2021/05/26/Bean%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2021-05-26T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:53.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2-1-声明Bean"><a href="#2-1-声明Bean" class="headerlink" title="2.1 声明Bean"></a>2.1 声明Bean</h3><h4 id="2-1-1创建Spring配置"><a href="#2-1-1创建Spring配置" class="headerlink" title="2.1.1创建Spring配置"></a>2.1.1创建Spring配置</h4><p>Spring提供两种装配Bean的方式。传统上Spring使用多个XML文件作为配置文件。<br>也可以采用基于Java注解的配置方式。<br>在XML文件中声明Bean时，Spring配置文件的根元素是来源于Spring beans命名空间所定义的<beans>元素。Spring XML配置文件例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot; 1. 0&quot; encoding=&quot; UTF- 8&quot;?&gt; </span><br><span class="line">&lt; beans xmlns=&quot; http:// www. springframework. org/ schema/ beans&quot; xmlns: xsi=&quot; http:// www. w3. org/ 2001/ XMLSchema- instance&quot; xsi: schemaLocation=&quot; http:// www. springframework. org/ schema/ beans http:// www. springframework. org/ schema/ beans/ spring- beans- 3. 0. xsd&quot;&gt; </span><br><span class="line"><span class="comment">&lt;!-- Bean declarations go here --&gt;</span> </span><br><span class="line">&lt;/ beans&gt;</span><br></pre></td></tr></table></figure><p>在beans元素内，可以放置所有的Spring配置信息。<br>Spring的核心框架自带了10个命名空间。<br><img src="https://uploadfiles.nowcoder.com/images/20190819/802092387_1566229489947_1DB20C1C030ACEF84B17A298B49861BE" alt="图片说明" title="图片标题"> </p><h4 id="2-1-2声明一个简单的Bean"><a href="#2-1-2声明一个简单的Bean" class="headerlink" title="2.1.2声明一个简单的Bean"></a>2.1.2声明一个简单的Bean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com. springinaction. springidol;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Juggler</span> <span class="keyword">implements</span> <span class="title">Performer</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> beanBags = <span class="number">3</span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Juggler</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Juggler</span><span class="params">( <span class="keyword">int</span> beanBags)</span> </span>&#123; <span class="keyword">this</span>. beanBags = beanBags; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> <span class="keyword">throws</span> PerformanceException </span>&#123; System. out. println(<span class="string">&quot; JUGGLING &quot;</span> + beanBags + <span class="string">&quot; BEANBAGS&quot;</span>); &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”duke”</span> <span class="attr">class</span>=<span class="string">”com.springinaction.springidol.Juggler”</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过<bean>的配置方式。创建了一个由Spring容器管理的名字为duke的Juggler的Bean，其中id属性定义了Bean的名字，也作为该Bean在Spring容器中的引用。<br>在Spring容器加载Bean时，Spring将使用默认的构造器来实例化duke</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> com.springinacation.springidol.Juggler();</span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext( <span class="string">&quot;com/ springinaction/ springidol/ spring- idol. xml&quot;</span>); </span><br><span class="line">Performer performer = (Performer) ctx. getBean(<span class="string">&quot; duke&quot;</span>); </span><br><span class="line">performer. perform();</span><br></pre></td></tr></table></figure><h4 id="2-1-3通过构造器注入"><a href="#2-1-3通过构造器注入" class="headerlink" title="2.1.3通过构造器注入"></a>2.1.3通过构造器注入</h4><p>1，Juggler类能够以两种不同的方式构造：<br>■使用默认的构造器；<br>■使用带有一个int参数的构造方法，该参数设置了Juggler可以同时抛在空中的豆袋子的个数。<br>带参数的配置方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”duke”</span> <span class="attr">class</span>=<span class="string">”com.springinaction.springidol.Juggler”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">”15”</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><constructor-arg>的value属性设置为15<br>通过构造器注入对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package com. springinaction. springidol;</span><br><span class="line">public class PoeticJuggler extends Juggler &#123; </span><br><span class="line">    private Poem poem;</span><br><span class="line"></span><br><span class="line">    public PoeticJuggler(Poem poem) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.poem = poem;</span><br><span class="line">    &#125;</span><br><span class="line">    public PoeticJuggler(int beanBags, Poem poem) &#123;</span><br><span class="line">        super(beanBags);</span><br><span class="line">        this.poem = poem;</span><br><span class="line">    &#125;</span><br><span class="line">    public void perform() throws PerformanceException &#123; </span><br><span class="line">super.perform();</span><br><span class="line">        System. out. println(&quot; JUGGLING &quot; + beanBags + &quot; BEANBAGS&quot;); </span><br><span class="line">        poem.recite();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poem接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com. springinaction. springidol;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Poem</span> </span>&#123; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recite</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com. springinaction. springidol; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sonnet29</span> <span class="keyword">implements</span> <span class="title">Poem</span> </span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String[] LINES = &#123; </span><br><span class="line"><span class="string">&quot;When, in disgrace with fortune and men&#x27; s eyes,&quot;</span>, </span><br><span class="line"><span class="string">&quot;I all alone beweep my outcast state&quot;</span>, </span><br><span class="line"><span class="string">&quot;And trouble deaf heaven with my bootless cries&quot;</span>, </span><br><span class="line"><span class="string">&quot;And look upon myself and curse my fate,&quot;</span>, </span><br><span class="line"><span class="string">&quot;Wishing me like to one more rich in hope,&quot;</span>, </span><br><span class="line"><span class="string">&quot;Featured like him, like him with friends possess&#x27; d,&quot;</span>,</span><br><span class="line"><span class="string">&quot;Desiring this man&#x27; s art and that man&#x27; s scope,&quot;</span>,</span><br><span class="line"><span class="string">&quot;With what I most enjoy contented least;&quot;</span>, </span><br><span class="line"><span class="string">&quot;Yet in these thoughts myself almost despising,&quot;</span>,</span><br><span class="line"><span class="string">&quot;Haply I think on thee, and then my state,&quot;</span>,</span><br><span class="line"><span class="string">&quot;Like to the lark at break of day arising&quot;</span>,</span><br><span class="line"><span class="string">&quot;From sullen earth, sings hymns at heaven&#x27; s gate;&quot;</span>,</span><br><span class="line"><span class="string">&quot;For thy sweet love remember&#x27; d such wealth brings&quot;</span>,</span><br><span class="line"><span class="string">&quot;That then I scorn to change my state with kings.&quot;</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Sonnet29</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recite</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LINES. length; i++) &#123; </span><br><span class="line">System. out. println(LINES[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以XML将Sonn t29声明为一个Spring<bean>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”sonnett29”</span> <span class="attr">class</span>=<span class="string">”com.springinaction.springidol.Sonnect29”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>有了poem，现将poem赋于Duke。<bean>声明如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;poeticDuke&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.springidol.PoeticJuggler&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;sonnet29&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过工厂方法创建Bean<br>有时候静态工厂方法是实例化对象的唯一方法。Spring支持通过<bean>元素的factory-method属性来装配工厂创建的Bean。<br>为单例类配置Bean</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”theStage”</span> <span class="attr">class</span>=<span class="string">”</span> <span class="attr">com.springinaction.springidol.PoeticJuggler</span>” <span class="attr">factory-method</span>=<span class="string">”getInstance”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这种配置方式可以用来创建静态方法</p><h4 id="2-1-4-Bean的作用域"><a href="#2-1-4-Bean的作用域" class="headerlink" title="2.1.4 Bean的作用域"></a>2.1.4 Bean的作用域</h4><p>当在Spring中配置<bean>元素时，我们可以为Bean声明一个作用域。为了让Spring在每次请求时都为Bean产生一个新的实例，则需要配置scope属性为prototype即可。例如，把演出门票声明为Spring Bean:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">”ticket”</span> <span class="attr">class</span>=<span class="string">”</span> <span class="attr">com.springinaction.springidol.PoeticJuggler</span>” <span class="attr">scope</span>=<span class="string">”prototype”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>除了prototype，Spring还提供了其他几个作用域的选项。<br> <img src="https://uploadfiles.nowcoder.com/images/20190819/802092387_1566229508182_AB0D0BAC02A7431FFADE7BB063A05FCB" alt="图片说明" title="图片标题"> </p><h4 id="2-1-5初始化和销毁Bean"><a href="#2-1-5初始化和销毁Bean" class="headerlink" title="2.1.5初始化和销毁Bean"></a>2.1.5初始化和销毁Bean</h4><p>Spring提供了Bean生命周期的钩子方法。<br>为了Bean定义初始化和销毁操作，只需要使用init-method和destroy-method参数来配置<bean>元素。<br>为bean定义初始化和销毁操作，只需要使用init-method和destory-method参数来配置<bean>元素。<br>如舞台类活动Auditorium</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Auditorium</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOnLights</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        . </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOffLights</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    . </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实例化对象的初始化和注销需求，我们可以使用initmethod和destorymethod属性来声明auditoriumBean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;auditorium&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.springidol.Auditorium&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;turnOnLights&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;turnOffLights&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>这样的配置方式会让auditoriumBean实例化后会立即调用turnOn-Lights()方法。在该Bean从容器移除和销毁前，会调用turnOffLights()<br>InitializingBean和DisposableBean<br>为Bean定义初始化和销毁方法的另一种可选方式是，让Bean实现Spring的InitializingBean和DisposableBean接口。Spring容器以特殊的方式对待实现这两个接口的Bean，允许它们进入Bean的生命周期。InitializingBean声明了一个afterPropertiesSet()方法作为初始化方法。而DisposableBean声明了一个destroy()方法，该方法在Bean从应用上下文移除时会被调用。使用这些生命周期接口的最大好处就是Spring能够自动检测实现了这些接口的Bean，而无需额外的配置。实现这些接口的缺点是Bean与Spring的API产生了耦合。就因为这条理由，所以我还是推荐使用init-method和destory-method属性来初始化和销毁Bean。唯一可能使用Spring的生命周期接口的场景是，开发一个明确在Spring容器内使用的框架Bean。<br>可以使用<beans>元素的default-init-method和default-destory-method属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot; 1. 0&quot; encoding=&quot; UTF- 8&quot;?&gt; </span><br><span class="line">&lt; beans xmlns=&quot; http:// www. springframework. org/ schema/ beans&quot; xmlns: xsi=&quot; http:// www. w3. org/ 2001/ XMLSchema- instance&quot; xsi: schemaLocation=&quot; http:// www. springframework. org/ schema/ beans http:// www. springframework. org/ schema/ beans/ spring- beans- 3. 0. xsd&quot; </span><br><span class="line">default- init- method=&quot; turnOnLights&quot; </span><br><span class="line">default- destroy- method=&quot; turnOffLights&quot;&gt;</span><br><span class="line"> ... </span><br><span class="line">&lt;/ beans&gt;</span><br></pre></td></tr></table></figure><p>default-init-method属性为应用上下文中所有的Bean设置了共同的初始化方法。类似的是，default-destory-method为应用上下文中所有的Bean设置了一个共同的销毁方法。</p><h3 id="2-2注入Bean属性"><a href="#2-2注入Bean属性" class="headerlink" title="2.2注入Bean属性"></a>2.2注入Bean属性</h3><h4 id="2-2-1注入Bean属性"><a href="#2-2-1注入Bean属性" class="headerlink" title="2.2.1注入Bean属性"></a>2.2.1注入Bean属性</h4><p>使用<property>元素配置Bean的属性。<property>在许多方面与<constructor-arg>类似。</p><p><constructor-arg>通过构造参数来注入值</p><p><property>通过setter方式来注入值<br>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beanid=&quot;kenny&quot;class=&quot;com.springinaction.springidol.Instrumentalist&quot;&gt;</span><br><span class="line">&lt;propertyname=&quot;song&quot;value=&quot;JingleBells&quot;/&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一旦Instrumentalist被实例化，Spring就会调用<property>元素所指定属性的setter方法为该属性注入值。在这段XML代码中，<property>元素会指示Spring调用setSong()方法将song属性的值设置为“JingleBells”。<br>但是<property>元素并没有限制只能注入String类型的值，value属性同样可以指定数值型（int、float、java.lang.Double等）以及boolen型的值。<br>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; kenny&quot;</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. Instrumentalist&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; song&quot;</span> <span class="attr">value</span>=<span class="string">&quot; Jingle Bells&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; age&quot;</span> <span class="attr">value</span>=<span class="string">&quot; 37&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2引用其他Bean"><a href="#2-2-2引用其他Bean" class="headerlink" title="2.2.2引用其他Bean"></a>2.2.2引用其他Bean</h4><p>程序清单2.6 saxophone实现了Instrument接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springinaction.springidol;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Saxophone</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Saxophone</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TOOT TOOT TOOT&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; saxophone&quot;</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. Saxophone&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; kenny2&quot;</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. Instrumentalist&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; song&quot;</span> <span class="attr">value</span>=<span class="string">&quot; Jingle Bells&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; instrument&quot;</span> <span class="attr">ref</span>=<span class="string">&quot; saxophone&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>调用方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;com/springinaction/ springidol/spring- idol. xml&quot;</span>); </span><br><span class="line">Performer performer = (Performer) ctx. getBean(<span class="string">&quot; kenny&quot;</span>);</span><br><span class="line">performer. perform();</span><br></pre></td></tr></table></figure><p>注入内部 Bean<br>重新配置了kenny Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; kenny&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.springidol.Instrumentalist&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; song&quot;</span> <span class="attr">value</span>=<span class="string">&quot; Jingle Bells&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; instrument&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot; org. springinaction. springidol. Saxophone&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内部Bean是通过直接声明一个<bean>元素作为<prop-erty>元素的子节点而定义的。<br>内部Bean并不限于setter注入，还可以把内部Bean装配到构造方法的入参中<br>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; duke&quot;</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. PoeticJuggler&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-</span> <span class="attr">arg</span> <span class="attr">value</span>=<span class="string">&quot; 15&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-</span> <span class="attr">arg</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. Sonnet29&quot;</span> /&gt;</span> </span><br><span class="line">&lt;/constructor- arg&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意内部Bean没有ID属性，说明内部Bean不能被复用。内部Bean仅仅适用于一次注入。而且也不能被其他Bean所引用。</p><h4 id="2-2-3使用Spring的命名空间p装配属性"><a href="#2-2-3使用Spring的命名空间p装配属性" class="headerlink" title="2.2.3使用Spring的命名空间p装配属性"></a>2.2.3使用Spring的命名空间p装配属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; kenny&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.springidol.Instrumentalist&quot;</span> <span class="attr">p:</span> <span class="attr">song</span> = <span class="string">&quot;Jingle Bells&quot;</span> <span class="attr">p:</span> <span class="attr">instrument-ref</span> = <span class="string">&quot;saxophone&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>p:song属性的值被设置为“JingleBells”，将使用该值装配song属性。同样，p:instrument-ref属性的值被设置为“saxophone”，将使用一个ID为saxophone的Bean引用来装配instrument属性。-ref后缀作为一个标识来告知Spring应该装配一个引用而不是字面值。</p><h4 id="2-2-4装配集合"><a href="#2-2-4装配集合" class="headerlink" title="2.2.4装配集合"></a>2.2.4装配集合</h4><p>当配置集合类型的Bean属性时，Spring提供了4种类型的集合配置元素。<br> <img src="https://uploadfiles.nowcoder.com/images/20190819/802092387_1566229540614_EF91E2DACAD99DFB4BBE9DCA129FC2E6" alt="图片说明" title="图片标题"><br>当装配类型为数组或者java.util.Collection任意实现的属性时，<list>和<set>元素非常有用。我们很快就会看到，其实属性实际定义的集合类型与选择<list>或者<set>元素没有任何关系。如果属性为任意的java.util.Collec-tion类型时，这两个配置元素在使用时几乎可以完全互换。</p><p><map>和<props>这两个元素分别对应java.util.Map和java.util.Properties。当我们需要由键-值对组成的集合时，这两种配置元素非常有用。这两种配置元素的关键区别在于，<props>要求键和值都必须为String类型，而<map>允许键和值可以是任意类型。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class OneManBand implements PerformanceException &#123;</span><br><span class="line">public OneManBand() &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public void perform() &#123;</span><br><span class="line">for(Instrument instrument : implements) &#123;</span><br><span class="line">instrument.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Collection&lt;Instrument&gt; implements;</span><br><span class="line"></span><br><span class="line">private void setInstruments(Collection&lt;Instrument&gt; implements) &#123;</span><br><span class="line">this.implements = implement;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>装配List、Set和Array<br>让我们使用<list>配置元素，为Hank赋予表演时所用到的乐器集合：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; hank&quot;</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. OneManBand&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; instruments&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; guitar&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; cymbal&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; harmonica&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.<list>元素包含一个或多个值。这里的<ref>元素用来定义Spring上下文中的其他Bean引用，当然还可以使用其他的Spring设值元素作为<list>的成员，包括<value>、<bean>和<null/>。实际上，<list>可以包含另外一个<list>作为其成员，形成多维列表。<br>中，OneManBand的instruments属性为java.util.Collection类型，使用了Java5范型来限制集合中的元素必须为Instrument类型。如果Bean的属性类型为数组类型或java.util.Collection接口的任意实现，都可以使用<list>元素。换句话说，即使像下面那样配置instruments属性，<list>元素也一样有效：<br>使用Set装配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot; hank&quot;</span> <span class="attr">class</span>=<span class="string">&quot; com. springinaction. springidol. OneManBand&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot; instruments&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; guitar&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; cymbal&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; harmonica&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot; harmonica&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无论<list>还是<set>都可以用来装配类型为java.util.Collection的任意实现或者数组的属性。不能因为属性为java.util.Set类型，就表示用户必须使用<set>元素来完成装配。</p><p>装配Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneManBand</span> <span class="keyword">implements</span> <span class="title">PerformanceException</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Instrument&gt; instruments;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OneManBand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> <span class="keyword">throws</span> PerformanceException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : instruments.keySet()) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">            Instrument instrument = instruments.get(key);</span><br><span class="line">            instrument.play();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstruments</span><span class="params">(Map&lt;String, Instrument&gt; instruments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instruments = instruments;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hank&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.OneManBand&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;instruments&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;saxophone&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;saxophone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;piano&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;piano&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>装配Properties集合<br>当将OneManBand的instrument属性声明为Map类型时，需要使用value-ref指定每一个entry的值。这是因为每一个entry最终都会成为Spring上下文中的一个Bean。但是如果所配置Map的每一个entry的键和值都为String类型时，我们可以考虑使用java.util.Properties代替Map。Properties类提供了和Map大致相同的功能，但是它限定键和值必须为String类型。为了演示，OneManBand使用String-to-String的java.util.Propeties集合来装配，代替之前键为String类型而值为Bean引用的Map。修改后的instruments属性如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">perform</span><span class="params">()</span> <span class="keyword">throws</span> PerformanceException </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; instrumentsObject = instruments.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span>(String key : instrumentsObject) &#123;</span><br><span class="line">            String instrumentValue = instruments.getProperty(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;:&quot;</span> + instrumentValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstruments</span><span class="params">(Properties instruments)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instruments = instruments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;instruments&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;saxophone&quot;</span>&gt;</span>saxophonesaxophonesaxophone<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;piano&quot;</span>&gt;</span>pianopianopiano<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><props>元素构建了一个java.util.Properties值，这个Properties的每一个成员都由<prop>元素定义。每一个<prop>元素都有一个key属性，其定义了Properties每个成员的键，而每一个成员的值由<prop>元素的内容所定义。在我们的示例中，键为“GUITAR”的元素，它的值为“STRUMSTRUMSTRUM”。这可能是我们所讨论的最复杂的Spring配置元素了。这是因为术语属性（property）包含了太多的含义。请牢记下面的配置要点：<br>■<property>元素用于把值或Bean引用注入到Bean的属性中；<br>■<props>元素用于定义一个java.util.Properties类型的集合值；<br>■<prop>元素用于定义<props>集合的一个成员。</p><h4 id="2-2-5装配空值"><a href="#2-2-5装配空值" class="headerlink" title="2.2.5装配空值"></a>2.2.5装配空值</h4><p>除了为Bean的属性或构造器参数装配其他任意类型的值外，Spring还可以装配一个空值。或者更准确地讲，Spring可以装配null值。<br>为属性设置null值，只需使用<null/>元素。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someNonNullProperty&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;2-1-声明Bean&quot;&gt;&lt;a href=&quot;#2-1-声明Bean&quot; class=&quot;headerlink&quot; title=&quot;2.1 声明Bean&quot;&gt;&lt;/a&gt;2.1 声明Bean&lt;/h3&gt;&lt;h4 id=&quot;2-1-1创建Spring配置&quot;&gt;&lt;a href=&quot;#2-1-1创</summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="Bean" scheme="https://gitflhub.github.io/tags/Bean/"/>
    
  </entry>
  
  <entry>
    <title>Java Bean</title>
    <link href="https://gitflhub.github.io/2021/05/26/Java-Bean/"/>
    <id>https://gitflhub.github.io/2021/05/26/Java-Bean/</id>
    <published>2021-05-26T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:44.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="3-1自动装配Bean属性"><a href="#3-1自动装配Bean属性" class="headerlink" title="3.1自动装配Bean属性"></a>3.1自动装配Bean属性</h3><p>当Spring装配Bean属性时，有时候非常明确，就是需要将某个Bean的引用装配给指定属性。如果我们的应用上下文中只有一个javax.sql.DataSource类型的Bean，那么任意一个依赖DataSource的其他Bean就是需要这个DataSourceBean。毕竟这里只有一个DataSourceBean。<br>为了应对这种明确的装配场景，Spring提供了自动装配（autowiring）。与其显式地装配Bean的属性，为何不让Spring识别出可以自动装配的场景——不需要不需要考虑究竟要装配哪一个Bean引用。</p><h4 id="3-1-1-4种类型的自动装配"><a href="#3-1-1-4种类型的自动装配" class="headerlink" title="3.1.1 4种类型的自动装配"></a>3.1.1 4种类型的自动装配</h4><p>■ byName——把与Bean的属性具有相同名字（或者ID）的其他Bean自动装配到Bean的对应属性中。如果没有跟属性的名字相匹配的Bean，则该属性不进行装配。<br>■ byType——把与Bean的属性具有相同类型的其他Bean自动装配到Bean的对应属性中。如果没有跟属性的类型相匹配的Bean，则该属性不被装配。<br>■ constructor——把与Bean的构造器入参具有相同类型的其他Bean自动装配到Bean构造器的对应入参中。<br>■ autodetect——首先尝试使用constructor进行自动装配。如果失败，再尝试使用byType进行自动装配。<br><strong>byName自动装配</strong><br>如将以下配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;kenny2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Instrumentalist&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;song&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jingle Bells&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;instrument&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;piano&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>替换成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;kenny2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Instrumentalist&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;song&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jingle Bells&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;instrument&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Saxophone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>byName自动装配遵循一项约定：为属性自动装配ID与该属性的名字相同的Bean。<br><strong>byType自动装配</strong><br>byType自动装配的工作方式类似于byName自动装配，只不过不再是匹配属性的名字而是检查属性的类型。当我们尝试使用byType自动装配时，Spring会寻找哪一个Bean的类型与属性的类型相匹配。<br>了避免因为使用byType自动装配而带来的歧义，Spring为我们提供了另外两种选择：可以为自动装配标识一个首选Bean，或者可以取消某个Bean自动装配的候选资格。为自动装配标识一个首选Bean，可以使用<bean>元素的primary属性。如果只有一个自动装配的候选Bean的primary属性设置为true，那么该Bean将比其他候选Bean优先被选择。但是primary属性有个很怪异的一点：它默认设置为true。这意味着所有的候选Bean都将变成首选Bean（因此，其实就不存在首选Bean了）。所以，为了使用primary属性，我们不得不将所有非首选Bean的primary属性设置为false。<br>我们希望排除某些Bean，那可以设置这些Bean的autowire-candidate属性为false，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beanid=&quot;saxophone&quot;class=&quot;com.springinaction.pringidol.Saxophone&quot;autowire-candidate=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>constructor自动装配</strong><br>如果要通过构造器注入来配置Bean，那我们可以移除<constructor-arg>元素，由Spring在应用上下文中自动选择Bean注入到构造器入参中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;duke&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.PoeticJuggler&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Sonnect29&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Sonnet29&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最佳自动装配<br>设置autowire属性为autodetect，由Spring来决定。<br>自动装配顺序<br>constructor-&gt;byType-&gt;byname</p><h4 id="3-1-2-默认自动装配"><a href="#3-1-2-默认自动装配" class="headerlink" title="3.1.2 默认自动装配"></a>3.1.2 默认自动装配</h4><p>如果需要为Spring应用上下文中的每一个Bean（或者其中的大多数）配置相同相同的autowire属性，那么就可以要求Spring为它所创建的所有Bean应用相同的自动装配策略来简化配置。我们所需要做的仅仅是在根元素<beans>上增加一个default-autowire属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">http://www.springframework.org/schema/beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">http://www.w3.org/2001/XMLSchema-instance</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">http://www.springframework.org/schema/beans</span> <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span>/<span class="attr">spring-beans-3.0.xsd</span> <span class="attr">default-autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下，default-autowire属性被设置为none，标示所有Bean都不使用自动装配，除非Bean自己配置了autowire属性。在这里，我们将default-autowire属性设置为byType，希望每一个Bean的所有属性都使用byType自动装配策略进行自动装配。当然了，我们可以将default-autowire属性设置为任意一种有效的自动装配策略，并将其应用于Spring配置文件中的所有Bean。注意，我只是说default-autowire应用于指定Spring配置文件中的所有Bean；我可没说它应用于Spring应用上下文中的所有Bean。你可以在一个Spring应用上下文中定义多个配置文件，每一个配置文件都可以有自己的默认自动装配策略。同样，不能因为我们配置了一个默认的自动装配策略，就意味着所有的Bean都只能使用这个默认的自动装配策略。我们还可以使用<bean>元素的autowire属性来覆盖<beans>元素所配置的默认自动装配策略。</p><h4 id="3-1-3-混合使用默认装配和显示装配"><a href="#3-1-3-混合使用默认装配和显示装配" class="headerlink" title="3.1.3 混合使用默认装配和显示装配"></a>3.1.3 混合使用默认装配和显示装配</h4><p>举个例子，即使kennyBean已经配置为byType自动装配策略，但它仍然可以显式装配kenny的instrument属性，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;kenny&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.springidol.Instrumentalist&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;song&quot;</span> <span class="attr">value</span>=<span class="string">&quot;JingleBells&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;instrument&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;saxophone&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如，如果我们想为kennyBean的instrument属性装配null值，可以使用如下的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;kenny&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springinaction.springidol.Instrumentalist&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;song&quot;</span> <span class="attr">value</span>=<span class="string">&quot;JingleBells&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;instrument&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-使用注解装配"><a href="#3-2-使用注解装配" class="headerlink" title="3.2 使用注解装配"></a>3.2 使用注解装配</h3><p>从Spring2.5开始，最有趣的一种装配SpringBean的方式是使用注解自动装配Bean的属性。使用注解自动装配与在XML中使用autowire属性自动装配并没有太大差别。但是使用注解方式允许更细粒度的自动装配，我们可以选择性地标注某一个属性来对其应用自动装配。<br>Spring容器默认禁用注解装配。所以，在使用基于注解的自动装配前，我们需要在Spring配置中启用它。最简单的启用方式是使用Spring的context命名空间配置中的<context:annotation-config>元素，如下所示：</p><p><context:annotation-config>元素告诉Spring我们打算使用基于注解的自动装配。一旦配置完成，我们就可以对代码添加注解，标识Spring应该为属性、方法和构造器进行自动装配。Spring 3支持几种不同的用于自动装配的注解：<br>■Spring自带的@Atutowired注解；<br>■JSR-330的@Inject注解；<br>■JSR-250的@Resource注解。<br>我们首先介绍如何使用Spring自带的@Autowired注解，然后再介绍如何使用Java依赖注入标准（JSR-330）的@Inject和JSR-250的@Resource。</p><h4 id="3-2-1-使用-Autowired"><a href="#3-2-1-使用-Autowired" class="headerlink" title="3.2.1 使用@Autowired"></a>3.2.1 使用@Autowired</h4><p>@Autowired示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用@Autowired注解需要的声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;duke&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.PoeticJuggler&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标注@Autowired</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstrument</span><span class="params">(Instrument instrument)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.instrument = instrument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们还可以使用@Autowired注解直接标注属性，并删除setter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> Instrument instrument;</span><br></pre></td></tr></table></figure><p>@Autowired甚至不会受限于private关键字。即使in-strument属性是私有的实例变量，它仍然可以被自动装配。<br>如果没有匹配的Bean，如何让@Autowired注解远离失败。<br><strong>可选的自动装配</strong><br>默认情况下，@Autowired具有强契约特征，其所标注的属性或参数必须是可装配的。如果没有Bean可以装配到@Autowired所标注的属性或参数中，自动装配就会失败（抛出令人讨厌的NoSuchBeanDefinitionException）。这可能是我们所期望的处理方式——当自动装配无法完成时，让Spring尽早失败，远胜于以后抛出NullPointerExcepiton异常。<br>属性不一定非要装配，null值也是可以接受的。在这种场景下，可以通过设置@Autowired的required属性为false来配置自动装配是可选的。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> Instrument instrument;</span><br></pre></td></tr></table></figure><p>在这里，Spring将尝试装配instrument属性，但是如果没有查找到与之匹配的类型为Instrument的Bean，应用就不会发生任何问题，而instrument属性的值会设置为null。<br>注意required属性可以用于@Autowired注解所使用的任意地方。但是当使用构造器装配时，只有一个构造器可以将@Autowired的requeired属性设置为true。其他使用@Autowired注解所标注的构造器只能将required属性设置为false。此外，当使用@Autowired标注多个构造器时，Spring就会从所有满足装配条件的构造器中选择入参最多的那个构造器。<br>限定歧义性的依赖<br>另一方面，问题或许在于Spring并不缺少适合自动装配的Bean。可能会有足够多的Bean（或者至少2个）都完全满足装配条件，并且都可以被装配到属性或参数中。、@Autowired注解没有办法选择哪一个Bean才是它真正需要的。所以抛出NoSuchBeanDefinitionException异常，明确表明装配失败了。我们可以配合使用Spring的@Qualifier注解。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="meta">@Qualifier(&quot; guitar&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Instrument instrument;</span><br></pre></td></tr></table></figure><p>所示，@Qualifier注解将尝试注入ID为guitar的Bean。<br>除了通过Bean的ID来缩小选择范围，我们还可以通过在Bean上直接使用qualifier来缩小范围。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;saxophone1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.springidol.Piano&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;ppp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;ppp&quot;)</span><br><span class="line">private Instrument instrument;</span><br></pre></td></tr></table></figure><p>创建自定义的限定器（Qualifier）为了创建一个自定义的限定器注解，我们所需要做的仅仅是定义一个注解，并使用@Qualifier注解作为它的元注解。</p><h4 id="3-2-2-借助-Inject实现基于标准的自动装配"><a href="#3-2-2-借助-Inject实现基于标准的自动装配" class="headerlink" title="3.2.2 借助@Inject实现基于标准的自动装配"></a>3.2.2 借助@Inject实现基于标准的自动装配</h4><p>为了统一各种依赖注入框架的编程模型，JCP（JavaCommunityProcess）最近发布了Java依赖注入规范，JCP将其称为JSR-330，更常见的叫法是atinject。该规范为Java带来了通用依赖注入模型。<br>该注解几乎可以完全替换Spring的@Au-towired注解。所以，除了使用Spring特定的@Autowired注解，我们还可以选择使用@Inject注解来标注instrument属性：<br>限定@Inject所标注的属性<br>一样，@Inject注解易导致歧义性的Bean定义。相对于@Autowired所对应的@Qualifier，@Inject所对应的是@Named注解。</p><h4 id="3-2-3-在注解注入中使用表达式"><a href="#3-2-3-在注解注入中使用表达式" class="headerlink" title="3.2.3 在注解注入中使用表达式"></a>3.2.3 在注解注入中使用表达式</h4><p>可以通过@Value直接标注某个属性、方法或者方法参数，并传入一个String类型的表达式来装配属性。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot; Eruption&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> String song;</span><br></pre></td></tr></table></figure><p>使用SpEL从系统属性中获取一个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;#&#123;systemProperties.myFavoriteSong&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String song; </span><br></pre></td></tr></table></figure><h3 id="3-3-自动检测Bean"><a href="#3-3-自动检测Bean" class="headerlink" title="3.3 自动检测Bean"></a>3.3 自动检测Bean</h3><p><context:annotation-config>有助于完全消除Spring配置中的<property>和<constructor-arg>元素，我们仍需要使用<bean>元素显式定义Bean。<br>为了配置Spring自动检测，需要使用<context:component-scan>元素来代替<context:annotation-config>元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span> <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">&quot;constructor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.springidol&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">&lt;/ beans &gt;</span><br></pre></td></tr></table></figure><p>base-package属性标识了<context:component-scan>元素所扫描的包。</p><h4 id="3-3-1-为自动检测标注Bean"><a href="#3-3-1-为自动检测标注Bean" class="headerlink" title="3.3.1 为自动检测标注Bean"></a>3.3.1 为自动检测标注Bean</h4><p>默认情况下，<context:component-scan>查找使用构造型（stereotype）注解所标注的类，这些特殊的注解如下。<br>■@Component——通用的构造型注解，标识该类为Spring组件。<br>■@Controller——标识将该类定义为SpringMVCcontroller。<br>■@Repository——标识将该类定义为数据仓库。<br>■@Service——标识将该类定义为服务。<br>■使用@Component标注的任意自定义注解。<br>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;guiterID&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Guiter</span> <span class="keyword">implements</span> <span class="title">Instrument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Guiter</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;guiterguiterguiterguiter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-2-过滤组件扫描"><a href="#3-3-2-过滤组件扫描" class="headerlink" title="3.3.2 过滤组件扫描"></a>3.3.2 过滤组件扫描</h4><p>事实上，在如何扫描来获得候选Bean方面，<context:component-scan>非常灵活。通过为<context:component-scan>配置<context:include-filter>和/或者<context:exclude-filter>子元素，我们可以随意调整扫描行为。<br>增加一个包含过滤器来要求<context:component-scan>自动注册所有的Instrument实现类，</p><p><context:include-filter>的type和expression属性一起协作来定义组件扫描策略。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.springidol&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;assignable&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;com.springidol.Instrument&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;com.springidol.Piano&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/images/20190821/802092387_1566402904546_40DB6D999F602B2967DE046A26ACDAEB" alt="图片说明" title="图片标题"> </p><h3 id="3-4-基于Java的Spring配置"><a href="#3-4-基于Java的Spring配置" class="headerlink" title="3.4 基于Java的Spring配置"></a>3.4 基于Java的Spring配置</h3><h4 id="3-4-1-创建基于Java的配置"><a href="#3-4-1-创建基于Java的配置" class="headerlink" title="3.4.1 创建基于Java的配置"></a>3.4.1 创建基于Java的配置</h4><p>需要极少量的XML来启用Java配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-2-定义一个配置类"><a href="#3-4-2-定义一个配置类" class="headerlink" title="3.4.2 定义一个配置类"></a>3.4.2 定义一个配置类</h4><p>在 基于 Java 的 配置 里 使用@ Configuration 注解 的 Java 类， 就 等价 于 XML 配置 中的&lt; beans&gt; 元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringIdolConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Configuration注解会作为一个标识告知Spring：这个类将包含一个或多个SpringBean的定义。这些Bean的定义是使用@Bean注解所标注的方法。</p><h4 id="3-4-3-声明一个简单的Bean"><a href="#3-4-3-声明一个简单的Bean" class="headerlink" title="3.4.3 声明一个简单的Bean"></a>3.4.3 声明一个简单的Bean</h4><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringIdolConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performer <span class="title">duke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Juggler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的基于Java的配置中，并没有String属性。Bean的ID和类型都被视为方法签名的一部分。Bean的实际创建是在方法体中定义的。因为它们全部是Java代码，所以我们可以进行编译期检查来确保Bean的类型是合法类型，并且Bean的ID是唯一的。</p><h4 id="3-4-4-使用Spring的基于Java的配置进行注入"><a href="#3-4-4-使用Spring的基于Java的配置进行注入" class="headerlink" title="3.4.4 使用Spring的基于Java的配置进行注入"></a>3.4.4 使用Spring的基于Java的配置进行注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringIdolConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performer <span class="title">duke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Juggler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performer <span class="title">duke15</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Juggler(<span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performer <span class="title">kenny</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Instrumentalist kenny = <span class="keyword">new</span> Instrumentalist();</span><br><span class="line">        kenny.setSong(<span class="string">&quot;aaaaaaannnnnnnnnn&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> kenny;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Poem <span class="title">sonnet29</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Sonnet29();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Performer <span class="title">poeticDuke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoeticJuggler(sonnet29());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring的Java配置中，通过声明方法引用一个Bean并不等同于调用该方法。如果真的这样，每次调用sonnet29()，都将得到该Bean的一个新的实例。Spring要比这聪明多了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;3-1自动装配Bean属性&quot;&gt;&lt;a href=&quot;#3-1自动装配Bean属性&quot; class=&quot;headerlink&quot; title=&quot;3.1自动装配Bean属性&quot;&gt;&lt;/a&gt;3.1自动装配Bean属性&lt;/h3&gt;&lt;p&gt;当Spring装配Bean属性时，有时候非常明确，就</summary>
      
    
    
    
    <category term="Java" scheme="https://gitflhub.github.io/categories/Java/"/>
    
    
    <category term="Bean" scheme="https://gitflhub.github.io/tags/Bean/"/>
    
    <category term="Spring" scheme="https://gitflhub.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java实现堆排序，快速排序，归并排序</title>
    <link href="https://gitflhub.github.io/2021/05/26/Java%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>https://gitflhub.github.io/2021/05/26/Java%E5%AE%9E%E7%8E%B0%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</id>
    <published>2021-05-26T13:01:42.000Z</published>
    <updated>2021-07-15T03:58:33.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>堆排序(大根堆，降序排序为例)的算法思想</p><p>①将输入元素构造成堆</p><p>②构造完成后找到最右下元素的父节点开始进行局部调整</p><p>③依次往前，重复②的操作，直到调整到堆的根节点。</p><p>④输出堆顶元素</p><p>⑤重复②③④步骤，直到堆被清空。</p><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h3><p>主函数入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> solution;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct.Heap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Method3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化堆</span></span><br><span class="line">        Heap heap = <span class="keyword">new</span> Heap(<span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">18</span>&#125;);</span><br><span class="line">        <span class="comment">// 调整为大根堆</span></span><br><span class="line">        heap.turnMaxHeap();</span><br><span class="line">        <span class="comment">// 输出堆顶元素</span></span><br><span class="line">        <span class="keyword">while</span> (heap.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环输出堆顶元素</span></span><br><span class="line">            System.out.println(heap.peakHeapTop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Heap类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> struct;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设堆的最大大小为100</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 存放数据的元素</span></span><br><span class="line">    <span class="keyword">public</span> Integer[] elems = <span class="keyword">new</span> Integer[MAX_SIZE];</span><br><span class="line">    <span class="comment">// 堆的大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造堆的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(Integer[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            elems[i] = arr[i];</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造大根堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnMaxHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从最右下节点的父节点开始遍历</span></span><br><span class="line">        <span class="keyword">int</span> index = size / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 局部调整</span></span><br><span class="line">            turnPartialMaxHeap(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆进行局部调整</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentIndex 子树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnPartialMaxHeap</span><span class="params">(<span class="keyword">int</span> currentIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左孩子索引</span></span><br><span class="line">        Integer leftChildIndex = getLeftChildIndex(currentIndex);</span><br><span class="line">        <span class="comment">// 右孩子索引</span></span><br><span class="line">        Integer rightChildIndex = getRightChildIndex(currentIndex);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (leftChildIndex == <span class="keyword">null</span> &amp;&amp; rightChildIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明当前已经找到了叶结点</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftChildIndex != <span class="keyword">null</span> &amp;&amp; rightChildIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 只有左孩子</span></span><br><span class="line">            <span class="keyword">if</span> (elems[currentIndex] &lt; elems[leftChildIndex]) &#123;</span><br><span class="line">                Integer temp = elems[currentIndex];</span><br><span class="line">                elems[currentIndex] = elems[leftChildIndex];</span><br><span class="line">                elems[leftChildIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftChildIndex != <span class="keyword">null</span> &amp;&amp; rightChildIndex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 左孩子右孩子同时存在,取左右节点的最大值与父节点进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (elems[leftChildIndex] &gt; elems[rightChildIndex]) &#123;</span><br><span class="line">                <span class="comment">// 左孩子为孩子王</span></span><br><span class="line">                <span class="keyword">if</span> (elems[currentIndex] &lt; elems[leftChildIndex]) &#123;</span><br><span class="line">                    Integer temp = elems[currentIndex];</span><br><span class="line">                    elems[currentIndex] = elems[leftChildIndex];</span><br><span class="line">                    elems[leftChildIndex] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有孩子为孩子王或者左右孩子相等</span></span><br><span class="line">                <span class="keyword">if</span> (elems[currentIndex] &lt; elems[rightChildIndex]) &#123;</span><br><span class="line">                    Integer temp = elems[currentIndex];</span><br><span class="line">                    elems[currentIndex] = elems[rightChildIndex];</span><br><span class="line">                    elems[rightChildIndex] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续调整左右子树</span></span><br><span class="line">            turnPartialMaxHeap(<span class="number">2</span> * (currentIndex + <span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">            turnPartialMaxHeap(<span class="number">2</span> * (currentIndex + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 摘取堆顶元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">peakHeapTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果堆为空，则返回null</span></span><br><span class="line">        <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取出堆顶元素</span></span><br><span class="line">            res = elems[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 补上堆顶元素</span></span><br><span class="line">            elems[<span class="number">0</span>] = elems[size - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// size 自减</span></span><br><span class="line">            size--;</span><br><span class="line">            <span class="comment">// 重新建立大根堆</span></span><br><span class="line">            turnMaxHeap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的左孩子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLeftChild</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getLeftChildIndex(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[getLeftChildIndex(index)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取左孩子索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getLeftChildIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; (index + <span class="number">1</span>) * <span class="number">2</span> &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取节点的右孩子</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRightChild</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getRightChildIndex(index) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> elems[getRightChildIndex(index)];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取右孩子索引</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getRightChildIndex</span><span class="params">(Integer index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; (index + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span> &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span> (index + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>①将待排序数组的第一个元素作为标准，将比第一个元素小的放到参照元素的左边，将比第一个元素大的放到参照元素的右边。<br>②放置完成后，把原数组划分为参照元素前后两个子数组<br>③重复①②过程，直到子数组中只有一个元素时停止排序</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>主函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = quickSort(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>排序函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr        待排序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex   结束下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回开始结束下标之间的一次快排操作结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex) &#123;</span><br><span class="line">    <span class="comment">// 下标异常返回arr,跳出递归过程</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex || startIndex &lt; <span class="number">0</span> || endIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参考值</span></span><br><span class="line">    <span class="keyword">int</span> splitNum = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> frontIndex = startIndex;</span><br><span class="line">    <span class="keyword">int</span> rearIndex = endIndex;</span><br><span class="line">    <span class="comment">// 起始下标小于结束下标时进行循环</span></span><br><span class="line">    <span class="keyword">boolean</span> lastMoveIsFront = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (rearIndex &gt; frontIndex) &#123;</span><br><span class="line">        <span class="comment">// 从数组尾巴上找到第一个比参考值小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (rearIndex &gt; frontIndex &amp;&amp; arr[rearIndex] &gt;= splitNum) &#123;</span><br><span class="line">            rearIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断循环跳出原因</span></span><br><span class="line">        <span class="keyword">if</span> (arr[rearIndex] &lt; splitNum) &#123;</span><br><span class="line">            <span class="comment">// 将小数左移</span></span><br><span class="line">            arr[frontIndex++] = arr[rearIndex];</span><br><span class="line">            <span class="comment">// 标记最后一次移动是头指针</span></span><br><span class="line">            lastMoveIsFront = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从数组头部找到一个比参考值大的元素</span></span><br><span class="line">        <span class="keyword">while</span> (rearIndex &gt; frontIndex &amp;&amp; arr[frontIndex] &lt;= splitNum) &#123;</span><br><span class="line">            frontIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断循环跳出原因</span></span><br><span class="line">    <span class="keyword">if</span> (arr[frontIndex] &gt; splitNum) &#123;</span><br><span class="line">        <span class="comment">// 将大数后移</span></span><br><span class="line">        arr[rearIndex--] = arr[frontIndex];</span><br><span class="line">        <span class="comment">// 标记最后一次移动是尾指针</span></span><br><span class="line">        lastMoveIsFront = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将参考值放入合适的位置 此处犯过错误</span></span><br><span class="line">    <span class="keyword">if</span> (lastMoveIsFront) &#123;</span><br><span class="line">        arr[frontIndex--] = splitNum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[frontIndex++] = splitNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分治处理当前参考值左右边子数组</span></span><br><span class="line">    quickSort(arr, startIndex, rearIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, rearIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>①将待排序数组的以2,4,8,,,2^n的步长划分为若干个子数组<br>②对这些子数组进行排序，这里选择的是快速排序</p><h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="comment">// 起始步长为1</span></span><br><span class="line">        <span class="keyword">int</span> spet = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (spet &lt; arr.length) &#123;</span><br><span class="line">            spet *= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i += spet) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i;</span><br><span class="line">                <span class="keyword">int</span> end = i + spet - <span class="number">1</span> &lt; arr.length - <span class="number">1</span> ? i + spet - <span class="number">1</span> : arr.length - <span class="number">1</span>;</span><br><span class="line">                quickSort(arr, start, end);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;堆排序&quot;&gt;&lt;a href=&quot;#堆排序&quot; class=&quot;headerlink&quot; title=&quot;堆排序&quot;&gt;&lt;/a&gt;堆排序&lt;/h2&gt;&lt;h3 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算法思想&quot;&gt;&lt;/a&gt;算法思</summary>
      
    
    
    
    <category term="算法" scheme="https://gitflhub.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="https://gitflhub.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 制作 Anki 卡片</title>
    <link href="https://gitflhub.github.io/2021/05/15/Markdown-%E5%88%B6%E4%BD%9C-Anki-%E5%8D%A1%E7%89%87/"/>
    <id>https://gitflhub.github.io/2021/05/15/Markdown-%E5%88%B6%E4%BD%9C-Anki-%E5%8D%A1%E7%89%87/</id>
    <published>2021-05-15T13:01:42.000Z</published>
    <updated>2021-07-15T04:02:49.863Z</updated>
    
    <content type="html"><![CDATA[<p>MarkDown 编辑器</p><h3 id="方式一：MarkDown-编辑器"><a href="#方式一：MarkDown-编辑器" class="headerlink" title="方式一：MarkDown 编辑器"></a>方式一：MarkDown 编辑器</h3><h4 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h4><p>这里以Typora为例：<br>1.打开MarkDown 编辑器<br>2.设置标题层级<br>3.四级标题#### 这层标题为面试的具体问题，如“JRE和JDK的区别？”<br>4.五级标题##### 这层标题为面试问题的具体答案,示例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># JAVA工程师面试</span><br><span class="line"></span><br><span class="line">## 1.JAVA </span><br><span class="line"></span><br><span class="line">### (1)Java基础</span><br><span class="line"></span><br><span class="line">#### JRE和JDK的区别</span><br><span class="line"></span><br><span class="line">##### JDK Java Development Kit,Java 开发工具包，提供了开发环境和运行环境</span><br><span class="line"></span><br><span class="line">##### JRE Java Runtime Environment Java 运行环境，为Java提供了所需的环境</span><br><span class="line"></span><br><span class="line">##### 运行Java程序，JRE即可</span><br><span class="line"></span><br><span class="line">##### 编写Java程序，需要安装JDK</span><br></pre></td></tr></table></figure></p><h4 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h4><h5 id="1-转为Anki批量格式CSV"><a href="#1-转为Anki批量格式CSV" class="headerlink" title="1.转为Anki批量格式CSV"></a>1.转为Anki批量格式CSV</h5><p>网上有一个大佬做了Markdown转Anki卡片的功能，链接如下<br><a href="https://hintsnet.com/tools/md2anki/index.html">https://hintsnet.com/tools/md2anki/index.html</a></p><h5 id="2-格式调整"><a href="#2-格式调整" class="headerlink" title="2.格式调整"></a>2.格式调整</h5><p>由于下载来的文件里面默认HTML标签是&lt; ol &gt;,在文本编辑器中批量替换为&lt; ul &gt;</p><h5 id="3-导入Anki"><a href="#3-导入Anki" class="headerlink" title="3.导入Anki"></a>3.导入Anki</h5><h3 id="方式二：网页数据爬取"><a href="#方式二：网页数据爬取" class="headerlink" title="方式二：网页数据爬取"></a>方式二：网页数据爬取</h3><h4 id="网页爬取数据"><a href="#网页爬取数据" class="headerlink" title="网页爬取数据"></a>网页爬取数据</h4><h5 id="爬取工具类"><a href="#爬取工具类" class="headerlink" title="爬取工具类"></a>爬取工具类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jsoup.Jsoup;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Document;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.nodes.Element;</span><br><span class="line"><span class="keyword">import</span> org.jsoup.select.Elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 网页抓取工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> htmltest 要获取的资源URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> laber    anki标签</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">(String htmltest, String laber)</span> </span>&#123;</span><br><span class="line">        String html = htmltest;</span><br><span class="line">        <span class="comment">// HTML文档对象</span></span><br><span class="line">        Document doc = Jsoup.parse(html);</span><br><span class="line">        Elements rows = doc.select(<span class="string">&quot;div[class=interview_detail]&quot;</span>).get(<span class="number">0</span>).select(<span class="string">&quot;ul&quot;</span>).select(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">        Elements rowTitle = doc.select(<span class="string">&quot;div[class=interview_detail]&quot;</span>);</span><br><span class="line">        <span class="comment">// 生成Anki题目</span></span><br><span class="line">        Element pFirst = rowTitle.select(<span class="string">&quot;p&quot;</span>).first();</span><br><span class="line">        <span class="comment">// rowTitle.remove(pFirst);</span></span><br><span class="line"></span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        String res = rowTitle.html();</span><br><span class="line">        <span class="keyword">if</span> (rows.size() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取网页结构指定的div[class=interview_wrap] 的代码信息</span></span><br><span class="line">            String title = doc.select(<span class="string">&quot;div[class=interview_wrap]&quot;</span>).select(<span class="string">&quot;h2&quot;</span>).get(<span class="number">0</span>).text();</span><br><span class="line">            <span class="comment">// 替换回车</span></span><br><span class="line">            res = res.replaceAll(<span class="string">&quot;(\\r\\n|\\n|\\n\\r)&quot;</span>, <span class="string">&quot; &quot;</span>)</span><br><span class="line">                    .replaceAll(<span class="string">&quot;\t&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    .replaceAll(<span class="string">&quot;class=\&quot;language-java\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (pFirst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 删除空行</span></span><br><span class="line">                res = res.replaceAll(pFirst.html(), <span class="string">&quot;&quot;</span>).replaceAll(<span class="string">&quot;&lt;p&gt;&lt;/p&gt;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// title 是anki卡片正面</span></span><br><span class="line">            stringBuffer.append(title).append(<span class="string">&quot;\t &quot;</span>);</span><br><span class="line">            <span class="comment">// 标签分类</span></span><br><span class="line">            stringBuffer.append(laber).append(<span class="string">&quot;\t &quot;</span>);</span><br><span class="line">            <span class="comment">// res 是anki卡片反面</span></span><br><span class="line">            stringBuffer.append(res);</span><br><span class="line">            System.out.println(stringBuffer.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="maven-依赖"><a href="#maven-依赖" class="headerlink" title="maven 依赖"></a>maven 依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Script</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个文件里面存放了链接信息</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;src/main/resources/url.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取配置信息</span></span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">            String str;</span><br><span class="line">            String label = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> ((str = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取Anki标签</span></span><br><span class="line">                <span class="keyword">if</span> (str.contains(<span class="string">&quot;@&quot;</span>)) &#123;</span><br><span class="line">                    label = str.substring(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 链接拼接</span></span><br><span class="line">                    String urlStr = <span class="string">&quot;https://www.javanav.com/interview/&quot;</span> + str + <span class="string">&quot;.html&quot;</span>; <span class="comment">// 网址</span></span><br><span class="line">                    URL url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line">                    String result = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(url.openStream()))</span><br><span class="line">                            .lines().parallel().collect(Collectors.joining(System.lineSeparator()));</span><br><span class="line">                    <span class="comment">// 调用爬取入口</span></span><br><span class="line">                    Test1.demo1(result, label);</span><br><span class="line">                    <span class="comment">// 读取太快会被反爬虫</span></span><br><span class="line">                    Thread.sleep(<span class="number">10</span> * <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="控制台打印结果（部分）"><a href="#控制台打印结果（部分）" class="headerlink" title="控制台打印结果（部分）"></a>控制台打印结果（部分）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==和equals的区别是什么? Java基础 &lt;ul&gt;   &lt;li&gt;== 是关系运算符，equals() 是方法，结果都返回布尔值&lt;/li&gt;   &lt;li&gt;Object 的 == 和 equals() 比较的都是地址，作用相同&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;== 作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;基本类型，比较值是否相等&lt;/li&gt;   &lt;li&gt;引用类型，比较内存地址值是否相等&lt;/li&gt;   &lt;li&gt;不能比较没有父子关系的两个对象&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;equals()方法的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;JDK 中的类一般已经重写了 equals()，比较的是内容&lt;/li&gt;   &lt;li&gt;自定义类如果没有重写 equals()，将调用父类（默认 Object 类）的 equals() 方法，Object 的 equals() 比较使用了 this == obj&lt;/li&gt;   &lt;li&gt;可以按照需求逻辑，重写对象的 equals() 方法（重写 equals方法，一般须重写 hashCode方法）&lt;/li&gt;  &lt;/ul&gt;  </span><br><span class="line">基本类型和包装类对象使用 == 和 equals进行比较的结果？ Java基础 &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;1、值不同，使用 ＝＝ 和 equals() 比较都返回 false&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、值相同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;p&gt;使用 ＝＝ 比较：&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;基本类型 － 基本类型、基本类型 － 包装对象返回 true&lt;/li&gt;   &lt;li&gt;包装对象 － 包装对象，非同一个对象（对象的内存地址不同）返回 false；对象的内存地址相同返回 true，如下值等于 100 的两个 Integer 对象（原因是 JVM 缓存部分基本类型常用的包装类对象，如 Integer -128 ~ 127 是被缓存的）&lt;/li&gt;  &lt;/ul&gt;  &lt;pre&gt; &lt;code&gt; Integer i1 = 100; &amp;nbsp;Integer i2 = 100; &amp;nbsp;Integer i3 = 200; &amp;nbsp;Integer i4 = 200; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;System.out.println(i1==i2); //打印true &amp;nbsp;System.out.println(i3==i4); //打印false&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;使用 equals() 比较&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;包装对象－基本类型返回 true&lt;/li&gt;   &lt;li&gt;包装对象－包装对象返回 true&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;3、不同类型的对象对比，返回 false&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;JDK1.8，实验代码&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;byte b1 = 127; Byte b2 = new Byte(&quot;127&quot;); Byte b3 = new Byte(&quot;127&quot;); System.out.println(&quot;Byte 基本类型和包装对象使用 == 比较 : &quot; + (b1 == b2)); System.out.println(&quot;Byte 基本类型和包装对象使用 equals 比较 : &quot; + b2.equals(b1)); System.out.println(&quot;Byte 包装对象和包装对象使用 == 比较 : &quot; + (b2 == b3)); System.out.println(&quot;Byte 包装对象和包装对象使用 equals 比较 : &quot; + b2.equals(b3)); System.out.println();  short s1 = 12; Short s2 = new Short(&quot;12&quot;); Short s3 = new Short(&quot;12&quot;); System.out.println(&quot;Short 基本类型和包装对象使用 == 比较 : &quot; + (s1 == s2)); System.out.println(&quot;Short 基本类型和包装对象使用 equals 比较 : &quot; + s2.equals(s1)); System.out.println(&quot;Short 包装对象和包装对象使用 == 比较 : &quot; + (s2 == s3)); System.out.println(&quot;Short 包装对象和包装对象使用 equals 比较 : &quot; + s2.equals(s3)); System.out.println();  char c1 = &#x27;A&#x27;; Character c2 = new Character(&#x27;A&#x27;); Character c3 = new Character(&#x27;A&#x27;); System.out.println(&quot;Character 基本类型和包装对象使用 == 比较 : &quot; + (c1 == c2)); System.out.println(&quot;Character 基本类型和包装对象使用 equals 比较 : &quot; + c2.equals(c1)); System.out.println(&quot;Character 包装对象和包装对象使用 == 比较 : &quot; + (c2 == c3)); System.out.println(&quot;Character 包装对象和包装对象使用 equals 比较 : &quot; + c2.equals(c3)); System.out.println();  int i1 = 10000; Integer i2 = new Integer(10000); Integer i3 = new Integer(10000); System.out.println(&quot;Integer 基本类型和包装对象使用 == 比较 : &quot; + (i1 == i2)); System.out.println(&quot;Integer 基本类型和包装对象使用 equals 比较 : &quot; + i2.equals(i1)); System.out.println(&quot;Integer 包装对象和包装对象使用 == 比较 : &quot; + (i2 == i3)); System.out.println(&quot;Integer 包装对象和包装对象使用 equals 比较 : &quot; + i2.equals(i3)); System.out.println();  long l1 = 1000000000000000L; Long l2 = new Long(&quot;1000000000000000&quot;); Long l3 = new Long(&quot;1000000000000000&quot;); System.out.println(&quot;Long 基本类型和包装对象使用 == 比较 : &quot; + (l1 == l2)); System.out.println(&quot;Long 基本类型和包装对象使用 equals 比较 : &quot; + l2.equals(l1)); System.out.println(&quot;Long 包装对象和包装对象使用 == 比较 : &quot; + (l2 == l3)); System.out.println(&quot;Long 包装对象和包装对象使用 equals 比较 : &quot; + l2.equals(l3)); System.out.println();  float f1 = 10000.111F; Float f2 = new Float(&quot;10000.111&quot;); Float f3 = new Float(&quot;10000.111&quot;); System.out.println(&quot;Float 基本类型和包装对象使用 == 比较 : &quot; + (f1 == f2)); System.out.println(&quot;Float 基本类型和包装对象使用 equals 比较 : &quot; + f2.equals(f1)); System.out.println(&quot;Float 包装对象和包装对象使用 == 比较 : &quot; + (f2 == f3)); System.out.println(&quot;Float 包装对象和包装对象使用 equals 比较 : &quot; + f2.equals(f3)); System.out.println();  double d1 = 10000.111; Double d2 = new Double(&quot;10000.111&quot;); Double d3 = new Double(&quot;10000.111&quot;); System.out.println(&quot;Double 基本类型和包装对象使用 == 比较 : &quot; + (d1 == d2)); System.out.println(&quot;Double 基本类型和包装对象使用 equals 比较 : &quot; + d2.equals(d1)); System.out.println(&quot;Double 包装对象和包装对象使用 == 比较 : &quot; + (d2 == d3)); System.out.println(&quot;Double 包装对象和包装对象使用 equals 比较 : &quot; + d2.equals(d3)); System.out.println();  boolean bl1 = true; Boolean bl2 = new Boolean(&quot;true&quot;); Boolean bl3 = new Boolean(&quot;true&quot;); System.out.println(&quot;Boolean 基本类型和包装对象使用 == 比较 : &quot; + (bl1 == bl2)); System.out.println(&quot;Boolean 基本类型和包装对象使用 equals 比较 : &quot; + bl2.equals(bl1)); System.out.println(&quot;Boolean 包装对象和包装对象使用 == 比较 : &quot; + (bl2 == bl3)); System.out.println(&quot;Boolean 包装对象和包装对象使用 equals 比较 : &quot; + bl2.equals(bl3));&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;br&gt; 运行结果&lt;/p&gt;  &lt;pre&gt; &lt;code&gt;Byte 基本类型和包装对象使用 == 比较 : true Byte 基本类型和包装对象使用 equals 比较 : true Byte 包装对象和包装对象使用 == 比较 : false Byte 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Short 基本类型和包装对象使用 == 比较 : true Short 基本类型和包装对象使用 equals 比较 : true Short 包装对象和包装对象使用 == 比较 : false Short 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Character 基本类型和包装对象使用 == 比较 : true Character 基本类型和包装对象使用 equals 比较 : true Character 包装对象和包装对象使用 == 比较 : false Character 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Integer 基本类型和包装对象使用 == 比较 : true Integer 基本类型和包装对象使用 equals 比较 : true Integer 包装对象和包装对象使用 == 比较 : false Integer 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Long 基本类型和包装对象使用 == 比较 : true Long 基本类型和包装对象使用 equals 比较 : true Long 包装对象和包装对象使用 == 比较 : false Long 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Float 基本类型和包装对象使用 == 比较 : true Float 基本类型和包装对象使用 equals 比较 : true Float 包装对象和包装对象使用 == 比较 : false Float 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Double 基本类型和包装对象使用 == 比较 : true Double 基本类型和包装对象使用 equals 比较 : true Double 包装对象和包装对象使用 == 比较 : false Double 包装对象和包装对象使用 equals 比较 : true &amp;nbsp; Boolean 基本类型和包装对象使用 == 比较 : true Boolean 基本类型和包装对象使用 equals 比较 : true Boolean 包装对象和包装对象使用 == 比较 : false Boolean 包装对象和包装对象使用 equals 比较 : true&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt;  &lt;p&gt;ps：可以延伸一个问题，基本类型与包装对象的拆/装箱的过程&lt;/p&gt;</span><br><span class="line">什么是装箱？什么是拆箱？装箱和拆箱的执行过程？常见问题？ Java基础   &lt;p&gt;装箱：基本类型转变为包装器类型的过程。&lt;br&gt; 拆箱：包装器类型转变为基本类型的过程。&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;//JDK1.5之前是不支持自动装箱和自动拆箱的，定义Integer对象，必须 Integer i = new Integer(8); &amp;nbsp; //JDK1.5开始，提供了自动装箱的功能，定义Integer对象可以这样 Integer i = 8; &amp;nbsp; int n = i;//自动拆箱&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&lt;br&gt; &amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;2、装箱和拆箱的执行过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;装箱是通过调用包装器类的 valueOf 方法实现的&lt;/li&gt;   &lt;li&gt;拆箱是通过调用包装器类的 xxxValue 方法实现的，xxx代表对应的基本数据类型。&lt;/li&gt;   &lt;li&gt;如int装箱的时候自动调用Integer的valueOf(int)方法；Integer拆箱的时候自动调用Integer的intValue方法。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;&lt;span style=&quot;color:#000000&quot;&gt;&lt;strong&gt;3、常见问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;整型的包装类 valueOf 方法返回对象时，在常用的取值范围内，会返回缓存对象。&lt;/li&gt;   &lt;li&gt;浮点型的包装类 valueOf 方法返回新的对象。&lt;/li&gt;   &lt;li&gt;布尔型的包装类 valueOf 方法 Boolean类的静态常量 TRUE | FALSE。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;实验代码&lt;/p&gt;  &lt;pre&gt; &lt;code&gt;Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1 == i2);//true System.out.println(i3 == i4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Double d1 = 100.0; Double d2 = 100.0; Double d3 = 200.0; Double d4 = 200.0; System.out.println(d1 == d2);//false System.out.println(d3 == d4);//false &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; Boolean b1 = false; Boolean b2 = false; Boolean b3 = true; Boolean b4 = true; System.out.println(b1 == b2);//true System.out.println(b3 == b4);//true&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;包含算术运算会触发自动拆箱。&lt;/li&gt;   &lt;li&gt;存在大量自动装箱的过程，如果装箱返回的包装对象不是从缓存中获取，会创建很多新的对象，比较消耗内存。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;Integer s1 = 0; long t1 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s1 += i; &#125; long t2 = System.currentTimeMillis(); System.out.println(&quot;使用Integer，递增相加耗时：&quot; + (t2 - t1));//使用Integer，递增相加耗时：68 &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp; int s2 = 0; long t3 = System.currentTimeMillis(); for(int i = 0; i &amp;lt;1000 * 10000; i++)&#123; &amp;nbsp;&amp;nbsp; &amp;nbsp;s2 += i; &#125; long t4 = System.currentTimeMillis(); System.out.println(&quot;使用int，递增相加耗时：&quot; + (t4 - t3));//使用int，递增相加耗时：6&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;ps：可深入研究一下 javap 命令，看下自动拆箱、装箱后的class文件组成。&lt;br&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看一下 JDK 中 Byte、Short、Character、Integer、Long、Boolean、Float、Double的 valueOf 和 xxxValue 方法的源码（xxx代表基本类型如intValue）。&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">hashCode()相同，equals()也一定为true吗？ Java基础 &lt;p&gt;首先，答案肯定是不一定。同时反过来 equals() 为true，hashCode() 也不一定相同。&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;类的 hashCode() 方法和 equals() 方法都可以重写，返回的值完全在于自己定义。&lt;/li&gt;   &lt;li&gt;hashCode() 返回该对象的哈希码值；equals() 返回两个对象是否相等。&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;关于 hashCode() 和 equals() 是方法是有一些 常规协定：&lt;/p&gt;  &lt;p&gt;1、两个对象用 equals() 比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。&lt;/p&gt;  &lt;p&gt;2、两个对象用 equals() 比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，以提高哈希表性能。&lt;/p&gt;  &lt;p&gt;3、重写 equals() 方法，必须重写 hashCode() 方法，以保证 equals() 方法相等时两个对象 hashcode() 返回相同的值。&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;  &lt;p&gt;就像打人是你的能力，但打伤了就违法了。重写 equals 和 hashCode 方法返回是否为 true 是你的能力，但你不按照上述协议进行控制，在用到对象 hash 和 equals 逻辑判断相等时会出现意外情况，如 HashMap 的 key 是否相等。&lt;/p&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">final在java中的作用 Java基础   &lt;ul&gt;   &lt;li&gt;被 final 修饰的类，不能够被继承&lt;/li&gt;   &lt;li&gt;被 final 修饰的成员变量必须要初始化，赋初值后不能再重新赋值(可以调用对象方法修改属性值)。对基本类型来说是其值不可变；对引用变量来说其引用不可变，即不能再指向其他的对象&lt;/li&gt;   &lt;li&gt;被 final 修饰的方法不能重写&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">final finally finalize()区别 Java基础 &lt;ul&gt;   &lt;li&gt;final 表示最终的、不可改变的。用于修饰类、方法和变量。final 修饰的类不能被继承；final 方法也同样只能使用，不能重写，但能够重载；final 修饰的成员变量必须在声明时给定初值或者在构造方法内设置初始值，只能读取，不可修改；final 修饰的局部变量必须在声明时给定初值；final 修饰的变量是非基本类型，对象的引用地址不能变，但对象的属性值可以改变&lt;/li&gt;   &lt;li&gt;finally 异常处理的一部分，它只能用在 try/catch 语句中，表示希望 finally 语句块中的代码最后一定被执行（存在一些情况导致 finally 语句块不会被执行，如 jvm 结束）&lt;/li&gt;   &lt;li&gt;finalize() 是在 java.lang.Object 里定义的，Object 的 finalize() 方法什么都不做，对象被回收时 finalize() 方法会被调用。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要清理工作，在垃圾收集器删除对象之前被调用的。一般情况下，此方法由JVM调用。特殊情况下，可重写 finalize() 方法，当对象被回收的时候释放一些资源，须调用 super.finalize() 。&lt;/li&gt;  &lt;/ul&gt;  </span><br><span class="line">finally语句块一定执行吗？ Java基础   &lt;ul&gt;   &lt;li&gt;直接返回未执行到 try-finally 语句块&lt;/li&gt;   &lt;li&gt;抛出异常未执行到 try-finally 语句块&lt;/li&gt;   &lt;li&gt;系统退出未执行到 finally 语句块&lt;/li&gt;  &lt;/ul&gt;  &lt;p&gt;等...&lt;/p&gt;  &lt;p&gt;代码如下&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;public static String test() &#123;     String str = null;     int i = 0;     if (i == 0) &#123;         return str;//直接返回未执行到finally语句块     &#125;     try &#123;         System.out.println(&quot;try...&quot;);         return str;     &#125; finally &#123;         System.out.println(&quot;finally...&quot;);     &#125; &#125;   public static String test2() &#123;     String str = null;     int i = 0;     i = i / 0;//抛出异常未执行到finally语句块     try &#123;         System.out.println(&quot;try...&quot;);         return str;     &#125; finally &#123;         System.out.println(&quot;finally...&quot;);     &#125; &#125;   public static String test3() &#123;     String str = null;     try &#123;         System.out.println(&quot;try...&quot;);         System.exit(0);//系统退出未执行到finally语句块         return str;     &#125; finally &#123;         System.out.println(&quot;finally...&quot;);     &#125; &#125;&lt;/code&gt;&lt;/pre&gt;  &lt;p&gt;&amp;nbsp;&lt;/p&gt;</span><br><span class="line">final与static的区别 Java基础   &lt;ul&gt;   &lt;li&gt;都可以修饰类、方法、成员变量。&lt;/li&gt;   &lt;li&gt;都不能用于修饰构造方法。&lt;/li&gt;   &lt;li&gt;static 可以修饰类的代码块，final 不可以。&lt;/li&gt;   &lt;li&gt;static 不可以修饰方法内的局部变量，final 可以。&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;static：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;static 修饰表示静态或全局，被修饰的属性和方法属于类，可以用类名.静态属性 / 方法名 访问&lt;/li&gt;   &lt;li&gt;static 修饰的代码块表示静态代码块，当 Java 虚拟机（JVM）加载类时，就会执行该代码块,只会被执行一次&lt;/li&gt;   &lt;li&gt;static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，只会被创建一次&lt;/li&gt;   &lt;li&gt;static 修饰的变量可以重新赋值&lt;/li&gt;   &lt;li&gt;static 方法中不能用 this 和 super 关键字&lt;/li&gt;   &lt;li&gt;static 方法必须被实现，而不能是抽象的abstract&lt;/li&gt;   &lt;li&gt;static 方法不能被重写&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:#000000&quot;&gt;final：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;  &lt;ul&gt;   &lt;li&gt;final 修饰表示常量、一旦创建不可改变&lt;/li&gt;   &lt;li&gt;final 标记的成员变量必须在声明的同时赋值，或在该类的构造方法中赋值，不可以重新赋值&lt;/li&gt;   &lt;li&gt;final 方法不能被子类重写&lt;/li&gt;   &lt;li&gt;final 类不能被继承，没有子类，final 类中的方法默认是 final 的&lt;/li&gt;  &lt;/ul&gt;    &lt;p&gt;final 和 static 修饰成员变量加载过程例子&lt;/p&gt;  &lt;pre&gt; &lt;code &gt;import java.util.Random;   public class TestStaticFinal &#123;   public static void main(String[] args) &#123; StaticFinal sf1 = new StaticFinal(); StaticFinal sf2 = new StaticFinal();  System.out.println(sf1.fValue == sf2.fValue);//打印false System.out.println(sf1.sValue == sf2.sValue);//打印true &#125; &#125;   class StaticFinal &#123;  final int fValue = new Random().nextInt(); static int sValue = new Random().nextInt();  &#125;&lt;/code&gt;&lt;/pre&gt;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MarkDown 编辑器&lt;/p&gt;
&lt;h3 id=&quot;方式一：MarkDown-编辑器&quot;&gt;&lt;a href=&quot;#方式一：MarkDown-编辑器&quot; class=&quot;headerlink&quot; title=&quot;方式一：MarkDown 编辑器&quot;&gt;&lt;/a&gt;方式一：MarkDown 编辑器&lt;/</summary>
      
    
    
    
    <category term="资料整理" scheme="https://gitflhub.github.io/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Anki" scheme="https://gitflhub.github.io/tags/Anki/"/>
    
  </entry>
  
</feed>
